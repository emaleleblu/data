<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Tutorial Trading Algoritmico Archivi - Data Trading</title>
	<atom:link href="https://datatrading.info/category/tutorial-trading-algoritmico/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Tecnologie Digitali applicate al Trading</description>
	<lastBuildDate>Sat, 23 Jul 2022 10:19:39 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://datatrading.info/wp-content/uploads/2019/04/favico.-300x300.jpg</url>
	<title>Tutorial Trading Algoritmico Archivi - Data Trading</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Motore di Backtesting con Python – Parte IX (Connessione con IB)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-ix-connessione-con-ib/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 24 May 2017 09:23:37 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=893</guid>

					<description><![CDATA[<p>È passato un po &#8216;di tempo da quando abbiamo la serie di articoli realtivi ad un ambiente di backtesting basato sugli eventi, che abbiamo iniziato a discutere in questo articolo. Nella Parte VI è stato descritto come implementare un modello di ExecutionHandler funzionante per una simulazione storica di backtesting. In questo si vuole implementare il &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ix-connessione-con-ib/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte IX (Connessione con IB)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ix-connessione-con-ib/">Motore di Backtesting con Python – Parte IX (Connessione con IB)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="893" class="elementor elementor-893">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-d909e8c elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="d909e8c" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-0d905a3" data-id="0d905a3" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-0b147db elementor-widget elementor-widget-text-editor" data-id="0b147db" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>È passato un po &#8216;di tempo da quando abbiamo la serie di articoli realtivi ad un ambiente di backtesting basato sugli eventi, che abbiamo iniziato a discutere in <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">questo articolo</a>. Nella <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/">Parte VI</a> è stato descritto come implementare un modello di ExecutionHandler funzionante per una simulazione storica di backtesting. In questo si vuole implementare il gestore dell&#8217;API di Interactive Brokers in modo da poter utilizzare l&#8217;ExecutionHandler per il live trading.</p>
<p>In precedenza abbiamo visto come come scaricare Trader Workstation e creare un account demo di Interactive Brokers e su come creare <a href="http://datatrading.info/come-creare-un-account-demo-su-interactive-brokers/">un&#8217;interfaccia di base verso l&#8217;API IB usando IbPy</a>. Questo articolo descrivere come collegare l&#8217;interfaccia IbPy all&#8217;interno di un sistema event-driven, in modo tale che, quando accoppiato con un feed di dati di mercato real-time, costituirà la base per un sistema di esecuzione automatizzato.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d565fc2 elementor-widget elementor-widget-heading" data-id="d565fc2" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Connessione con Interactive Brokers</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-9b869e5 elementor-widget elementor-widget-text-editor" data-id="9b869e5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">L&#8217;idea alla base della classe </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: #e83e8c;">IBExecutionHandler</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);"> consiste nel ricevere istanze </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: #e83e8c;">OrderEvent</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);"> dalla coda degli eventi ed eseguirli direttamente verso l&#8217;API di ordine di Interactive Brokers utilizzando la libreria IbPy. La classe gestirà anche i messaggi &#8220;Server Response&#8221; inviati in rispota dalla stessa API. In questa fase, l&#8217;unica azione intrapresa sarà creare le corrispondenti istanze </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: #e83e8c;">FillEvent</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);"> corrispondenti che verranno quindi ritrasferite nella coda degli eventi.</span></p><p>La stessa classe può essere facilmente resa più complessa, includendo una logica di ottimizzazione dell&#8217;esecuzione e una sofisticata gestione degli errori. Tuttavia, in questa fase è opportuno mantenerla relativamente semplice in modo che si possa capire le principali funzionalità ed estenderle nella direzione che si adatta al tuo particolare stile di trading.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a73e2fa elementor-widget elementor-widget-heading" data-id="a73e2fa" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Implementazione</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-3bf2434 elementor-widget elementor-widget-text-editor" data-id="3bf2434" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Come sempre, il primo passo è creare il file Python e importare le librerie necessarie. Il file si chiama <code style="color: #e83e8c;">ib_execution.py</code> e risiede nella stessa directory degli altri file event-driven.

Importiamo le necessarie librerie per la gestione della data / ora, gli oggetti IbPy e i specifici oggetti Event gestiti da <code style="color: #e83e8c;">IBExecutionHandler</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4a82a4b elementor-widget elementor-widget-bdt-source-code" data-id="4a82a4b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py

import datetime
import time

from ib.ext.Contract import Contract
from ib.ext.Order import Order
from ib.opt import ibConnection, message

from event import FillEvent, OrderEvent
from execution import ExecutionHandler</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-231f01b elementor-widget elementor-widget-text-editor" data-id="231f01b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>A questo punto è necessario definire la classe <code style="color: #e83e8c;">IBExecutionHandler</code>. Innanzitutto il costruttore <code style="color: #e83e8c;">__init__</code> richiede in input la coda degli eventi. Prevende inoltre la specifica di <code style="color: #e83e8c;">order_routing</code>, che viene impostata a &#8220;SMART&#8221; come default. Nel caso l&#8217;exchange abbia specifici requisiti, questi possono essere specificati in questo costruttore. Inoltre la <code style="color: #e83e8c;">currency</code> predefinita è stata impostata sui Dollari USA.</p><p>All&#8217;interno del metodo si crea un dizionario <code style="color: #e83e8c;">fill_dict</code>, necessario per l&#8217;utilizzo nella generazione delle istanze di <code style="color: #e83e8c;">FillEvent</code>. Si prevede anche un oggetto di connessione <code style="color: #e83e8c;">tws_conn</code> per archiviare le informazioni di connessione verso l&#8217;API di Interactive Brokers. Inoltre si crea un <code style="color: #e83e8c;">order_id</code> iniziale, che tiene traccia di tutti gli ordini successivi per evitare duplicati. Infine si registra il gestore dei messaggi (che sarà definito dettagliatamente più avanti):</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-30422b2 elementor-widget elementor-widget-bdt-source-code" data-id="30422b2" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py

class IBExecutionHandler(ExecutionHandler):
    &quot;&quot;&quot;
    Gestisce l&#039;esecuzione degli ordini tramite l&#039;API di Interactive 
    Brokers, da utilizzare direttamente sui conti reali durante il 
    live trading.
    &quot;&quot;&quot;

    def __init__(self, events,
                 order_routing=&quot;SMART&quot;,
                 currency=&quot;USD&quot;):
        &quot;&quot;&quot;
        Inizializza l&#039;instanza di IBExecutionHandler.
        &quot;&quot;&quot;
        self.events = events
        self.order_routing = order_routing
        self.currency = currency
        self.fill_dict = {}

        self.tws_conn = self.create_tws_connection()
        self.order_id = self.create_initial_order_id()
        self.register_handlers()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-989f7de elementor-widget elementor-widget-text-editor" data-id="989f7de" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>L&#8217;API di IB utilizza un sistema di eventi basato sui messaggi che consente alla nostra classe di rispondere in modo specifico a determinati messaggi, in analogia allo stesso ambiente di backtesing event-driven stesso. Non si include nessuna gestione degli errori reali (a fini di brevità), ad eccezione dell&#8217;output al terminale tramite il metodo <code style="color: #e83e8c;">_error_handler</code>.</p><p>Il metodo <code style="color: #e83e8c;">_reply_handler</code>, d&#8217;altra parte, viene utilizzato per determinare se è necessario creare un&#8217;istanza <code style="color: #e83e8c;">FillEvent</code>. Il metodo verifica se è stato ricevuto un messaggio &#8220;openOrder&#8221; e controlla se è presente una voce <code style="color: #e83e8c;">fill_dict</code> relativa a questo particolare orderId. In caso contrario, ne viene creata una.</p><p>Inoltre, se il metodo verifica la presenta di un messaggio &#8220;orderStatus&#8221; e nel caso quel particolare messaggio indichi che un ordine è stato eseguito, allora richiama la funzione <code style="color: #e83e8c;">create_fill</code> per creare un <code style="color: #e83e8c;">FillEvent</code>. Si invia anche un messaggio al terminale per scopi di logging / debug:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-28df205 elementor-widget elementor-widget-bdt-source-code" data-id="28df205" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py 
   
    def _error_handler(self, msg):
        &quot;&quot;&quot;
        Gestore per la cattura dei messagi di errori
        &quot;&quot;&quot;
        # Al momento non c&#039;è gestione degli errori.
        print
        &quot;Server Error: %s&quot; % msg


    def _reply_handler(self, msg):
        &quot;&quot;&quot;
        Gestione delle risposte dal server
        &quot;&quot;&quot;
        # Gestisce il processo degli orderId degli ordini aperti
        if msg.typeName == &quot;openOrder&quot; and \
                msg.orderId == self.order_id and \
                not self.fill_dict.has_key(msg.orderId):
            self.create_fill_dict_entry(msg)
        # Gestione dell&#039;esecuzione degli ordini (Fills)
        if msg.typeName == &quot;orderStatus&quot; and \
                msg.status == &quot;Filled&quot; and \
                self.fill_dict[msg.orderId][&quot;filled&quot;] == False:
            self.create_fill(msg)
        print
        &quot;Server Response: %s, %s\n&quot; % (msg.typeName, msg)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-967c6fa elementor-widget elementor-widget-text-editor" data-id="967c6fa" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il seguente metodo, <code style="color: #e83e8c;">create_tws_connection</code>, crea una connessione all&#8217;API di IB usando l&#8217;oggetto <code style="color: #e83e8c;">ibConnection</code> di IbPy. Utilizza la porta predefinita 7496 e un clientId predefinito a 10. Una volta creato l&#8217;oggetto, viene richiamato il metodo di connessione per eseguire la connessione:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6ab1bd7 elementor-widget elementor-widget-bdt-source-code" data-id="6ab1bd7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def create_tws_connection(self):
        &quot;&quot;&quot;
        Collegamento alla Trader Workstation (TWS) in esecuzione 
        sulla porta standard 7496, con un clientId di 10.
        Il clientId è scelto da noi e avremo bisogno ID separati 
        sia per la connessione di esecuzione che per la connessione
        ai dati di mercato, se quest&#039;ultima è utilizzata altrove.
        &quot;&quot;&quot;
        tws_conn = ibConnection()
        tws_conn.connect()
        return tws_conn</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4008bd3 elementor-widget elementor-widget-text-editor" data-id="4008bd3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per tenere traccia degli ordini separati (ai fini del tracciamento degli eseguiti) viene utilizzato il metodo <code style="color: #e83e8c;">create_initial_order_id</code>. E&#8217; stato impostato su &#8220;1&#8221;, ma un approccio più sofisticato prevede la gestione della query IB per conoscere ed utilizzare l&#8217;ultimo ID disponibile. Si può sempre reimpostare l&#8217;ID dell&#8217;ordine corrente dell&#8217;API tramite il pannello Trader Workstation &#8211;> Configurazione globale &#8211;> Impostazioni API:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6c13860 elementor-widget elementor-widget-bdt-source-code" data-id="6c13860" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
   
    def create_initial_order_id(self):
        &quot;&quot;&quot;
        Crea l&#039;iniziale ID dell&#039;ordine utilizzato da Interactive
        Broker per tenere traccia degli ordini inviati.
        &quot;&quot;&quot;
        # Qui c&#039;è spazio per una maggiore logica, ma 
        # per ora useremo &quot;1&quot; come predefinito.
        return 1</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-cc82cb2 elementor-widget elementor-widget-text-editor" data-id="cc82cb2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il seguente metodo, <code style="color: #e83e8c;">register_handlers</code>, registra semplicemente i metodi per la gestione degli errori e delle risposte, definiti  in precedenza con la connessione TWS:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7f77daf elementor-widget elementor-widget-bdt-source-code" data-id="7f77daf" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def register_handlers(self):
        &quot;&quot;&quot;
        Registra le funzioni di gestione di errori e dei 
        messaggi di risposta dal server.
        &quot;&quot;&quot;
        # Assegna la funzione di gestione degli errori definita
        # sopra alla connessione TWS 
        self.tws_conn.register(self._error_handler, &#039;Error&#039;)

        # Assegna tutti i messaggi di risposta del server alla
        # funzione reply_handler definita sopra
        self.tws_conn.registerAll(self._reply_handler)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b224c8c elementor-widget elementor-widget-text-editor" data-id="b224c8c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Come descritto nel <a href="http://datatrading.info/come-creare-un-account-demo-su-interactive-brokers/">precedente tutorial</a> relativo all&#8217;uso di IbPy, si deve creare un&#8217;istanza di <code style="color: #e83e8c;">Contract</code> ed associarla a un&#8217;istanza di <code style="color: #e83e8c;">Order</code>, che verrà inviata all&#8217;API di IB. Il seguente metodo, <code style="color: #e83e8c;">create_contract</code>, genera la prima componente di questa coppia. Si aspetta in input un simbolo ticker, un tipo di sicurezza (ad esempio, azioni o futures), un exchange primario e una valuta. Restituisce l&#8217;istanza di <code style="color: #e83e8c;">Contract</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8ca7dce elementor-widget elementor-widget-bdt-source-code" data-id="8ca7dce" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def create_contract(self, symbol, sec_type, exch, prim_exch, curr):
        &quot;&quot;&quot;
        Crea un oggetto Contract definendo cosa sarà
        acquistato, in quale exchange e in quale valuta.

        symbol - Il simbolo del ticker per il contratto
        sec_type - Il tipo di asset per il contratto (&quot;STK&quot; è &quot;stock&quot;)
        exch - La borsa su cui eseguire il contratto
        prim_exch - Lo scambio principale su cui eseguire il contratto
        curr - La valuta in cui acquistare il contratto
        &quot;&quot;&quot;
        contract = Contract()
        contract.m_symbol = symbol
        contract.m_secType = sec_type
        contract.m_exchange = exch
        contract.m_primaryExch = prim_exch
        contract.m_currency = curr
        return contract</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8633609 elementor-widget elementor-widget-text-editor" data-id="8633609" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il metodo <code style="color: #e83e8c;">create_order</code> genera la seconda componente della coppia, ovvero l&#8217;istanza di <code style="color: #e83e8c;">Order</code>. Questo metodo prevede in input un tipo di ordine (ad es. market o limit), una quantità del bene da scambiare e una &#8220;posizione&#8221; (acquisto o vendita). Restituisce l&#8217;istanza di <code style="color: #e83e8c;">Order</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ee57d61 elementor-widget elementor-widget-bdt-source-code" data-id="ee57d61" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def create_order(self, order_type, quantity, action):
        &quot;&quot;&quot;
        Crea un oggetto Ordine (Market/Limit) per andare long/short.

        order_type - &quot;MKT&quot;, &quot;LMT&quot; per ordini a mercato o limite
        quantity - Numero intero di asset dell&#039;ordine
        action - &#039;BUY&#039; o &#039;SELL&#039;
        &quot;&quot;&quot;
        order = Order()
        order.m_orderType = order_type
        order.m_totalQuantity = quantity
        order.m_action = action
        return order</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4a3d43d elementor-widget elementor-widget-text-editor" data-id="4a3d43d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per evitare la duplicazione delle istanze di <code style="color: #e83e8c;">FillEvent</code> per un particolare ID ordine, si utilizza un dizionario chiamato <code style="color: #e83e8c;">fill_dict</code> per memorizzare le chiavi che corrispondono a particolari ID ordine. Quando è stato generato un eseguito, la chiave &#8220;fill&#8221; di una voce per un particolare ID ordine è impostata su <code style="color: #e83e8c;">True</code>. Nel caso si riceva un successivo messaggio &#8220;Server Response&#8221; da IB che dichiara che un ordine è stato eseguito (ed è un messaggio duplicato) non si creerà un nuovo eseguito. Il seguente metodo <code style="color: #e83e8c;">create_fill_dict_entry</code> implementa questa logica:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-88f3112 elementor-widget elementor-widget-bdt-source-code" data-id="88f3112" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def create_fill_dict_entry(self, msg):
        &quot;&quot;&quot;
        Crea una voce nel dizionario Fill che elenca gli orderIds
        e fornisce informazioni sull&#039;asset. Ciò è necessario
        per il comportamento guidato dagli eventi del gestore
        dei messaggi del server IB.
        &quot;&quot;&quot;
        self.fill_dict[msg.orderId] = {
            &quot;symbol&quot;: msg.contract.m_symbol,
            &quot;exchange&quot;: msg.contract.m_exchange,
            &quot;direction&quot;: msg.order.m_action,
            &quot;filled&quot;: False
        }</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-f553ab3 elementor-widget elementor-widget-text-editor" data-id="f553ab3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il metodo <code style="color: #e83e8c;">create_fill</code> si occupa di creare effettivamente l&#8217;istanza di <code style="color: #e83e8c;">FillEvent</code> e la inserisce all&#8217;interno della coda degli eventi:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b3fa5a0 elementor-widget elementor-widget-bdt-source-code" data-id="b3fa5a0" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def create_fill(self, msg):
        &quot;&quot;&quot;
        Gestisce la creazione del FillEvent che saranno
        inseriti nella coda degli eventi successivamente
        alla completa esecuzione di un ordine.
        &quot;&quot;&quot;
        fd = self.fill_dict[msg.orderId]

        # Preparazione dei dati di esecuzione
        symbol = fd[&quot;symbol&quot;]
        exchange = fd[&quot;exchange&quot;]
        filled = msg.filled
        direction = fd[&quot;direction&quot;]
        fill_cost = msg.avgFillPrice

        # Crea un oggetto di Fill Event
        fill_event = FillEvent(
            datetime.datetime.utcnow(), symbol,
            exchange, filled, direction, fill_cost
        )

        # Controllo per evitare che messaggi multipli non
        # creino dati addizionali.
        self.fill_dict[msg.orderId][&quot;filled&quot;] = True

        # Inserisce il fill event nella coda di eventi
        self.events.put(fill_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c9b23ee elementor-widget elementor-widget-text-editor" data-id="c9b23ee" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dopo aver implementato tutti i metodi precedenti, resta solamente da sviluppare il metodo <code style="color: #e83e8c;">execute_order</code> della classe base astratta <code style="color: #e83e8c;">ExecutionHandler</code>. Questo metodo esegue effettivamente il posizionamento dell&#8217;ordine tramite l&#8217;API di IB.</p><p>Si verifica innanzitutto che l&#8217;evento ricevuto con questo metodo sia realmente un <code style="color: #e83e8c;">OrderEvent</code> e quindi prepara gli oggetti <code style="color: #e83e8c;">Contract</code> e <code style="color: #e83e8c;">Order</code> con i rispettivi parametri. Una volta che sono stati creati entrambi, il metodo <code style="color: #e83e8c;">placeOrder</code> dell&#8217;oggetto di connessione viene richiamato con associato a <code style="color: #e83e8c;">order_ID</code>.</p><p>È estremamente importante chiamare il metodo <code style="color: #e83e8c;">time.sleep(1)</code> per garantire che l&#8217;ordine sia effettivamente trasmesso ad IB. La rimozione di questa linea può causare comportamenti incoerenti dell&#8217;API, e perfino malfunzionamenti!</p><p>Infine, si incrementa l&#8217;ID ordine al fine di evitare la duplicazione degli ordini:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c3c2a3f elementor-widget elementor-widget-bdt-source-code" data-id="c3c2a3f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># ib_execution.py
    
    def execute_order(self, event):
        &quot;&quot;&quot;
        Crea il necessario oggetto ordine InteractiveBrokers
        e lo invia a IB tramite la loro API.

        I risultati vengono quindi interrogati per generare il 
        corrispondente oggetto Fill, che viene nuovamente posizionato
        nella coda degli eventi.

        Parametri:
        event - Contiene un oggetto Event con informazioni sull&#039;ordine.
        &quot;&quot;&quot;
        if event.type == &#039;ORDER&#039;:
            # Prepara i parametri per l&#039;ordine dell&#039;asset
            asset = event.symbol
            asset_type = &quot;STK&quot;
            order_type = event.order_type
            quantity = event.quantity
            direction = event.direction

            # Crea un contratto per Interactive Brokers tramite
            # l&#039;evento Order in inuput
            ib_contract = self.create_contract(
                asset, asset_type, self.order_routing,
                self.order_routing, self.currency
            )

            # Crea un ordine per Interactive Brokers tramite
            # l&#039;evento Order in inuput
            ib_order = self.create_order(
                order_type, quantity, direction
            )

            # Usa la connessione per inviare l&#039;ordine a IB
            self.tws_conn.placeOrder(
                self.order_id, ib_contract, ib_order
            )

            # NOTE: questa linea è cruciale
            # Questo assicura che l&#039;ordina sia effettivamente trasmesso!
            time.sleep(1)

            # Incrementa l&#039;ordene ID per questa sessione
            self.order_id += 1</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-3a72437 elementor-widget elementor-widget-text-editor" data-id="3a72437" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questa classe costituisce la base per gestione dell&#8217;esecuzione verso Interactive Brokers e può essere utilizzata al posto del gestore dell&#8217;esecuzione simulata, che è adatto solo per il backtesting. Prima che il gestore di IB possa essere utilizzato è necessario creare un gestore del feed dei dati di mercato in tempo reale che deve sostituire il gestore del feed dei dati storici utilizzato nel backtesting.</p><p>Con questo approccio è possibile riutilizzare la maggior parte delle componenti di un sistema di backtesting per un sistema live, in modo da garantire che il codice &#8220;swap out&#8221; sia ridotto al minimo e quindi assicurare un comportamento simile, se non identico, tra i due sistemi.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-78625b0 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="78625b0" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-8c26cae elementor-widget elementor-widget-text-editor" data-id="8c26cae" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ix-connessione-con-ib/">Motore di Backtesting con Python – Parte IX (Connessione con IB)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python &#8211; Parte VIII (Backtest)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-viii-backtest/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Fri, 19 May 2017 17:59:35 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2192</guid>

					<description><![CDATA[<p>Siamo ora in grado di creare la classe gerarchica Backtest. L&#8217;oggetto Backtest incapsula la logica di gestione degli eventi ed essenzialmente lega insieme tutte le altre classi che abbiamo descritto negli articoli precedenti. L&#8217;oggetto Backtest è progettato per eseguire un sistema guidato da eventi annidati in un ciclo while per gestire gli eventi inseriti nell&#8217;oggetto EventQueue. &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-viii-backtest/"> <span class="screen-reader-text">Motore di Backtesting con Python &#8211; Parte VIII (Backtest)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-viii-backtest/">Motore di Backtesting con Python &#8211; Parte VIII (Backtest)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2192" class="elementor elementor-2192">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-29d0b9f elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="29d0b9f" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-b45c60e" data-id="b45c60e" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-6bed066 elementor-widget elementor-widget-text-editor" data-id="6bed066" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Siamo ora in grado di creare la classe gerarchica Backtest. L&#8217;oggetto Backtest incapsula la logica di gestione degli eventi ed essenzialmente lega insieme tutte le altre classi che abbiamo descritto negli articoli precedenti.</p><p>L&#8217;oggetto Backtest è progettato per eseguire un sistema guidato da eventi annidati in un ciclo while per gestire gli eventi inseriti nell&#8217;oggetto EventQueue. Il ciclo while esterno è noto come il &#8220;heartbeat loop&#8221; e decide la risoluzione temporale del sistema di backtesting. In un live ambiente questo valore sarà un numero positivo, ad esempio 600 secondi (ogni dieci minuti). Così i dati di mercato e le posizioni verranno aggiornati solo in questo lasso di tempo.<br />Per il backtester qui descritto il &#8220;heartbeat&#8221; può essere impostato a zero, indipendentemente dalla frequenza della strategia, poiché i dati sono già disponibili in virtù del fatto che sono storici!</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e1bed59 elementor-widget elementor-widget-heading" data-id="e1bed59" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il Motore di Backtest</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-9d9ac33 elementor-widget elementor-widget-text-editor" data-id="9d9ac33" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">Possiamo eseguire il backtest a qualsiasi velocità desideriamo, poiché il sistema guidato dagli eventi è agnostico dalla disponibilità temporale dei dati storici, a condizione che abbiano un timestamp associato. Quindi ho solo incluso per dimostrare come funzionerebbe un motore di trading live. Il ciclo esterno così termina una volta che DataHandler lo comunica all&#8217;oggetto Backtest, utilizzando un attributo booleano continue_backtest.</span><br></p><p>Il ciclo while interno elabora effettivamente i segnali e li invia al componente corretto a seconda del tipo di evento. Pertanto, la coda degli eventi viene continuamente popolata e spopolata da eventi. Questo è ciò che significa avere un sistema guidato dagli eventi.</p>
<p>Il primo compito è importare le librerie necessarie. Importiamo <code style="color: #e83e8c;">pprint</code> (&#8220;pretty-print&#8221;), perché vogliamo visualizzare le statistiche in modo semplice per l&#8217;output:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-dd9bcc7 elementor-widget elementor-widget-bdt-source-code" data-id="dd9bcc7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

import datetime
import pprint
import queue
import time</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4056cf0 elementor-widget elementor-widget-text-editor" data-id="4056cf0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				L&#8217;inizializzazione dell&#8217;oggetto Backtest richiede la directory CSV, l&#8217;elenco completo dei simboli da analizzare, il capitale iniziale, il periodo di &#8220;heartbreat&#8221; in millisecondi, la data e ora di inizio del backtest nonché degli oggetti DataHandler, ExecutionHandler, Portfolio e Strategy. Una coda viene utilizzata per contenere gli eventi.
Vengono conteggiati i segnali, gli ordini e le esecuzioni:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-eed36dd elementor-widget elementor-widget-bdt-source-code" data-id="eed36dd" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

class Backtest(object):
    &quot;&quot;&quot;
    Racchiude le impostazioni e i componenti per l&#039;esecuzione
    un backtest basato sugli eventi.
    &quot;&quot;&quot;
    def __init__(self, csv_dir, symbol_list, initial_capital,
                 heartbeat, start_date, data_handler,
                 execution_handler, portfolio, strategy ):
        &quot;&quot;&quot;
        Inizializza il backtest.

        Parametri:
        csv_dir - Il percorso della directory dei dati CSV.
        symbol_list - L&#039;elenco dei simboli.
        intial_capital - Il capitale iniziale del portafoglio.
        heartbeat - il &quot;battito cardiaco&quot; del backtest in secondi
        data_inizio - La data e ora di inizio della strategia.
        data_handler - (Classe) Gestisce il feed di dati di mercato.
        execution_handler - (Classe) Gestisce gli ordini / esecuzioni per i trade.
        portfolio - (Classe) Tiene traccia del portafoglio attuale e delle posizioni precedenti.
        strategy - (Classe) Genera segnali basati sui dati di mercato.
        &quot;&quot;&quot;
        
        self.csv_dir = csv_dir
        self.symbol_list = symbol_list
        self.initial_capital = initial_capital
        self.heartbeat = heartbeat
        self.start_date = start_date
        self.data_handler_cls = data_handler
        self.execution_handler_cls = execution_handler
        self.portfolio_cls = portfolio
        self.strategy_cls = strategy
        self.events = queue.Queue()
        self.signals = 0
        self.orders = 0
        self.fills = 0
        self.num_strats = 1
        self._generate_trading_instances()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-79b29dd elementor-widget elementor-widget-text-editor" data-id="79b29dd" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il primo metodo, <code style="color: #e83e8c;">_generate_trading_instances</code>, collega tutti gli oggetti di trading (Data- Handler, Strategy, Portfolio and ExecutionHandler) a vari componenti interni:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ef0956f elementor-widget elementor-widget-bdt-source-code" data-id="ef0956f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

    def _generate_trading_instances(self):
        &quot;&quot;&quot;
        Genera le istanze degli componenti del backtest a partire dalle loro classi.
        &quot;&quot;&quot;

        print(&quot;Creating DataHandler, Strategy, Portfolio and ExecutionHandler&quot;)
        self.data_handler = self.data_handler_cls(self.events, 
                                                  self.csv_dir,
                                                  self.symbol_list)
        self.strategy = self.strategy_cls(self.data_handler, 
                                          self.events)
        self.portfolio = self.portfolio_cls(self.data_handler, 
                                            self.events,
                                            self.start_date,
                                            self.initial_capital)
        self.execution_handler = self.execution_handler_cls(self.events)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-fbcd0f8 elementor-widget elementor-widget-text-editor" data-id="fbcd0f8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo <code style="color: #e83e8c;">_run_backtest</code> è dove viene effettuata la gestione di segnali all&#8217;interno del motore di backtest.</p><p>Come descritto negli <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">articoli precedenti</a>, ci sono due cicli while, uno annidato all&#8217;interno dell&#8217;altro.<br />Il ciclo esterno tiene traccia del &#8220;battito&#8221; del sistema, mentre il ciclo interno controlla se c&#8217;è un evento in coda e agisce su di esso chiamando il metodo appropriato sull&#8217;oggetto necessario.</p><p>Per un <em>MarketEvent</em>, si chiede all&#8217;oggetto Strategy di ricalcolare nuovi segnali, mentre all&#8217; oggetto Portfolio<br />si chiede di reindicizzare l&#8217;ora.<br />Se si riceve un <em>SignalEvent</em>, si comunica al Portfolio di gestire il nuovo segnale e convertirlo in un insieme di <em>OrderEvents</em>, se necessario.<br />Nel caso di ricezione di un  <em>OrderEvent, </em>si invia l&#8217;ordine all&#8217;ExecutionHandler in modo che venga trasmesso al broker (se è attivo il live trading).<br />Infine, se viene ricevuto un &#8220;FillEvent&#8221;, si aggiorna il Portfolio in modo da essere a allineato con le nuove posizioni:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-93caf68 elementor-widget elementor-widget-bdt-source-code" data-id="93caf68" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

    def _run_backtest(self):
        &quot;&quot;&quot;
        Esecuzione del backtest.
        &quot;&quot;&quot;
        i = 0
        while True:
            i += 1
            print(i)
            # Aggiornamento dei dati di mercato
            if self.data_handler.continue_backtest == True:
                self.data_handler.update_bars()
            else:
               break
            # Gestione degli eventi
            while True:
                try:
                    event = self.events.get(False)
                except queue.Empty:
                    break
                else:
                    if event is not None:
                        if event.type == &#039;MARKET&#039;:
                            self.strategy.calculate_signals(event)
                            self.portfolio.update_timeindex(event)
                        elif event.type == &#039;SIGNAL&#039;:
                            self.signals += 1
                            self.portfolio.update_signal(event)
                        elif event.type == &#039;ORDER&#039;:
                            self.orders += 1
                            self.execution_handler.execute_order(event)
                        elif event.type == &#039;FILL&#039;:
                            self.fills += 1
                            self.portfolio.update_fill(event)
            time.sleep(self.heartbeat)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8d5ce07 elementor-widget elementor-widget-text-editor" data-id="8d5ce07" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Una volta completata la simulazione del backtest, è possibile visualizzare le prestazioni della strategia
nel terminale / console python.<br> Viene creata la curva di equity dal Dataframe pandas e vengono visualizzate le statistiche di riepilogo, così come il conteggio di Segnali, Ordini ed Eseguiti:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-84c107b elementor-widget elementor-widget-bdt-source-code" data-id="84c107b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

    def _output_performance(self):
        &quot;&quot;&quot;
        Stampa delle performance della strategia dai risultati del backtest.
        &quot;&quot;&quot;
        self.portfolio.create_equity_curve_dataframe()
        print(&quot;Creating summary stats...&quot;)
        stats = self.portfolio.output_summary_stats()
        print(&quot;Creating equity curve...&quot;)
        print(self.portfolio.equity_curve.tail(10))
        pprint.pprint(stats)
        print(&quot;Signals: %s&quot; % self.signals)
        print(&quot;Orders: %s&quot; % self.orders)
        print(&quot;Fills: %s&quot; % self.fills)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-d12a8f6 elementor-widget elementor-widget-text-editor" data-id="d12a8f6" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				L&#8217;ultimo metodo da implementare è il <code style="color: #e83e8c;">simulate_trading</code>. Esso richiama semplicemente in ordine i 2 metodi descritti precedentemente:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4af1d26 elementor-widget elementor-widget-bdt-source-code" data-id="4af1d26" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py

    def simulate_trading(self):
        &quot;&quot;&quot;
        Simula il backtest e stampa le performance del portafoglio.
        &quot;&quot;&quot;
        self._run_backtest()
        self._output_performance()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-665bc8e elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="665bc8e" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-3cf0dd2 elementor-widget elementor-widget-text-editor" data-id="3cf0dd2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-viii-backtest/">Motore di Backtesting con Python &#8211; Parte VIII (Backtest)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte VII (Performance)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-vii-performance/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sun, 14 May 2017 13:52:23 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=886</guid>

					<description><![CDATA[<p>Nel precedente articolo della serie &#8220;Ambiente di Backtesting Event-Driven&#8221; è stato descritta la gerarchia della classe ExecutionHandler. In questo articolo si introduce l&#8217;implementazione delle metriche per misurare le prestazioni di una strategia usando la curva equity DataFrame precedentemente costruita nell&#8217;oggetto Portfolio. Misurare le Performance Abbiamo già descritto il Sharpe Ratio in un precedente articolo. In &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vii-performance/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte VII (Performance)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vii-performance/">Motore di Backtesting con Python – Parte VII (Performance)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="886" class="elementor elementor-886">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-b721eee elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="b721eee" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1259c2a" data-id="1259c2a" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-c6f202c elementor-widget elementor-widget-text-editor" data-id="c6f202c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nel <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/">precedente articolo</a> della serie &#8220;Ambiente di Backtesting Event-Driven&#8221; è stato descritta la gerarchia della classe ExecutionHandler. In questo articolo si introduce l&#8217;implementazione delle metriche per misurare le prestazioni di una strategia usando la curva equity DataFrame precedentemente costruita nell&#8217;oggetto Portfolio.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d004d80 elementor-widget elementor-widget-heading" data-id="d004d80" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Misurare le Performance</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-4c60ed4 elementor-widget elementor-widget-text-editor" data-id="4c60ed4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Abbiamo già descritto il Sharpe Ratio in un <a href="http://datatrading.info/sharpe-ratio-per-la-misura-delle-prestazioni-del-trading-algoritmico/">precedente articolo</a>. In quell&#8217;articolo il Sharpe Ratio (annualizzato) viene calcolato tramite:
<p style="text-align: center;">\(\begin{eqnarray*}
S_A = \sqrt{N} \frac{\mathbb{E}(R_a &#8211; R_b)}{\sqrt{\text{Var} (R_a &#8211; R_b)}}
\end{eqnarray*}\)</p>
Dove \(R_a\) è il flusso dei rendimenti della curva equity e \(R_b\) è un indice di riferimento, come uno specifico tasso di interesse o un indice azionario.

Il <em>massimo drawdown</em> e la <em>durata del drawdown</em> sono due ulteriori misure che gli investitori utilizzano per valutare il rischio in un portafoglio. Il primo rappresenta è più grande discesa, la correzione, da un precedente massimo relativo o massimo assoluto, della curva equity, mentre il secondo è definito come il numero di periodi di trading in cui si verifica.

In questo articolo si implementa il Sharpe Ratio, il drawdown massimo e la durata del drawdown come misure delle prestazioni del portafoglio da utilizzare nella suite di Backtesting Event-Driven sviluppato in Python.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-51a0938 elementor-widget elementor-widget-heading" data-id="51a0938" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Implementazione</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-73e092a elementor-widget elementor-widget-text-editor" data-id="73e092a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il primo passo è creare un nuovo file <code style="color: #e83e8c;">performance.py</code>, che memorizzi le funzioni per calcolare il Sharpe Ratio e le informazioni sul drawdown. Come per la maggior parte delle classi che prevedono elevati carichi computanzionali, abbiamo bisogno di importare NumPy e Pandas:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-46eb04b elementor-widget elementor-widget-bdt-source-code" data-id="46eb04b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># performance.py

import numpy as np
import pandas as pd</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-941e8c3 elementor-widget elementor-widget-text-editor" data-id="941e8c3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il Sharpe Ratio è una misura del rischio/rendimento (in realtà è una delle tante!) e prevede un singolo parametro, cioè il numero di periodi da considerare per il ridimensionamento al valore annualizzato.</p><p>Di solito questo valore è impostato su 252, ovvero il numero di giorni di negoziazione (mercati aperti) negli Stati Uniti in un anno. Tuttavia, ad esempio, se la strategia apre e chiude posizioni all&#8217;interno di un&#8217;ora, si deve regolare lo Sharpe per annualizzarlo correttamente. Pertanto, è necessario impostare il <code style="color: #e83e8c;">periods</code> come 252 * 6.5 = 1638, ovvero il numero di ore di trading statunitensi in un anno. Se si effettua trading sul minuto, questo fattore deve essere impostato come 252 * 6.5 * 60 = 98280.</p><p>La funzione <code style="color: #e83e8c;">create_sharpe_ratio</code> opera su un oggetto Serie di Pandas che abbiamo chiamato <code style="color: #e83e8c;">returns</code> e calcola semplicemente il rapporto tra la media dei rendimenti percentuali del periodo e le deviazioni standard dei rendimenti percentuali ridimensionato in base al fattore <code style="color: #e83e8c;">periods</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-01feaec elementor-widget elementor-widget-bdt-source-code" data-id="01feaec" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># performance.py

def create_sharpe_ratio(returns, periods=252):
    &quot;&quot;&quot;
    Crea il Sharpe ratio per la strategia, basato su a benchmark 
    pari a zero (ovvero nessuna informazione sui tassi privi di rischio).

    Parametri:
    returns - Una serie panda che rappresenta i rendimenti percentuali nel periodo.
    periods - Giornaliero (252), orario (252 * 6,5), minuto (252 * 6,5 * 60) ecc.
    &quot;&quot;&quot;
    return np.sqrt(periods) * (np.mean(returns)) / np.std(returns)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-14b8a6b elementor-widget elementor-widget-text-editor" data-id="14b8a6b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Mentre il Sharpe Ratio indica il livello di rischio (definito dalla deviazione standard del patrimonio) per unità di rendimento, il &#8220;drawdown&#8221; è definito come la distanza tra un massimo relativo e un minimo relativo lungo una curva equity.</p><p>La funzione <code style="color: #e83e8c;">create_drawdowns</code> calcola sia il <em>drawdown massimo</em> che la <em>durata massima di drawdown</em>. Il primo è la discesa più elevata tra un massimo e minimo relativi, mentre il secondo è definito come il numero di periodi in cui questa discesa si verifica.</p><p>E&#8217; necessario prestare molta attenzione nell&#8217;interpretazione della durata del drawdown in quanto questo fattore identifica i <em>periodi di trading</em> e quindi non è direttamente traducibile in un&#8217;unità temporale come &#8220;giorni&#8221;.</p><p>La funzione inizia creando due oggetti Serie di Pandas che rappresentano il drawdown e la durata di ogni &#8220;barra&#8221; di trading. Quindi viene stabilito l&#8217;attuale <em>high water mark</em> (HWM) determinando se la curva di equty supera tutti i picchi precedenti.</p><p>Il drawdown è quindi semplicemente la differenza tra l&#8217;attuale HWM e la curva di equity. Se questo valore è negativo, la durata viene aumentata per ogni barra che si verifica fino al raggiungimento del prossimo HWM. La funzione restituisce quindi semplicemente il massimo di ciascuna delle due serie:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-dca562e elementor-widget elementor-widget-bdt-source-code" data-id="dca562e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># performance.py

def create_drawdowns(pnl):
    &quot;&quot;&quot;
    Calcola il massimo drawdown tra il picco e il minimo della curva PnL
    così come la durata del drawdown. Richiede che il pnl_returns
    sia una serie di pandas.

    Parametri:
    pnl - Una serie pandas che rappresenta i rendimenti percentuali del periodo.

    Restituisce:
    Drawdown, duration - Massimo drawdown picco-minimo e relativa durata.
    &quot;&quot;&quot;

    # Calcola la curva cumulativa dei rendimenti
    # e imposta un &quot;High Water Mark&quot;
    # Quindi crea le serie dei drawdown e relative durate
    hwm = [0]
    idx = pnl.index
    drawdown = pd.Series(index = idx)
    duration = pd.Series(index = idx)

    # Ciclo sul range dell&#039;indice
    for t in range(1, len(idx)):
        cur_hwm = max(hwm[t-1], pnl[t])
        hwm.append(cur_hwm)
        dd = (hwm[t] - pnl[t])
        drawdown[t]= dd
        duration[t]= (0 if drawdown[t] == 0 else duration[t-1] + 1)
    return drawdown, drawdown.max(), duration.max()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c56261d elementor-widget elementor-widget-text-editor" data-id="c56261d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Al fine di utilizzare queste misure di performance, si ha bisogno di un metodo per calcolarle dopo che è stato effettuato un backtest, cioè quando è disponibile un&#8217;adeguata curva di equity!

E&#8217; necessario inoltre associare tale metodo a una particolare gerarchia di oggetti. Dato che le misure di rendimento sono calcolate a partire dal <em>portafoglio</em>, ha senso inserire i calcoli delle prestazioni all&#8217;interno di un metodo nella gerarchia della classe <code style="color: #e83e8c;">Portfolio</code>, che è stata descritta in <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/">questo articolo</a>.

Il primo compito è aprire <code style="color: #e83e8c;">portfolio.py</code> e importare le funzioni di performance:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0bd1f3e elementor-widget elementor-widget-bdt-source-code" data-id="0bd1f3e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

..  # Other imports

from performance import create_sharpe_ratio, create_drawdowns</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-95e5915 elementor-widget elementor-widget-text-editor" data-id="95e5915" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Poiché <code style="color: #e83e8c;">Portfolio</code> è una classe base astratta, si deve associare un metodo a una delle sue classi derivate, che in questo caso corrisponde a <code style="color: #e83e8c;">NaivePortfolio</code>. Quindi si crea un metodo chiamato <code style="color: #e83e8c;">output_summary_stats</code> che elabora la curva equity del portafoglio per generare le informazioni relative allo Sharpe e drawdown.

Il metodo è semplice. Utilizza semplicemente le due misure di performance e le applica direttamente al DataFrame Pandas relativo alla curva equity, restituendo le statistiche come una lista di tuple in un formato &#8220;user-friendly&#8221;:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ca2abf4 elementor-widget elementor-widget-bdt-source-code" data-id="ca2abf4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

..
..

class NaivePortfolio(object):

    ..
    ..

    def output_summary_stats(self):
        &quot;&quot;&quot;
        Crea un elenco di statistiche di riepilogo per il portafoglio 
        come lo Sharpe Ratio e le informazioni sul drowdown.
        &quot;&quot;&quot;
        total_return = self.equity_curve[&#039;equity_curve&#039;][-1]
        returns = self.equity_curve[&#039;returns&#039;]
        pnl = self.equity_curve[&#039;equity_curve&#039;]

        sharpe_ratio = create_sharpe_ratio(returns)
        drawdown, max_dd, dd_duration = create_drawdowns(pnl)
        self.equity_curve[&#039;drawdown&#039;] = drawdown
        stats = [(&quot;Total Return&quot;, &quot;%0.2f%%&quot; % \
                  ((total_return - 1.0) * 100.0)),
                 (&quot;Sharpe Ratio&quot;, &quot;%0.2f&quot; % sharpe_ratio),
                 (&quot;Max Drawdown&quot;, &quot;%0.2f%%&quot; % (max_dd * 100.0)),
                 (&quot;Drawdown Duration&quot;, &quot;%d&quot; % dd_duration)]
        self.equity_curve.to_csv(&#039;equity.csv&#039;)
        return stats</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-dd4055e elementor-widget elementor-widget-text-editor" data-id="dd4055e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Chiaramente questa è un&#8217;analisi molto semplice delle prestazioni per un portfolio. Non prende in considerazione l&#8217;analisi a livello di singolo trade o altre misure del rapporto rischio / rendimento. Tuttavia è molto semplice da estendere, aggiungendo più metodi in <code style="color: #e83e8c;">performance.py</code> e quindi incorporandoli in <code style="color: #e83e8c;">output_summary_stats</code> come richiesto.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4c535a5 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="4c535a5" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-c49e5d2 elementor-widget elementor-widget-text-editor" data-id="c49e5d2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vii-performance/">Motore di Backtesting con Python – Parte VII (Performance)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte VI (Esecuzione degli Ordini)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 10 May 2017 10:44:02 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=881</guid>

					<description><![CDATA[<p>In questo articolo continua lo sviluppo di un ambiente di backtesting basato sugli eventi, utilizzando Python. Nel precedente articolo è stata approfondita la gerarchia della classe Portfolio che permette di gestire le posizioni correnti, generare ordini di trading e tenere traccia dei profitti e delle perdite (PnL). Il porossimo passo è implementare l&#8217;esecuzione di questi &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte VI (Esecuzione degli Ordini)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/">Motore di Backtesting con Python – Parte VI (Esecuzione degli Ordini)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="881" class="elementor elementor-881">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-5266386 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="5266386" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-38e5916" data-id="38e5916" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-174d74f elementor-widget elementor-widget-text-editor" data-id="174d74f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo continua lo sviluppo di un ambiente di backtesting basato sugli eventi, utilizzando Python. Nel <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/">precedente articolo</a> è stata approfondita la gerarchia della classe Portfolio che permette di gestire le posizioni correnti, generare ordini di trading e tenere traccia dei profitti e delle perdite (PnL).</p><p>Il porossimo passo è implementare l&#8217;esecuzione di questi ordini, creando una gerarchia di classi che rappresenta un meccanismo per la simulazione della gestione degli ordini e, infine, collegarsi ad un broker o ad altri intermediari di mercato.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-84b4b58 elementor-widget elementor-widget-heading" data-id="84b4b58" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Esecuzione degli Ordini</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-96f9938 elementor-widget elementor-widget-text-editor" data-id="96f9938" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">L&#8217;</span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: rgb(232, 62, 140);">ExecutionHandler</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);"> descritto in questo articolo è estremamente semplice, poiché esegue tutti gli ordini al prezzo corrente di mercato. Questo è altamente irrealistico, ma serve come una buona base di partenza da perfezionare successivamente.</span><br></p>
<p>Come per le precedenti gerarchie di classi astratte di base, bisogna importare le proprietà e i decoratori necessari dalla libreria <code style="color: #e83e8c;">abc</code>. Inoltre, è necessario importare <code style="color: #e83e8c;">FillEvent</code> e <code style="color: #e83e8c;">OrderEvent</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d900c36 elementor-widget elementor-widget-bdt-source-code" data-id="d900c36" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># execution.py

import datetime
import queue

from abc import ABCMeta, abstractmethod

from event.event import FillEvent, OrderEvent</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-483c949 elementor-widget elementor-widget-text-editor" data-id="483c949" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>La classe <code style="color: #e83e8c;">ExecutionHandler</code> è simile alle precedenti classi astratte di base e ha solamente un metodo virtuale, <code style="color: #e83e8c;">execute_order</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0dd2b7d elementor-widget elementor-widget-bdt-source-code" data-id="0dd2b7d" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># execution.py

class ExecutionHandler(object):
    &quot;&quot;&quot;
    La classe astratta ExecutionHandler gestisce l&#039;interazione
    tra un insieme di oggetti &quot;ordini&quot; generati da un portafoglio e
    l&#039;ultimo set di oggetti Fill che effettivamente si verificano
    nel mercato.

    Gli handles possono essere utilizzati per creare sottoclassi
    con interfacce identiche per broker simulati o broker live.
    Questo permette di sottoporre strategie a backtesting in modo
    molto simile al motore di live trading.
    &quot;&quot;&quot;

    __metaclass__ = ABCMeta

    @abstractmethod
    def execute_order(self, event):
        &quot;&quot;&quot;
        Accetta un evento Order e lo esegue, producendo
        un evento Fill che viene inserito nella coda degli eventi.

        Parametri:
        event - Contiene un oggetto Event con informazioni sull&#039;ordine.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement execute_order()&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-abdb621 elementor-widget elementor-widget-text-editor" data-id="abdb621" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per testare le strategie, è necessario simulare il modo in cui un trade verrà eseguito. L&#8217;implementazione più semplice possibile consiste nell&#8217;ipotizzare che tutti gli ordini siano stati eseguiti al prezzo corrente di mercato per qualsiasi quantità. Questo è chiaramente estremamente irrealistico e gran parte del lavoro per aumentare il grado di realismo del backtesting consiste nel progettare dei modelli avanzati per simulare lo slippage e il market-impact.</p><p>Da notare che all&#8217;interno del metodo <code style="color: #e83e8c;">FillEvent</code> viene passato un valore pari a <code style="color: #e83e8c;">None</code> per l&#8217;attributo <code style="color: #e83e8c;">fill_cost</code> (vedere la penultima riga in execute_order) come abbiamo descritto per il costo di esecuzione nell&#8217;oggetto <code style="color: #e83e8c;">NaivePortfolio</code> descritto nell&#8217;<a href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/">articolo precedente</a>. In un&#8217;implementazione più realistica, si utilizza il valore di dati di mercato &#8220;attuali&#8221; per ottenere un costo di esecuzione più realistico.</p><p>Ho inoltre utilizzato ARCA come exchange, anche se per i scopi di backtesting questo è puramente un segnaposto. In un ambiente di esecuzione dal vivo questo attributo diventa molto più importante:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7e49649 elementor-widget elementor-widget-bdt-source-code" data-id="7e49649" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># execution.py

class SimulatedExecutionHandler(ExecutionHandler):
    &quot;&quot;&quot;
    Il gestore di esecuzione simulato converte semplicemente tutti gli
    oggetti Ordine automaticamente negli equivalenti oggetti Fill
    senza considerare i problemi di latenza, slittamento e rapporto di
    esecuzione (fill-ratio).

    Ciò consente un semplice test &quot;first go&quot; di qualsiasi strategia,
    prima dell&#039;implementazione con un gestiore di esecuzione più sofisticato.
    &quot;&quot;&quot;

    def __init__(self, events):
        &quot;&quot;&quot;
        Inizializza il gestore, impostando internamente le code degli eventi.

        Parametri
        events - L&#039;oggetto di coda degli eventi.
        &quot;&quot;&quot;
        self.events = events

    def execute_order(self, event):
        &quot;&quot;&quot;
        Converte semplicemente gli oggetti Order in oggetti Fill base,
        cioè senza considerare latenza, slittamento o rapporto di esecuzione.

        Parametri:
        event - Contiene un oggetto Event con informazioni sull&#039;ordine.
        &quot;&quot;&quot;
        if event.type == &#039;ORDER&#039;:
            fill_event = FillEvent(datetime.datetime.utcnow(), event.symbol,
                                   &#039;ARCA&#039;, event.quantity, event.direction, None)
            self.events.put(fill_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2049a1d elementor-widget elementor-widget-text-editor" data-id="2049a1d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questo conclude le gerarchie di classi necessarie per implementare un ambiente di backtesting basato sugli eventi.</p><p>Nel prossimo articolo si descriverà come calcolare un insieme di metriche sul rendimento per la strategia oggetto del backtesting.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-aa2273b elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="aa2273b" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-dee2ceb elementor-widget elementor-widget-text-editor" data-id="dee2ceb" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-vi-esecuzione-degli-ordini/">Motore di Backtesting con Python – Parte VI (Esecuzione degli Ordini)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte V (Portafoglio)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Fri, 05 May 2017 08:58:30 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=871</guid>

					<description><![CDATA[<p>Nel precedente articolo relativo al backtesting basato sugli eventi abbiamo descritto come costruire la gerarchia della classe Strategy. Le strategie, per come sono state definite, sono utilizzate per generare signals, che sono l&#8217;input di un oggetto portfolio al fine di decidere se inviare o meno gli orders. Inizialmente, è naturale creare una classe astratta di &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte V (Portafoglio)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/">Motore di Backtesting con Python – Parte V (Portafoglio)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="871" class="elementor elementor-871">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-5e8c0a5 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="5e8c0a5" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-2cddfcb" data-id="2cddfcb" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-acf011b elementor-widget elementor-widget-text-editor" data-id="acf011b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nel <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/">precedente articolo</a> relativo al backtesting basato sugli eventi abbiamo descritto come costruire la gerarchia della classe <code style="color: #e83e8c;">Strategy</code>.</p><p>Le strategie, per come sono state definite, sono utilizzate per generare <em>signals</em>, che sono l&#8217;input di un oggetto portfolio al fine di decidere se inviare o meno gli <em>orders</em>. Inizialmente, è naturale creare una classe astratta di base (ABC) del <code style="color: #e83e8c;">Portfolio</code> da cui si ereditano tutte le sottoclassi successive.</p><p>Questo articolo descrive un oggetto <code style="color: #e83e8c;">NaivePortfolio</code> che tiene traccia delle posizioni all&#8217;interno di un portafoglio e genera ordini di una quantità fissa di azioni in base ai segnali. Oggetti di portfolio avanzati includono strumenti di gestione del rischio più sofisticati e saranno oggetto di articoli successivi.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ceef12e elementor-widget elementor-widget-heading" data-id="ceef12e" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Monitoraggio della Posizione e Gestione degli Ordini</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-5d8452f elementor-widget elementor-widget-text-editor" data-id="5d8452f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il sistema di gestione degli ordini del portafoglio è probabilmente la componente più complessa di un ambiente backtesting basato sugli eventi. Questa componente ha il compito di tenere traccia di tutte le attuali posizioni aperte sul mercato e del valore di mercato di queste posizioni (note come &#8220;holdings&#8221;). Questa è semplicemente una stima del valore di liquidazione della posizione ed è derivata in parte dalla funzione di gestione dei dati del backtester.</p><p>Oltre alle posizioni e alla gestione degli holdings, il portafoglio deve essere a conoscenza dei fattori di rischio e delle tecniche di dimensionamento delle posizioni al fine di ottimizzare gli ordini inviati ad un broker o verso altre forme di accesso al mercato.</p><p>In analogia alla gerarchia della classe <code style="color: #e83e8c;">Event</code>, un oggetto <code style="color: #e83e8c;">Portfolio</code> deve essere in grado di gestire oggetti <code style="color: #e83e8c;">SignalEvent</code>, generare oggetti <code style="color: #e83e8c;">OrderEvent</code> e interpretare oggetti <code style="color: #e83e8c;">FillEvent</code> per aggiornare le posizioni. Pertanto non sorprende che gli oggetti portfolio siano spesso il componente più importante dei sistemi event-driven, in termini di righe di codice (LOC).</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-99bf41c elementor-widget elementor-widget-heading" data-id="99bf41c" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>Implementazione</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-73a192f elementor-widget elementor-widget-text-editor" data-id="73a192f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Si crea un nuovo file <code style="color: #e83e8c;">portfolio.py</code> e si importa le librerie necessarie. Queste sono le stesse della maggior parte delle altre implementazioni delle classe astratte di base. In particolare si importa la funzione <code style="color: #e83e8c;">floor</code> dalla libreria <code style="color: #e83e8c;">math</code> per generare dimensioni di ordine con valori interi, ed inoltre si importano gli oggetti <code style="color: #e83e8c;">FillEvent</code> e <code style="color: #e83e8c;">OrderEvent</code> poiché il Portfolio gestisce entrambi.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3e2969f elementor-widget elementor-widget-bdt-source-code" data-id="3e2969f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

import datetime
import numpy as np
import pandas as pd
import queue

from abc import ABCMeta, abstractmethod
from math import floor

from event import FillEvent, OrderEvent</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7b11a3c elementor-widget elementor-widget-text-editor" data-id="7b11a3c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>A questo punto si crea una classe ABC per il <code style="color: #e83e8c;">Portfolio</code> e si implementano due metodi virtuali <code style="color: #e83e8c;">update_signal</code> e <code style="color: #e83e8c;">update_fill</code>. Il primo elabora i nuovi segnali di trading che vengono prelevati dalla coda degli eventi, mentre il secondo gestisce gli ordini eseguiti e ricevuti dall&#8217;oggetto di gestione dell&#8217;esecuzione.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6db120f elementor-widget elementor-widget-bdt-source-code" data-id="6db120f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

class Portfolio(object):
    &quot;&quot;&quot;
    La classe Portfolio gestisce le posizioni e il valore di
    mercato di tutti gli strumenti alla risoluzione di una &quot;barra&quot;,
    cioè ogni secondo, ogni minuto, 5 minuti, 30 minuti, 60 minuti o EOD.
    &quot;&quot;&quot;

    __metaclass__ = ABCMeta

    @abstractmethod
    def update_signal(self, event):
        &quot;&quot;&quot;
        Azioni su un SignalEvent per generare nuovi ordini
        basati sulla logica di portafoglio
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement update_signal()&quot;)

    @abstractmethod
    def update_fill(self, event):
        &quot;&quot;&quot;
        Aggiorna le posizioni e il patrimonio del portafoglio 
        da un FillEvent.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement update_fill()&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-ecd4fe8 elementor-widget elementor-widget-text-editor" data-id="ecd4fe8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>L&#8217;argomento principale di questo articolo è la classe <code style="color: #e83e8c;">NaivePortfolio</code>. Questa classe è progettata per gestire il dimensionamento delle posizioni e gli holdings correnti, ma esegue gli ordini di compravendita in modo &#8220;stupido&#8221;, semplicemente inviandoli direttamente al broker con una dimensione fissa e predeterminata, indipendentemente dalla liquidità detenuta. Queste sono tutte ipotesi irrealistiche, ma aiutano a delineare come funziona un sistema di gestione degli ordini di portafoglio (OMS) basato sugli eventi.</p><p>La <code style="color: #e83e8c;">NaivePortfolio</code> richiede un valore del capitale iniziale, che ho impostato sul valore predefinito di 100.000 USD. Richiede anche una data di inizio.</p><p>Il portfolio contiene gli attributi <code style="color: #e83e8c;">all_positions</code> e <code style="color: #e83e8c;">current_positions</code>. Il primo memorizza un elenco di tutte le precedenti <em>posizioni</em> registrate ad uno specifico timestamp di un evento di dati di mercato. Una posizione è semplicemente la quantità dell&#8217;asset. Le posizioni negative indicano che l&#8217;asset è stato ridotto. Il secondo attributo memorizza un dizionario contenente le posizioni correnti per l&#8217;ultimo aggiornamento dei dati di mercato.</p><p>Oltre agli attributi delle posizioni, il portafoglio memorizza gli <em>holdings</em>, che descrivono il valore corrente di mercato delle posizioni detenute. Il &#8220;Valore corrente di mercato&#8221; indica, in questo caso, il prezzo di chiusura ottenuto dalla barra OLHCV corrente, che è chiaramente un&#8217;approssimazione, ma è abbastanza accettabile in questo momento. L&#8217;attributo <code style="color: #e83e8c;">all_holdings</code> memorizza la lista storica di tutte gli holding dei simboli, mentre <code style="color: #e83e8c;">current_holdings</code> memorizza il dizionario aggiornato di tutti i valori di holdings dei simboli.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b8a55f0 elementor-widget elementor-widget-bdt-source-code" data-id="b8a55f0" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

class NaivePortfolio(Portfolio):
    &quot;&quot;&quot;
    L&#039;oggetto NaivePortfolio è progettato per inviare ordini a
    un oggetto di intermediazione con una dimensione di quantità costante,
    cioè senza alcuna gestione del rischio o dimensionamento della posizione. È
    utilizzato per testare strategie più semplici come BuyAndHoldStrategy.
    &quot;&quot;&quot;

    def __init__(self, bars, events, start_date, initial_capital=100000.0):
        &quot;&quot;&quot;
        Inizializza il portfolio con la coda delle barre e degli eventi.
        Include anche un indice datetime iniziale e un capitale iniziale
        (USD se non diversamente specificato).

        Parametri:
        bars - L&#039;oggetto DataHandler con i dati di mercato correnti.
        events: l&#039;oggetto Event Queue (coda di eventi).
        start_date - La data di inizio (barra) del portfolio.
        initial_capital - Il capitale iniziale in USD.
        &quot;&quot;&quot;
        self.bars = bars
        self.events = events
        self.symbol_list = self.bars.symbol_list
        self.start_date = start_date
        self.initial_capital = initial_capital

        self.all_positions = self.construct_all_positions()
        self.current_positions = dict((k, v) for k, v in [(s, 0) for s in self.symbol_list])

        self.all_holdings = self.construct_all_holdings()
        self.current_holdings = self.construct_current_holdings()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-964f475 elementor-widget elementor-widget-text-editor" data-id="964f475" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il seguente metodo, <code style="color: #e83e8c;">construct_all_positions</code>, crea semplicemente un dizionario per ogni simbolo, e per ciascuno imposta il valore a zero e quindi aggiunge una chiave datetime, inserendo infine questo oggetto in un elenco. Usa una <a href="http://stackoverflow.com/questions/1747817/python-create-a-dictionary-with-list-comprehension">comprensione</a> del dizionario, che è simile alla comprensione di una lista:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-74d897f elementor-widget elementor-widget-bdt-source-code" data-id="74d897f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def construct_all_positions(self):
        &quot;&quot;&quot;
        Costruisce l&#039;elenco delle posizioni utilizzando start_date
        per determinare quando inizierà l&#039;indice temporale.
        &quot;&quot;&quot;
        d = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] )
        d[&#039;datetime&#039;] = self.start_date
        return [d]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-ffc54c4 elementor-widget elementor-widget-text-editor" data-id="ffc54c4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il metodo <code style="color: #e83e8c;">construct_all_holdings</code> è simile al precedente, ma aggiunge delle chiavi extra per memorizzare i contanti, le commissioni e il totale, che rappresentano rispettivamente la riserva di denaro nel conto dopo eventuali acquisti, la commissione cumulativa maturata e il totale del conto azionario inclusi i contanti e le posizioni aperte. Le posizioni short sono considerate negative. I contanti (cash) e il totale (total) sono entrambi inizializzati con il capitale iniziale:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d72037a elementor-widget elementor-widget-bdt-source-code" data-id="d72037a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def construct_all_holdings(self):
        &quot;&quot;&quot;
        Costruisce l&#039;elenco delle partecipazioni utilizzando start_date
        per determinare quando inizierà l&#039;indice temporale.
        &quot;&quot;&quot;
        d = dict( (k,v) for k, v in [(s, 0.0) for s in self.symbol_list] )
        d[&#039;datetime&#039;] = self.start_date
        d[&#039;cash&#039;] = self.initial_capital
        d[&#039;commission&#039;] = 0.0
        d[&#039;total&#039;] = self.initial_capital
        return [d]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-45d53b5 elementor-widget elementor-widget-text-editor" data-id="45d53b5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il metodo seguente, <code style="color: #e83e8c;">construct_current_holdings</code> è quasi identico al metodo precedente, tranne per il fatto che non racchiude il dizionario in un elenco:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9bed0be elementor-widget elementor-widget-bdt-source-code" data-id="9bed0be" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def construct_current_holdings(self):
        &quot;&quot;&quot;
        Questo costruisce il dizionario che conterrà l&#039;istantaneo
        valore del portafoglio attraverso tutti i simboli.
        &quot;&quot;&quot;
        d = dict( (k,v) for k, v in [(s, 0.0) for s in self.symbol_list] )
        d[&#039;cash&#039;] = self.initial_capital
        d[&#039;commission&#039;] = 0.0
        d[&#039;total&#039;] = self.initial_capital
        return d</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-35c31e7 elementor-widget elementor-widget-text-editor" data-id="35c31e7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ad ogni &#8220;battito&#8221; o impulso del sistema, cioè ogni volta che vengono richiesti nuovi dati di mercato dall&#8217;oggetto <code style="color: #e83e8c;">DataHandler</code>, il portfolio deve aggiornare il valore corrente di mercato di tutte le posizioni detenute. In uno scenario di trading live queste informazioni possono essere scaricate e analizzate direttamente dal broker, ma per un&#8217;implementazione di backtesting è necessario calcolare manualmente questi valori.</p><p>Sfortunatamente non esiste una cosa come il &#8220;valore corrente di mercato&#8221; a causa degli spread bid / ask e delle problematiche di liquidità. Quindi è necessario stimarlo moltiplicando la quantità del bene detenuta per un determinato &#8220;prezzo&#8221;. L&#8217;approccio utilizzato in questo esempio prevede di utilizzare il prezzo di chiusura dell&#8217;ultima barra ricevuta. Per una strategia intraday questo è relativamente realistico. Per una strategia quotidiana questo è meno realistico in quanto il prezzo di apertura può differire molto dal prezzo di chiusura.</p><p>Il metodo <code style="color: #e83e8c;">update_timeindex</code> gestisce il monitoraggio dei nuovi holdings. In particolare ricava i prezzi più recenti dal gestore dei dati di mercato e crea un nuovo dizionario di simboli per rappresentare le posizioni correnti, impostando le posizioni &#8220;nuove&#8221; uguali alle posizioni &#8220;correnti&#8221;. Questi vengono modificati solo quando si riceva un <code style="color: #e83e8c;">FillEvent</code>, che viene successivamente gestito dal portfolio. Il metodo quindi aggiunge questo insieme di posizioni correnti alla lista <code style="color: #e83e8c;">all_positions</code>. Successivamente, le posizioni vengono aggiornate in modo simile, con l&#8217;eccezione che il valore di mercato viene ricalcolato moltiplicando il conteggio delle posizioni correnti con il prezzo di chiusura dell&#8217;ultima barra (<code style="color: #e83e8c;">self.current_positions [s] * bars [s] [0] [ 5]</code>). Infine, i nuovi holdings sono agggiunti a <code style="color: #e83e8c;">all_holdings</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-393161e elementor-widget elementor-widget-bdt-source-code" data-id="393161e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def update_timeindex(self, event):
        &quot;&quot;&quot;
        Aggiunge un nuovo record alla matrice delle posizioni per la barra corrente
        dei dati di mercato. Questo riflette la barra PRECEDENTE, cioè in questa fase
        tutti gli attuali dati di mercato sono noti (OLHCVI).

        Utilizza un MarketEvent dalla coda degli eventi.
        &quot;&quot;&quot;
        latest_datetime = self.bars.get_latest_bar_datetime(
                                self.symbol_list[0]
                            )

        # Update positions
        dp = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] )
        dp[&#039;datetime&#039;] = latest_datetime

        for s in self.symbol_list:
            dp[s] = self.current_positions[s]

        # Aggiunge le posizioni correnti
        self.all_positions.append(dp)

        # Aggiorno delle holdings
        dh = dict( (k,v) for k, v in [(s, 0) for s in self.symbol_list] )
        dh[&#039;datetime&#039;] = latest_datetime
        dh[&#039;cash&#039;] = self.current_holdings[&#039;cash&#039;]
        dh[&#039;commission&#039;] = self.current_holdings[&#039;commission&#039;]
        dh[&#039;total&#039;] = self.current_holdings[&#039;cash&#039;]

        for s in self.symbol_list:
            # Approossimazione ad un valore reale
            market_value =  market_value = self.current_positions[s] * \
                            self.bars.get_latest_bar_value(s, &quot;adj_close&quot;)&quot;adj_close&quot;)
            dh[s] = market_value
            dh[&#039;total&#039;] += market_value

        # Aggiunta alle holdings correnti
        self.all_holdings.append(dh)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-bd4ae6c elementor-widget elementor-widget-text-editor" data-id="bd4ae6c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il metodo <code style="color: #e83e8c;">update_positions_from_fill</code> determina se <code style="color: #e83e8c;">FillEvent</code> è un Buy o un Sell e quindi aggiorna di conseguenza il dizionario <code style="color: #e83e8c;">current_positions</code> aggiungendo / sottraendo la corretta quantità di asset:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-748ce87 elementor-widget elementor-widget-bdt-source-code" data-id="748ce87" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def update_positions_from_fill(self, fill):
        &quot;&quot;&quot;
        Prende un oggetto FilltEvent e aggiorna la matrice delle posizioni
        per riflettere le nuove posizioni.

        Parametri:
        fill - L&#039;oggetto FillEvent da aggiornare con le posizioni.
        &quot;&quot;&quot;
        # Check whether the fill is a buy or sell
        fill_dir = 0
        if fill.direction == &#039;BUY&#039;:
            fill_dir = 1
        if fill.direction == &#039;SELL&#039;:
            fill_dir = -1

        # Aggiorna le posizioni con le nuove quantità
        self.current_positions[fill.symbol] += fill_dir * fill.quantity</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7a8cbf3 elementor-widget elementor-widget-text-editor" data-id="7a8cbf3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il corrispondente <code style="color: #e83e8c;">update_holdings_from_fill</code> è simile al metodo precedente ma aggiorna i valori di <em>holdings</em>. Per simulare il costo di riempimento, il metodo seguente non utilizza il costo associato a <code style="color: #e83e8c;">FillEvent</code>. Perchè questo approccio? In parole povere, in un ambiente di backtesting il costo di riempimento è in realtà sconosciuto e quindi deve essere stimato. Quindi il costo di riempimento è impostato sul &#8220;prezzo corrente di mercato&#8221; (il prezzo di chiusura dell&#8217;ultima barra). Le posizioni per un particolare simbolo vengono quindi impostate per essere uguali al costo di riempimento moltiplicato per la quantità del trade.</p><p>Una volta che il costo di riempimento è noto, gli holdings correnti, i contanti e i valori totali possono essere aggiornati. Anche la commissione cumulativa viene aggiornata:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3245a83 elementor-widget elementor-widget-bdt-source-code" data-id="3245a83" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def update_holdings_from_fill(self, fill):
        &quot;&quot;&quot;
        Prende un oggetto FillEvent e aggiorna la matrice delle holdings
        per riflettere il valore delle holdings.

        Parametri:
        fill - L&#039;oggetto FillEvent da aggiornare con le holdings.
        &quot;&quot;&quot;
        # Controllo se l&#039;oggetto fill è un buy o sell
        fill_dir = 0
        if fill.direction == &#039;BUY&#039;:
            fill_dir = 1
        if fill.direction == &#039;SELL&#039;:
            fill_dir = -1

        # Aggiorna la lista di holdings con le nuove quantità
        fill_cost = self.bars.get_latest_bar_value(fill.symbol, &quot;adj_close&quot;)
        cost = fill_dir * fill_cost * fill.quantity
        self.current_holdings[fill.symbol] += cost
        self.current_holdings[&#039;commission&#039;] += fill.commission
        self.current_holdings[&#039;cash&#039;] -= (cost + fill.commission)
        self.current_holdings[&#039;total&#039;] -= (cost + fill.commission)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-61c92a8 elementor-widget elementor-widget-text-editor" data-id="61c92a8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Qui viene implementato il metodo virtuale <code style="color: #e83e8c;">update_fill</code> della classe ABC <code style="color: #e83e8c;">Portfolio </code>. Esegue semplicemente i due metodi precedenti, <code>update_positions_from_fill </code>e <code>update_holdings_from_fill</code>, che sono già stati discussi sopra:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d94338d elementor-widget elementor-widget-bdt-source-code" data-id="d94338d" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code> # portfolio.py

def update_fill(self, event):
        &quot;&quot;&quot;
        Aggiorna le attuali posizioni e holdings del portafoglio da un FillEvent.
        &quot;&quot;&quot;
        if event.type == &#039;FILL&#039;:
            self.update_positions_from_fill(event)
            self.update_holdings_from_fill(event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-3e006a0 elementor-widget elementor-widget-text-editor" data-id="3e006a0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>L&#8217;oggetto <code style="color: #e83e8c;">Portfolio</code>, oltre a gestire i <code style="color: #e83e8c;">FillEvents</code>, deve anche occuparsi della generazione degli <code style="color: #e83e8c;">OrderEvents</code> al ricevimento di uno o più <code style="color: #e83e8c;">SignalEvents</code>. Il metodo <code style="color: #e83e8c;">generate_naive_order</code> prende un segnale di long o short di un asset e invia un ordine per aprire una posizione per 100 shares di tale asset. Chiaramente 100 è un valore arbitrario. In un&#8217;implementazione realistica questo valore sarà determinato da una gestione del rischio o da un overlay di ridimensionamento della posizione. Tuttavia, questo è un <code style="color: #e83e8c;">NaivePortfolio</code> e quindi &#8220;ingenuamente&#8221; invia tutti gli ordini direttamente dai segnali, senza un sistema di dimensionamento della posizione.</p><p>Il metodo gestisce il long, lo short e l&#8217;uscita di una posizione, in base alla quantità corrente e allo specifico simbolo. Infine vengono generati i corrispondenti oggetti <code style="color: #e83e8c;">OrderEvent</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-cd2de3e elementor-widget elementor-widget-bdt-source-code" data-id="cd2de3e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def generate_naive_order(self, signal):
        &quot;&quot;&quot;
        Trasmette semplicemente un oggetto OrderEvent con una quantità costante
        che dipendente dell&#039;oggetto segnale, senza gestione del rischio o
        considerazioni sul dimensionamento della posizione.

        Parametri:
        signal - L&#039;oggetto SignalEvent.
        &quot;&quot;&quot;     
        order = None

        symbol = signal.symbol
        direction = signal.signal_type
        strength = signal.strength

        mkt_quantity = floor(100 * strength)
        cur_quantity = self.current_positions[symbol]
        order_type = &#039;MKT&#039;

        if direction == &#039;LONG&#039; and cur_quantity == 0:
            order = OrderEvent(symbol, order_type, mkt_quantity, &#039;BUY&#039;)
        if direction == &#039;SHORT&#039; and cur_quantity == 0:
            order = OrderEvent(symbol, order_type, mkt_quantity, &#039;SELL&#039;)   
    
        if direction == &#039;EXIT&#039; and cur_quantity &gt; 0:
            order = OrderEvent(symbol, order_type, abs(cur_quantity), &#039;SELL&#039;)
        if direction == &#039;EXIT&#039; and cur_quantity &lt; 0:
            order = OrderEvent(symbol, order_type, abs(cur_quantity), &#039;BUY&#039;)
        return order</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9a1448b elementor-widget elementor-widget-text-editor" data-id="9a1448b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il metodo <code style="color: #e83e8c;">update_signal</code> richiama semplicemente il metodo precedente e aggiunge l&#8217;ordine generato alla coda degli eventi:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bda0640 elementor-widget elementor-widget-bdt-source-code" data-id="bda0640" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def update_signal(self, event):
        &quot;&quot;&quot;
        Azioni a seguito di un SignalEvent per generare nuovi ordini
        basati sulla logica del portafoglio 
        &quot;&quot;&quot;
        if event.type == &#039;SIGNAL&#039;:
            order_event = self.generate_naive_order(event)
            self.events.put(order_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-5212e4d elementor-widget elementor-widget-text-editor" data-id="5212e4d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il penultimo metodo di <code style="color: #e83e8c;">NaivePortfolio</code> prevede la generazione di una curva equity. Crea semplicemente un flusso dei rendimenti, utilizzato per i calcoli delle prestazioni e quindi normalizza la curva equity in base alla percentuale. La dimensione iniziale dell&#8217;account è pari a 1,0:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8abdfda elementor-widget elementor-widget-bdt-source-code" data-id="8abdfda" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def create_equity_curve_dataframe(self):
        &quot;&quot;&quot;
        Crea un DataFrame pandas dalla lista di dizionari &quot;all_holdings&quot;
        &quot;&quot;&quot;
        curve = pd.DataFrame(self.all_holdings)
        curve.set_index(&#039;datetime&#039;, inplace=True)
        curve[&#039;returns&#039;] = curve[&#039;total&#039;].pct_change()
        curve[&#039;equity_curve&#039;] = (1.0+curve[&#039;returns&#039;]).cumprod()
        self.equity_curve = curve</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-25ce6e2 elementor-widget elementor-widget-text-editor" data-id="25ce6e2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il metodo finale nel  <code style="color: #e83e8c;">NaivePortfolio</code>  è l&#8217;output della curva azionaria e di varie statistiche sulle performance della strategia. L&#8217;ultima riga genera un file, equity.csv, nella stessa directory del codice, che può essere caricato in uno script Matplotlib Python (o un foglio di calcolo come MS Excel o LibreOffice Calc) per un&#8217;analisi successiva.
<em>Si noti che la Durata del Drawdown è data in termini di numero assoluto di &#8220;barre&#8221; per le quali si è svolto il Drawdown, al contrario di un determinato periodo di tempo.</em>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d6d04e8 elementor-widget elementor-widget-bdt-source-code" data-id="d6d04e8" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># portfolio.py

    def output_summary_stats(self):
        &quot;&quot;&quot;
        Crea un elenco di statistiche di riepilogo per il portafoglio
        come lo Sharpe Ratio e le informazioni sul drowdown.
        &quot;&quot;&quot;
        total_return = self.equity_curve[&#039;equity_curve&#039;][-1]
        returns = self.equity_curve[&#039;returns&#039;]
        pnl = self.equity_curve[&#039;equity_curve&#039;]
        sharpe_ratio = create_sharpe_ratio(returns, periods=252 * 60 * 6.5)
        drawdown, max_dd, dd_duration = create_drawdowns(pnl)
        self.equity_curve[&#039;drawdown&#039;] = drawdown
        stats = [(&quot;Total Return&quot;, &quot;%0.2f%%&quot; % \
                  ((total_return - 1.0) * 100.0)),
                 (&quot;Sharpe Ratio&quot;, &quot;%0.2f&quot; % sharpe_ratio),
                 (&quot;Max Drawdown&quot;, &quot;%0.2f%%&quot; % (max_dd * 100.0)),
                 (&quot;Drawdown Duration&quot;, &quot;%d&quot; % dd_duration)]
        self.equity_curve.to_csv(&#039;equity.csv&#039;)
        return stats</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-d9dba00 elementor-widget elementor-widget-text-editor" data-id="d9dba00" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>L&#8217;oggetto <code style="color: #e83e8c;">NaivePortfolio</code> è la componente più complessa dell&#8217;intero sistema di backtesting basato sugli eventi. L&#8217;implementazione è complessa, quindi in questo articolo abbiamo semplificato alcuni aspetti tra cui la gestione delle posizioni. Le versioni successive prenderanno in considerazione la gestione del rischio e il dimensionamento delle posizioni, che porterà a un&#8217;idea molto più realistica delle prestazioni della strategia.</p><p>Nel prossimo articolo considereremo l&#8217;ultimo modulo di un sistema di backtesting event-driven, ovvero l&#8217;oggetto <code style="color: #e83e8c;">ExecutionHandler</code>, che viene utilizzato per prelevare oggetti <code style="color: #e83e8c;">OrderEvent</code> e creare oggetti <code style="color: #e83e8c;">FillEvent</code>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9219725 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="9219725" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-5419433 elementor-widget elementor-widget-text-editor" data-id="5419433" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-v-portafoglio/">Motore di Backtesting con Python – Parte V (Portafoglio)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte IV (Gestione della Strategia)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sun, 30 Apr 2017 12:48:06 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=867</guid>

					<description><![CDATA[<p>In questa serie di articoli relativa all&#8217;implementazione di un ambiente di backtesting basato sugli eventi abbiamo già descritto la struttura degli event-loop, la gerarchia della classe Event e la componente per la gestione dei dati. In questo articolo si introduce la gerarchia della classe Strategy. Gli oggetti &#8220;strategia&#8221; prendono i dati di mercato come input &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte IV (Gestione della Strategia)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/">Motore di Backtesting con Python – Parte IV (Gestione della Strategia)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="867" class="elementor elementor-867">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-b428f66 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="b428f66" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-809f563" data-id="809f563" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-f7663b8 elementor-widget elementor-widget-text-editor" data-id="f7663b8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questa serie di articoli relativa all&#8217;implementazione di un ambiente di backtesting basato sugli eventi abbiamo già descritto la <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">struttura degli event-loop</a>, la gerarchia della <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/">classe Event</a> e la componente per la <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-iii-dati-di-mercato/">gestione dei dati</a>. In questo articolo si introduce la gerarchia della classe <code style="color: #e83e8c;">Strategy</code>. Gli oggetti &#8220;strategia&#8221; prendono i dati di mercato come input e producono eventi di tipo <em>Signal Trading</em> come output.</p><p>Un oggetto <code style="color: #e83e8c;">Strategy</code> include tutti i calcoli sui dati di mercato che generano segnali <em>advisory</em> per l&#8217;oggetto <code style="color: #e83e8c;">Portfolio</code>. In questa fase di sviluppo dell&#8217;ambiente di backtesting event-driven non introduciamo i concetto di <em>indicatore</em> o <em>filtro</em>, come quelli che sono usati nell&#8217;analisi tecnica classica. Questi sono tuttavia buoni candidati per la creazione di una gerarchia di classi, ma vanno oltre lo scopo di questo articolo.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0fe9c96 elementor-widget elementor-widget-heading" data-id="0fe9c96" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Gestione delle Strategia</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-5a0b10c elementor-widget elementor-widget-text-editor" data-id="5a0b10c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">La gerarchia della classe Strategy è relativamente semplice poiché consiste in una classe base astratta con un singolo metodo puro virtuale per generare oggetti </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: rgb(232, 62, 140);">SignalEvent</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">. Per creare la gerarchia della strategia è necessario importare NumPy, Pandas, l&#8217;oggetto Queue, i strumenti della classe base astratta e </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: rgb(232, 62, 140);">SignalEvent</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">:</span><br></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a9120fd elementor-widget elementor-widget-bdt-source-code" data-id="a9120fd" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># strategy.py

import datetime
import numpy as np
import pandas as pd
import queue

from abc import ABCMeta, abstractmethod

from event import SignalEvent</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c8b0d5b elementor-widget elementor-widget-text-editor" data-id="c8b0d5b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>La classe base astratta <code style="color: #e83e8c;">Strategy</code> definisce semplicemente il metodo virtuale <code style="color: #e83e8c;">calculate_signals</code>. Questo metodo sarà usato nelle classi derivate per gestire la creazione di oggetti <code style="color: #e83e8c;">SignalEvent</code> a seconda degli aggiornamenti dei dati di mercato:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-07f22f1 elementor-widget elementor-widget-bdt-source-code" data-id="07f22f1" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># strategy.py


class Strategy(object):
    &quot;&quot;&quot;
    Strategy è una classe base astratta che fornisce un&#039;interfaccia per
    tutti i successivi oggetti (ereditati) di gestione della strategia.

    L&#039;obiettivo di un oggetto (derivato da) Strategy è generare un oggetto
    Signal per specifici simboli basati sugli input di Bars
    (OLHCVI) generati da un oggetto DataHandler.

    Questo è progettato per funzionare sia con dati storici che in tempo reale
    quindi l&#039;oggetto Strategy è agnostico rispetto all&#039;origine dati,
    poiché ricava le tuple di barre da un oggetto Queue (coda).
    &quot;&quot;&quot;

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        &quot;&quot;&quot;
        Fornisce il meccanismo per calcolare la lista di segnali.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement calculate_signals()&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-e9aa290 elementor-widget elementor-widget-text-editor" data-id="e9aa290" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Come mostrato nel codice precedente, la definizione della classe astratta <code style="color: #e83e8c;">Strategy</code> è semplice.<br />Un primo esempio di sottoclasse dell&#8217;oggetto <code style="color: #e83e8c;">Strategy</code> è la creazione della classe <code style="color: #e83e8c;">BuyAndHoldStrategy</code>, che implementa la classica strategia buy and hold. Questa strategia compra un asset ad una certo istante e lo conserva all&#8217;interno del portafoglio. Quindi viene generato un solo segnale per ogni asset.</p><p>Il costruttore (<code style="color: #e83e8c;">__init__</code>) prevede, come input, il gestore dei dati di mercato e l&#8217;oggetto della coda degli eventi <code style="color: #e83e8c;">Events</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-161e6b5 elementor-widget elementor-widget-bdt-source-code" data-id="161e6b5" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># strategy.py

class BuyAndHoldStrategy(Strategy):
    &quot;&quot;&quot;
    Questa è una strategia estremamente semplice che va LONG su tutti
    i simboli non appena viene ricevuta una barra. Non uscirà mai da una posizione.

    Viene utilizzato principalmente come meccanismo di test per la classe Strategy
    nonché un benchmark con cui confrontare le altre strategie.
    &quot;&quot;&quot;

    def __init__(self, bars, events):
        &quot;&quot;&quot;
        Inizializza la strategia &quot;buy and hold&quot;.

        Parametri:
        bars - L&#039;oggetto DataHandler che fornisce le informazioni sui prezzi
        events - L&#039;oggetto Event Queue (coda di eventi).
        &quot;&quot;&quot;
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Quando il segnale &quot;buy &amp; hold&quot; viene inviato, questi sono impostati a True
        self.bought = self._calculate_initial_bought()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-ce384ce elementor-widget elementor-widget-text-editor" data-id="ce384ce" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nell&#8217;inizializzazione di <code style="color: #e83e8c;">BuyAndHoldStrategy</code>, l&#8217;attributo <code style="color: #e83e8c;">bought</code> viene instanziato con un <em>dictionary</em> (una struttura dati nativa di Python) di chiavi per ogni simbolo, tutte impostate con False. Una volta che un asset è andato &#8220;long&#8221;, la relativa chiave viene impostata su True. In sostanza ciò consente alla Strategia di sapere su quali asset è &#8220;sul mercato&#8221; o meno:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-df922aa elementor-widget elementor-widget-bdt-source-code" data-id="df922aa" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># strategy.py

     def _calculate_initial_bought(self):
        &quot;&quot;&quot;
        Aggiunge le chiavi di tutti i simboli al dizionario &quot;bought&quot;
        e li imposta su False.
        &quot;&quot;&quot;
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-a23c9f4 elementor-widget elementor-widget-text-editor" data-id="a23c9f4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo virtuale <code style="color: #e83e8c;">calculate_signals</code> viene concretamente implementato in questa classe. Il metodo scorre su tutti i simboli nell&#8217;elenco dei simboli e recupera la barra OLHCV più recente dal gestore dei dati di mercato. Quindi controlla se quel simbolo è stato &#8220;comprato&#8221; (cioè se abbiamo una posizione aperta a mercato per questo simbolo o no) e, in caso negativo, crea un singolo oggetto <code style="color: #e83e8c;">SignalEvent</code>. Quest&#8217;ultimo viene poi inserito nella coda degli eventi e il dizionario <code style="color: #e83e8c;">bought</code> viene correttamente aggiornato con True per questo specifico simbolo:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0ba3536 elementor-widget elementor-widget-bdt-source-code" data-id="0ba3536" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># strategy.py

    def calculate_signals(self, event):
        &quot;&quot;&quot;
        For &quot;Buy and Hold&quot; generiamo un singolo segnale per simbolo
        e quindi nessun segnale aggiuntivo. Ciò significa che siamo
        costantemente LONG sul mercato a partire dalla data di 
        inizializzazione della strategia.

        Parametri
        event - Un oggetto MarketEvent.
        &quot;&quot;&quot;
        if event.type == &#039;MARKET&#039;:
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], &#039;LONG&#039;)
                        self.events.put(signal)
                        self.bought[s] = True</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-cbd79d7 elementor-widget elementor-widget-text-editor" data-id="cbd79d7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questa semplice strategia è sufficiente per dimostrare la natura di una gerarchia basata su eventi. Negli articoli successivi considereremo strategie più sofisticate come il pairs trading.</p><p>Infine nel prossimo articolo considereremo come creare la gerarchia della classe <code style="color: #e83e8c;">Portfolio</code> che tenga traccia delle nostre posizioni con un profitto e una perdita (&#8220;PnL&#8221;)</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4c244e1 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="4c244e1" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-ce1a990 elementor-widget elementor-widget-text-editor" data-id="ce1a990" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/">Motore di Backtesting con Python – Parte IV (Gestione della Strategia)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte III (Dati di Mercato)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-iii-dati-di-mercato/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 26 Apr 2017 06:15:39 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=839</guid>

					<description><![CDATA[<p>Nei due articoli precedenti della serie abbiamo introdotto i concetti base di un sistema di backtesting basato sugli eventi e la gerarchia di classi per l&#8217;oggetto Event. In questo articolo vediamo come vengono utilizzati i dati di mercato, sia in un contesto storico di backtesting sia per l&#8217;esecuzione del live trading. Uno dei nostri obiettivi &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iii-dati-di-mercato/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte III (Dati di Mercato)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iii-dati-di-mercato/">Motore di Backtesting con Python – Parte III (Dati di Mercato)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="839" class="elementor elementor-839">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-ed64d75 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="ed64d75" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-faf1e87" data-id="faf1e87" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-af7cf97 elementor-widget elementor-widget-text-editor" data-id="af7cf97" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nei due articoli precedenti della serie abbiamo introdotto i concetti base di un <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">sistema di backtesting basato sugli eventi</a> e la gerarchia di <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/">classi per l&#8217;oggetto Event</a>. In questo articolo vediamo come vengono utilizzati i dati di mercato, sia in un contesto storico di backtesting sia per l&#8217;esecuzione del live trading.</p><p>Uno dei nostri obiettivi con un sistema di trading basato sugli eventi è di minimizzare la duplicazione del codice tra l&#8217;elemento di backtesting e l&#8217;elemento di esecuzione <em>live</em>. Idealmente, è ottimale utilizzare la stessa metodologia di generazione del segnale e le stesse componenti di gestione del portafoglio sia per i test storici che per trading reale. Affinché questo funzioni, l&#8217;oggetto <code style="color: #e83e8c;">Strategy</code>, che genera i segnali, e l&#8217;oggetto <code style="color: #e83e8c;">Portfolio</code>, che fornisce gli ordini basati su di essi, devono utilizzare un&#8217;identica interfaccia verso un feed di dati finanziari, sia per la versione di backtesting che per quella live.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a1ef0b3 elementor-widget elementor-widget-heading" data-id="a1ef0b3" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">I Dati di Mercato</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-0fc0d83 elementor-widget elementor-widget-text-editor" data-id="0fc0d83" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">Questo requisito motiva la necessità di una gerarchia di classi basata sull&#8217;oggetto </span><code style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5); color: rgb(232, 62, 140);">DataHandler</code><span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">, che l&#8217;implementa un&#8217;interfaccia, disponibile a tutte le sottoclassi, per fornire i dati di mercato alle rimanenti componenti del sistema. In questo modo, si può intercambiare qualsiasi sottoclasse di &#8220;fornitura&#8221; di dati finanziari senza influenzare la strategia o il calcolo del portafoglio.</span><br></p>
<p>Esempi di sottoclassi specifiche possono includere <code style="color: #e83e8c;">HistoricCSVDataHandler</code>, <code style="color: #e83e8c;">QuandlDataHandler</code>, <code style="color: #e83e8c;">SecuritiesMasterDataHandler</code>, <code style="color: #e83e8c;">InteractiveBrokersMarketFeedDataHandler</code> ecc. In questo tutorial descriviamo solamente la creazione di un gestore CSV di dati storici, che caricherà da un CSV i dati intraday per le azioni nel formato Open-Low-High-Close- Volume-OpenInterest. Questo può quindi essere usato per alimentare con i dati &#8220;candela-per-candela&#8221; le classi Strategy e Portfolio per ogni heartbeat (o impulso) del sistema, evitando così i bias di look-ahead.</p>
<p>Il primo compito è importare le librerie necessarie. Nello specifico, si includono Pandas e gli strumenti astratti della classe base. Dato che DataHandler genera MarketEvents, si importa anche <code style="color: #e83e8c;">event.py</code> come descritto nel <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/">tutorial precedente</a>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-af44848 elementor-widget elementor-widget-bdt-source-code" data-id="af44848" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

import datetime
import os, os.path
import pandas as pd

from abc import ABCMeta, abstractmethod

from event import MarketEvent</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-0dfdae6 elementor-widget elementor-widget-text-editor" data-id="0dfdae6" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>La classe <code style="color: #e83e8c;">DataHandler</code> è una classe base astratta (ABC), cioè è impossibile istanziare direttamente un&#8217;istanza. Possono essere istanziate solamente le sottoclassi. Con questo approccio la classe ABC fornisce un&#8217;interfaccia che tutte le successive sottoclassi di <code style="color: #e83e8c;">DataHandler</code> devono rispettare, garantendo in tal modo la compatibilità con altre classi che comunicano con esse.</p><p>Facciamo uso della proprietà <code style="color: #e83e8c;">__metaclass__</code> per far sapere a Python che questa è una classe ABC. Inoltre usiamo il decoratore <code style="color: #e83e8c;">@abstractmethod</code> per far sapere a Python che il metodo verrà sovrascritto dalle sottoclassi (questo è identico a un <a href="http://en.wikipedia.org/wiki/Virtual_function#Abstract_classes_and_pure_virtual_functions">metodo virtuale puro</a> di C++).</p><p>I due metodi fondamentali sono <code style="color: #e83e8c;">get_latest_bars</code> e <code style="color: #e83e8c;">update_bars</code>. Il primo restituisce le ultime barre N a partire dal timestamp dall&#8217;attuale &#8220;impulso&#8221;, necessarie per far eseguire le elaborazioni previste nelle classi <code style="color: #e83e8c;">Strategy</code>. Il secondo metodo fornisce un meccanismo di &#8220;alimentazione a goccia&#8221; per posizionare le informazioni OLHCV su una nuova struttura dati in modo da evitare la distorsione lookahead. Si noti che verranno sollevate eccezioni se si verifica un tentativo di istanziazione della classe:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b1d2177 elementor-widget elementor-widget-bdt-source-code" data-id="b1d2177" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

class DataHandler(object):
    &quot;&quot;&quot;
    DataHandler è una classe base astratta che fornisce un&#039;interfaccia per
    tutti i successivi  gestori di dati (ereditati) (sia live che storici).

    L&#039;obiettivo di un oggetto (derivato da) DataHandler è generare un 
    set di barre (OLHCVI) per ogni simbolo richiesto.

    Questo replicherà il modo in cui una strategia live funzionerebbe quando nuovi 
    i dati di mercato sarebbero inviati &quot;giù per il tubo&quot;. Questo permette a sistemi 
    live e a sistemi con dati storici di essere trattati allo stesso modo dal resto
    della suite di backtest.
    &quot;&quot;&quot;

    __metaclass__ = ABCMeta

    @abstractmethod
    def get_latest_bar(self, symbol):
        &quot;&quot;&quot;
        Restituisce l&#039;ultima barra dalla lista latest_symbol.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bar()&quot;)

    @abstractmethod
    def get_latest_bars(self, symbol, N=1):
        &quot;&quot;&quot;
        Restituisce le ultime N barre dalla lista di barre
        per il simbolo, o meno se sono disponibili poche barre
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bars()&quot;)

    def get_latest_bar(self, symbol):
        &quot;&quot;&quot;
        Restituisce l&#039;ultima barra dalla lista latest_symbol.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bar()&quot;)

    @abstractmethod
    def get_latest_bar_datetime(self, symbol):
        &quot;&quot;&quot;
        Restituisce un oggetto datetime di Python per l&#039;ultima barra.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bar_datetime()&quot;)\


    @abstractmethod
    def get_latest_bar_value(self, symbol, val_type):
        &quot;&quot;&quot;
        Restituisce un elemento tra Open, High, Low, Close, Volume o Adj_Close
        from the last bar.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bar_value()&quot;)


    @abstractmethod
    def get_latest_bars_values(self, symbol, val_type, N=1):
        &quot;&quot;&quot;
        Restituisce i valori delle ultime N barre dalla lista
        latest_symbol, o N-k se non meno disponibili.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement get_latest_bars_values()&quot;)

    @abstractmethod
    def update_bars(self):
        &quot;&quot;&quot;
        Inserisce la barra più recente nella struttura delle barre per
        tutti i simboli della lista di simboli.
        &quot;&quot;&quot;
        raise NotImplementedError(&quot;Should implement update_bars()&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9eb016d elementor-widget elementor-widget-text-editor" data-id="9eb016d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Dopo aver definito la classe <code style="color: #e83e8c;">DataHandler</code>, il passo successivo è creare un gestore per i file CSV di dati storici. In particolare, <code style="color: #e83e8c;">HistoricCSVDataHandler</code> prenderà più file CSV, uno per ciascun simbolo, e li convertirà in un DataFrame di Panda.</p><p>Il gestore dati richiede alcuni parametri, ovvero una coda di eventi su cui inviare informazioni di MarketEvent, il percorso assoluto dei file CSV e un elenco di simboli.<br />Di seguito l&#8217;inizializzazione della classe:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f793cca elementor-widget elementor-widget-bdt-source-code" data-id="f793cca" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

class HistoricCSVDataHandler(DataHandler):
    &quot;&quot;&quot;
    HistoricCSVDataHandler è progettato per leggere dal disco
    fisso un file CSV per ogni simbolo richiesto e fornire
    un&#039;interfaccia per ottenere la barra &quot;più recente&quot; in un
    modo identico a un&#039;interfaccia di live trading.
    &quot;&quot;&quot;

    def __init__(self, events, csv_dir, symbol_list):
        &quot;&quot;&quot;
        Inizializza il gestore dei dati storici richiedendo
        la posizione dei file CSV e un elenco di simboli.

        Si presume che tutti i file abbiano la forma
        &quot;symbol.csv&quot;, dove symbol è una stringa dell&#039;elenco.

        Parametri:
        events - la coda degli eventi.
        csv_dir - percorso assoluto della directory dei file CSV.
        symbol_list - Un elenco di stringhe di simboli.
        &quot;&quot;&quot;
        
        self.events = events
        self.csv_dir = csv_dir
        self.symbol_list = symbol_list

        self.symbol_data = {}
        self.latest_symbol_data = {}
        self.continue_backtest = True

        self._open_convert_csv_files()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-a755223 elementor-widget elementor-widget-text-editor" data-id="a755223" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Questa funzione prevede quindi di aprire i file nel formato &#8220;SYMBOL.csv&#8221; dove il SYMBOL è il simbolo del ticker. Il formato dei file corrisponde a quello fornito da <a href="http://www.iqfeed.net/">DTN IQFeed</a>, ma si può facilmente modificare per gestire formati di dati aggiuntivi. L&#8217;apertura dei file è gestita dal seguente metodo <code style="color: #e83e8c;">_open_convert_csv_files</code>.</p><p>Uno dei vantaggi dell&#8217;uso della libreria Pandas come archivio all&#8217;interno di <code style="color: #e83e8c;">HistoricCSVDataHandler</code> è la possibilità di unire gli indici di tutti i simboli tracciati. Ciò consente di correggere i punti di dati mancanti in avanti, indietro o interpolati all&#8217;interno di questi spazi, in modo tale che i ticker possano essere confrontati &#8220;candela-per-candela&#8221;. Questo è necessario, ad esempio, per strategie di mean-reverting. Si noti l&#8217;uso dei metodi <code style="color: #e83e8c;">union</code> e <code style="color: #e83e8c;">reindex</code> quando si combina gli indici di tutti i simboli:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f145a79 elementor-widget elementor-widget-bdt-source-code" data-id="f145a79" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

    def _open_convert_csv_files(self):
        &quot;&quot;&quot;
        Apre i file CSV dalla directory dei dati, convertendoli
        in DataFrame pandas all&#039;interno di un dizionario di simboli.

        Per questo gestore si assumerà che i dati siano
        tratto da DTN IQFeed. Così il suo formato sarà rispettato.
        &quot;&quot;&quot;
        comb_index = None
        for s in self.symbol_list:
            # Carica il file CSV senza nomi delle colonne, indicizzati per data
            self.symbol_data[s] = pd.io.parsers.read_csv(
                                      os.path.join(self.csv_dir, &#039;%s.csv&#039; % s),
                                      header=0, index_col=0,
                                      names=[&#039;datetime&#039;,&#039;open&#039;,&#039;low&#039;,&#039;high&#039;,
                                             &#039;close&#039;,&#039;volume&#039;,&#039;adj_close&#039;]
                                  )

            # Combina l&#039;indice per riempire i valori successivi
            if comb_index is None:
                comb_index = self.symbol_data[s].index
            else:
                comb_index.union(self.symbol_data[s].index)

            # Imposta il più recente symbol_data a None
            self.latest_symbol_data[s] = []

        # Indicizza nuovamente i dataframes
        for s in self.symbol_list:
            self.symbol_data[s] = self.symbol_data[s].reindex(index=comb_index, method=&#039;pad&#039;).iterrows()
            </code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-96c06c0 elementor-widget elementor-widget-text-editor" data-id="96c06c0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Il metodo <code style="color: #e83e8c;">_get_new_bar</code> crea un <a href="https://wiki.python.org/moin/Generators">generatore python</a> per fornire una versione formattata dei dati OLCHV. Questo significa che le successive chiamate al metodo genereranno una nuova barra fino al raggiungimento della fine dei dati del simbolo:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3112b5a elementor-widget elementor-widget-bdt-source-code" data-id="3112b5a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

    def _get_new_bar(self, symbol):
        &quot;&quot;&quot;
        Restituisce l&#039;ultima barra dal feed di dati come una tupla di
        (sybmbol, datetime, open, low, high, close, volume).
        &quot;&quot;&quot;
        for b in self.symbol_data[symbol]:
            yield b</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-251ce84 elementor-widget elementor-widget-text-editor" data-id="251ce84" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Di seguito l&#8217;implementazione dei metodi astratti di <code style="color: #e83e8c;">DataHandler</code>. Questi metodi forniscono varie forme di accesso alle barre acquisite. Dipende dalla fonte di acquisizione dati e dalla struttura dati in cui viene acquisita:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-45b3398 elementor-widget elementor-widget-bdt-source-code" data-id="45b3398" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

    def get_latest_bar(self, symbol):
        &quot;&quot;&quot;
        Restituisce l&#039;ultima barra dalla lista latest_symbol.
        &quot;&quot;&quot;
        try:
            bars_list = self.latest_symbol_data[symbol]
        except KeyError:
            print(&quot;That symbol is not available in the historical data set.&quot;)
            raise
        else:
            return bars_list[-1]


    def get_latest_bars(self, symbol, N=1):
        &quot;&quot;&quot;
        Restituisce le ultime N barre dall&#039;elenco latest_symbol
        o N-k se non sono tutte disponibili.
        &quot;&quot;&quot;
        try:
            bars_list = self.latest_symbol_data[symbol]
        except KeyError:
            print(&quot;That symbol is not available in the historical data set.&quot;)
        else:
            return bars_list[-N:]


    def get_latest_bar_datetime(self, symbol):
        &quot;&quot;&quot;
        Restituisce un oggetto datetime di Python per l&#039;ultima barra.
        &quot;&quot;&quot;
        try:
            bars_list = self.latest_symbol_data[symbol]
        except KeyError:
            print(&quot;That symbol is not available in the historical data set.&quot;)
            raise
        else:
            return bars_list[-1][0]

    def get_latest_bar_value(self, symbol, val_type):
        &quot;&quot;&quot;
        Restituisce un elemento tra Open, High, Low, Close, Volume o Adj_Close
        from the last bar.
        &quot;&quot;&quot;
        try:
            bars_list = self.latest_symbol_data[symbol]
        except KeyError:
            print(&quot;That symbol is not available in the historical data set.&quot;)
            raise
        else:
            return getattr(bars_list[-1][1], val_type)


    def get_latest_bars_values(self, symbol, val_type, N=1):
        &quot;&quot;&quot;
        Restituisce i valori delle ultime N barre dalla lista
        latest_symbol, o N-k se non meno disponibili.
        &quot;&quot;&quot;
        try:
            bars_list = self.get_latest_bars(symbol, N)
        except KeyError:
            print(&quot;That symbol is not available in the historical data set.&quot;)
            raise
        else:
            return np.array([getattr(b[1], val_type) for b in bars_list])
</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8049c27 elementor-widget elementor-widget-text-editor" data-id="8049c27" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>L&#8217;ultimo metodo astratto, <code style="color: #e83e8c;">update_bars</code>, genera semplicemente un <code style="color: #e83e8c;">MarketEvent</code> che viene aggiunto alla coda, e aggiunge le ultime barre a <code style="color: #e83e8c;">latest_symbol_data</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5a2b165 elementor-widget elementor-widget-bdt-source-code" data-id="5a2b165" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># data.py

    def update_bars(self):
        &quot;&quot;&quot;
        Inserisce l&#039;ultima barra nella struttura latest_symbol_data
        per tutti i simboli nell&#039;elenco dei simboli.
        &quot;&quot;&quot;
        for s in self.symbol_list:
            try:
                bar = self._get_new_bar(s).next()
            except StopIteration:
                self.continue_backtest = False
            else:
                if bar is not None:
                    self.latest_symbol_data[s].append(bar)
        self.events.put(MarketEvent())</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-20dbfaf elementor-widget elementor-widget-text-editor" data-id="20dbfaf" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>A questo punto abbiamo implementato un oggetto derivato da <code style="color: #e83e8c;">DataHandler</code>, che viene utilizzato dai restanti componenti per tenere traccia dei dati di mercato. Gli oggetti <code style="color: #e83e8c;">Strategy</code>, <code style="color: #e83e8c;">Portfolio</code> ed <code style="color: #e83e8c;">ExecutionHandler</code> richiedono i dati di mercato aggiornati, quindi ha senso centralizzare questa gestione al fine di evitare la duplicazione del codice e di possibili bug.</p>
<p>Nel prossimo articolo vedremo la gerarchia della classe <code style="color: #e83e8c;">Strategy</code> e descriviamo come una strategia può essere progettata per gestire più simboli, generando così più <code style="color: #e83e8c;">SignalEvents</code> per l&#8217;oggetto <code style="color: #e83e8c;">Portfolio</code>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-922d317 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="922d317" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-8342312 elementor-widget elementor-widget-text-editor" data-id="8342312" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-iii-dati-di-mercato/">Motore di Backtesting con Python – Parte III (Dati di Mercato)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python – Parte II (Gli Eventi)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sat, 22 Apr 2017 15:46:25 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=826</guid>

					<description><![CDATA[<p>Nel precedente articolo abbiamo introdotto la struttura base di un ambiente di backtesting event-driven. Il resto di questa serie di articoli si concentrerà su ciascuna delle gerarchie di classi  che costituiscono il sistema generale. In questo articolo i descrivono gli Eventi e come questi possono essere usati per scambiare informazioni tra gli oggetti. Come discusso &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/"> <span class="screen-reader-text">Motore di Backtesting con Python – Parte II (Gli Eventi)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/">Motore di Backtesting con Python – Parte II (Gli Eventi)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="826" class="elementor elementor-826">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-cf30f70 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="cf30f70" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-b04bcd5" data-id="b04bcd5" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-df16c74 elementor-widget elementor-widget-text-editor" data-id="df16c74" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nel precedente articolo abbiamo introdotto la struttura base di un <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">ambiente di backtesting event-driven</a>. Il resto di questa serie di articoli si concentrerà su ciascuna delle gerarchie di classi  che costituiscono il sistema generale. In questo articolo i descrivono gli <strong>Eventi</strong> e come questi possono essere usati per scambiare informazioni tra gli oggetti.</p><p>Come discusso nel precedente articolo, il sistema di trading utilizza due loop: uno esterno e uno interno. Il loop interno gestisce l&#8217;acquisizione degli eventi da una coda in memoria, e il loro smistamento verso gli specifici componenti che gestiscono la conseguente azione.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-51c97c6 elementor-widget elementor-widget-heading" data-id="51c97c6" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Gli Eventi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-673c9d8 elementor-widget elementor-widget-text-editor" data-id="673c9d8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<span style="font-style: inherit; font-weight: inherit; background-color: var(--ast-global-color-5);">In questo sistema ci sono quattro tipi di eventi:</span>
<ul>
 	<li><strong>MarketEvent</strong>: viene attivato quando il loop esterno inizia un nuovo &#8220;impulso&#8221;. Si verifica quando l&#8217;oggetto <code style="color: #e83e8c;">DataHandler</code> riceve un nuovo aggiornamento dei dati di mercato per tutti i simboli che sono attualmente monitorati. Viene utilizzato per attivare l&#8217;oggetto <code style="color: #e83e8c;">Strategy</code> che genera nuovi segnali di trading. L&#8217;oggetto Event contiene semplicemente un&#8217;identificazione che si tratta di un evento di mercato, senza altre strutture.</li>
 	<li><strong>SignalEvent</strong>: l&#8217;oggetto <code style="color: #e83e8c;">Strategy</code> utilizza i dati di mercato per creare nuovi SignalEvent. <code style="color: #e83e8c;">SignalEvents</code> contiene un simbolo ticker, il timestamp di quando è stato generato e una direzione (long o short). I SignalEvents sono utilizzati dall&#8217;oggetto <code style="color: #e83e8c;">Portfolio</code> come consigli su come effettuare i trade.</li>
 	<li><b>OrderEvent</b>: quando un oggetto <code style="color: #e83e8c;">Portfolio</code> riceve i <code style="color: #e83e8c;">SignalEvents</code>, questi sono valutati nel contesto generale del portfolio, in termini di rischio e dimensionamento della posizione. Questo processo genera un OrderEvents che verrà inviato a un <code style="color: #e83e8c;">ExecutionHandler</code>.</li>
 	<li><strong>FillEvent</strong>: dopo la ricezione di un <code style="color: #e83e8c;">OrderEvent</code>, l&#8217;<code style="color: #e83e8c;">ExecutionHandler</code> deve eseguire l&#8217;ordine. Una volta che un ordine è stato eseguito, genera un <code style="color: #e83e8c;">FillEvent</code>, che descrive il costo di acquisto o vendita, nonché i costi di transazione, come le commissioni o lo slippage.</li>
</ul>
<h4>La classe Event</h4><br>
La classe genitore è chiamata <code style="color: #e83e8c;">Event</code>. È una classe base e non fornisce alcuna funzionalità o interfaccia specifica. Nelle implementazioni successive gli oggetti Event svilupperanno una maggiore complessità e quindi stiamo definendo la progettazione di tali sistemi creando una gerarchia di classi.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d47e2f0 elementor-widget elementor-widget-bdt-source-code" data-id="d47e2f0" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># event.py

class Event(object):
    &quot;&quot;&quot;
    Event è la classe base che fornisce un&#039;interfaccia per tutti
    i tipi di sottoeventi (ereditati), che attiverà ulteriori 
    eventi nell&#039;infrastruttura di trading.
    &quot;&quot;&quot;
    pass</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4dee4f9 elementor-widget elementor-widget-text-editor" data-id="4dee4f9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h4>La classe MarketEventi</h4><br>
La classe <code style="color: #e83e8c;">MarketEvent</code> eredita da <code style="color: #e83e8c;">Event</code> e prevede semplicemente di autoidentificare l&#8217;evento come di tipo &#8220;MARKET&#8221;.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bcd1f59 elementor-widget elementor-widget-bdt-source-code" data-id="bcd1f59" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># event.py

class MarketEvent(Event):
    &quot;&quot;&quot;
    Gestisce l&#039;evento di ricezione di un nuovo aggiornamento dei 
    dati di mercato con le corrispondenti barre.
    &quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;
        Inizializzazione del MarketEvent.
        &quot;&quot;&quot;
        self.type = &#039;MARKET&#039;</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-0d49ca3 elementor-widget elementor-widget-text-editor" data-id="0d49ca3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h4>La classe SignalEvent</h4><br>
La classe <code style="color: #e83e8c;">SignalEvent</code> richiede un simbolo ticker, un timestamp della generazione e una direzione per &#8220;avvisare&#8221; un oggetto <code style="color: #e83e8c;">Portfolio</code>.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6b05e84 elementor-widget elementor-widget-bdt-source-code" data-id="6b05e84" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># event.py

class SignalEvent(Event):
    &quot;&quot;&quot;
    Gestisce l&#039;evento di invio di un Segnale da un oggetto Strategia.
    Questo viene ricevuto da un oggetto Portfolio e si agisce su di esso.
    &quot;&quot;&quot;

    def __init__(self, symbol, datetime, signal_type):
        &quot;&quot;&quot;
        Inizializzazione del SignalEvent.

        Parametri:
        symbol - Il simbolo del ticker, es. &#039;GOOG&#039;.
        datetime - Il timestamp al quale il segnale è stato generato.
        signal_type - &#039;LONG&#039; o &#039;SHORT&#039;.
        &quot;&quot;&quot;

        self.type = &#039;SIGNAL&#039;
        self.symbol = symbol
        self.datetime = datetime
        self.signal_type = signal_type</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-5b1bf9c elementor-widget elementor-widget-text-editor" data-id="5b1bf9c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h4>La classe OrderEvent</h4><br>
La classe <code style="color: #e83e8c;">OrderEvent</code> è leggermente più complessa rispetto alla SignalEvent poiché contiene un campo quantità, oltre alle già citate proprietà di <code style="color: #e83e8c;">SignalEvent</code>. La quantità è determinata dai vincoli del portafoglio. Inoltre, OrderEvent ha un metodo <code style="color: #e83e8c;">print_order()</code>, utilizzato per inviare le informazioni alla console, se necessario.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-172919e elementor-widget elementor-widget-bdt-source-code" data-id="172919e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># event.py

class OrderEvent(Event):
    &quot;&quot;&quot;
    Gestisce l&#039;evento di invio di un ordine al sistema di esecuzione.
    L&#039;ordine contiene un simbolo (ad esempio GOOG), un tipo di ordine
    (a mercato o limite), una quantità e una direzione.
    &quot;&quot;&quot;

    def __init__(self, symbol, order_type, quantity, direction):
        &quot;&quot;&quot;
        Inizializza il tipo di ordine, impostando se è un ordine a mercato
        (&#039;MKT&#039;) o un ordine limite (&#039;LMT&#039;), la quantità (integral) 
        e la sua direzione (&#039;BUY&#039; or &#039;SELL&#039;).

        Parametri:
        symbol - Lo strumento da tradare.
        order_type - &#039;MKT&#039; o &#039;LMT&#039; per ordine Market or Limit.
        quantity - Intero non negativo per la quantità.
        direction - &#039;BUY&#039; o &#039;SELL&#039; per long o short.
        &quot;&quot;&quot;

        self.type = &#039;ORDER&#039;
        self.symbol = symbol
        self.order_type = order_type
        self.quantity = quantity
        self.direction = direction

    def print_order(self):
        &quot;&quot;&quot;
        Stampa dei valori che compongono l&#039;ordine.
        &quot;&quot;&quot;
        print
        &quot;Order: Symbol=%s, Type=%s, Quantity=%s, Direction=%s&quot; % \
        (self.symbol, self.order_type, self.quantity, self.direction)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-880ebe0 elementor-widget elementor-widget-text-editor" data-id="880ebe0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h4>La classe FillEvent</h4><br>
La classe <code style="color: #e83e8c;">FillEvent</code> è l&#8217;evento con la maggiore complessità. Contiene un timestamp di quando è stato effettuato un ordine, il simbolo dell&#8217;ordine e l&#8217;exchange su cui è stato eseguito, la quantità di azioni negoziate, il prezzo effettivo dell&#8217;acquisto e la commissione sostenuta.

La commissione viene calcolata utilizzando le commissioni di Interactive Brokers. Per l&#8217;azionario statunitenze questa commissione è pari ad un minimo di 1 USD per ordine, con una tariffa fissa di 0,005 USD per azione.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-13dae6c elementor-widget elementor-widget-bdt-source-code" data-id="13dae6c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># event.py

class FillEvent(Event):
    &quot;&quot;&quot;
    Incorpora il concetto di un ordine eseguito, come restituito
    da un broker. Memorizza l&#039;effettiva quantità scambiata di
    uno strumento e a quale prezzo. Inoltre, memorizza
    la commissione del trade applicata dal broker.
    &quot;&quot;&quot;

    def __init__(self, timeindex, symbol, exchange, quantity,
                 direction, fill_cost, commission=None):
        &quot;&quot;&quot;
        Inizializza l&#039;oggetto FillEvent. Imposta il simbolo, il broker,
        la quantità, la direzione, il costo di esecuzione e una
        commissione opzionale.

        Se la commissione non viene fornita, l&#039;oggetto Fill la calcola
        in base alla dimensione del trade e alle commissioni di
        Interactive Brokers.

        Parametri:
        timeindex - La risoluzione delle barre quando l&#039;ordine è stato eseguito.
        symbol - Lo strumento che è stato eseguito.
        exchange - Il broker/exchange dove l&#039;ordine è stato eseguito.
        quantity - La quantità effettivamente scambiata.
        direction - La direzione dell&#039;esecuzione (&#039;BUY&#039; o &#039;SELL&#039;)
        fill_cost - Il valore nominale in dollari.
        commission - La commissione opzionale inviata da IB.
        &quot;&quot;&quot;

        self.type = &#039;FILL&#039;
        self.timeindex = timeindex
        self.symbol = symbol
        self.exchange = exchange
        self.quantity = quantity
        self.direction = direction
        self.fill_cost = fill_cost

        # Calcolo della commissione
        if commission is None:
            self.commission = self.calculate_ib_commission()
        else:
            self.commission = commission

    def calculate_ib_commission(self):
        &quot;&quot;&quot;
        Calcolo delle commisioni di trading basate sulla struttura
        delle fee per la API di Interactive Brokers, in USD.

        Non sono incluse le fee di exchange o ECN.

        Basata sulla &quot;US API Directed Orders&quot;:
        https://www.interactivebrokers.com/en/index.php?f=commission&amp;p=stocks2
        &quot;&quot;&quot;
        full_cost = 1.3
        if self.quantity &lt;= 300:
            full_cost = max(0.35, 0.0035 * self.quantity)
        elif self.quantity &lt;= 3000:
            full_cost = max(0.35, 0.002 * self.quantity)
        elif self.quantity &lt;= 20000:
            full_cost = max(0.35, 0.0015 * self.quantity)
        elif self.quantity &lt;= 100000:
            full_cost = max(0.35, 0.001 * self.quantity)
        else:  # Maggiore di 100 mila azioni
            full_cost = max(0.35, 0.0005 * self.quantity)
   #     full_cost = min(full_cost, 1.0 / 100.0 * self.quantity * self.fill_cost)
        return full_cost</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-bff038c elementor-widget elementor-widget-text-editor" data-id="bff038c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Nel prossimo articolo della serie vedremo come sviluppare la gerarchia della classe <code style="color: #e83e8c;">DataHandler</code> che permetta sia backtesting storico che il live trading, tramite la stessa classe di interfaccia.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2163686 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="2163686" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-5407a02 elementor-widget elementor-widget-text-editor" data-id="5407a02" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-ii-gli-eventi/">Motore di Backtesting con Python – Parte II (Gli Eventi)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Motore di Backtesting con Python &#8211; Parte I (Struttura Base)</title>
		<link>https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Tue, 18 Apr 2017 08:47:13 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Backtesting]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=809</guid>

					<description><![CDATA[<p>Negli ultimi mesi abbiamo descritto su DataTrading come testare le varie strategie di trading utilizzando Python e Pandas. La natura vettoriale di Pandas permette elaborazioni estremamente rapide su set di dati di grandi dimensioni siano. Tuttavia, gli approcci di backtesting vettorializzato che abbiamo studiato finora presentano alcune criticità nelle modalità di simulazione dell&#8217;esecuzione dei trade. &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/"> <span class="screen-reader-text">Motore di Backtesting con Python &#8211; Parte I (Struttura Base)</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">Motore di Backtesting con Python &#8211; Parte I (Struttura Base)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="809" class="elementor elementor-809">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-dba5f1f elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="dba5f1f" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-41edcb0" data-id="41edcb0" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-d1f6549 elementor-widget elementor-widget-text-editor" data-id="d1f6549" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Negli ultimi mesi abbiamo descritto su DataTrading come testare le varie strategie di trading utilizzando Python e Pandas. La natura vettoriale di Pandas permette elaborazioni estremamente rapide su set di dati di grandi dimensioni siano. Tuttavia, gli approcci di backtesting vettorializzato che abbiamo studiato finora presentano alcune criticità nelle modalità di simulazione dell&#8217;esecuzione dei trade. 
In questa serie di articoli discuteremo un approccio più realistico alla simulazione della strategia, usando Python per costruire un ambiente di backtesting basato sugli eventi.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fb5be84 elementor-widget elementor-widget-heading" data-id="fb5be84" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Software basati sugli Eventi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-637dc12 elementor-widget elementor-widget-text-editor" data-id="637dc12" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Prima di approfondire lo sviluppo di questo ambiente di backtesting, è necessario introdurre i concetti base dei sistemi basati sugli eventi. I videogiochi forniscono un classico caso d&#8217;uso di tale tipologia di software e sono un semplice esempio da studiare. Un videogioco ha più componenti che interagiscono tra loro in un ambiente real-time con elevati frame-rate. Questo viene gestito grazie all&#8217;esecuzione di una serie di calcoli all&#8217;interno di un ciclo &#8220;infinito&#8221; noto come <strong>event-loop</strong> o <strong>game-loop</strong>.</p><p>Ad ogni <em>tick</em> del game-loop viene chiamata una funzione che si occupa di acquisire l&#8217;ultimo evento, quest&#8217;ultimo è stato generato da una corrispondente azione precedente all&#8217;interno del loop. A seconda della natura dell&#8217;evento, come ad esempio la pressione di un tasto o il clic del mouse, sono eseguite specifiche azioni che interromperanno il ciclo o genereranno alcuni eventi aggiuntivi.</p><p>Di seguito un esempio del pseudo-codice dell&#8217;event-loop:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-53bd5d4 elementor-widget elementor-widget-bdt-source-code" data-id="53bd5d4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>while True:  # Esecuzione infinita del loop f
    new_event = get_new_event()   # ottengo l&#039;ultimo evento

    # A seconda del tipo di evento si esegue una azione
    if new_event.type == &quot;LEFT_MOUSE_CLICK&quot;:
        open_menu()
    elif new_event.type == &quot;ESCAPE_KEY_PRESS&quot;:
        quit_game()
    elif new_event.type == &quot;UP_KEY_PRESS&quot;:
        move_player_north()
    # ... e molti altri eventi

    redraw_screen()   # Update dell&#039;output per fornire un&#039;animazione
    tick(50)   # Pausa di 50 millisecondi</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c4e06bd elementor-widget elementor-widget-text-editor" data-id="c4e06bd" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il codice verifica continuamente la presenza di nuovi eventi e, in caso affermativo, esegue azioni a seconda del tipo di eventi. In particolare, permette l&#8217;illusione di un sistema con risposta in tempo reale dato che il codice viene continuamente ripetuto e quindi si ha una verifica continua degli eventi. Ovviamente, questo è esattamente quello di cui abbiamo bisogno per effettuare simulazioni di trading ad alta frequenza.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-657fbe9 elementor-widget elementor-widget-heading" data-id="657fbe9" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Perchè abbiamo bisogno di un Backtesting Event-Driven</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-fd5f63c elementor-widget elementor-widget-text-editor" data-id="fd5f63c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>I sistemi basati sugli eventi offrono molti vantaggi rispetto a un approccio vettorializzato:</p><ul><li><strong>Riutilizzo del codice</strong> &#8211; un backtester basato sugli eventi, in base alla progettazione, può essere utilizzato sia per il backtesting storico sia per il live trading con una minima modifica dei componenti. Questo non è possibile per i backtesting vettorizzati dove tutti i dati devono essere disponibili contemporaneamente per poter effettuare analisi statistiche.</li><li><strong>Bias di Look-Ahead</strong> &#8211; con un backtesting basato sugli eventi non vi è alcun bias di previsione perché l&#8217;acquisizione dei dati finanziari è gestita come un &#8220;evento&#8221; su cui si deve effettuare specifiche azioni. In questo modo è possibile un ambiente di backtestering event-driven è alimentato  &#8220;instante dopo instante&#8221; con i dati di mercato, replicando il comportamento di un sistema di gestione degli ordini e del portafoglio.</li><li><strong>Realismo</strong> &#8211; I backtesting basati sugli eventi consentono una significativa personalizzazione del modalità di esecuzione degli ordini e dei costi di transazione sostenuti. È semplice gestire il market-order e il limit-order, oltre al market-on-open (MOO) e al market-on-close (MOC), poiché è possibile costruire un gestore di exchange personalizzato.</li></ul><p> </p><p>Sebbene i sistemi basati sugli eventi siano dotati di numerosi vantaggi, essi presentano due importanti svantaggi rispetto ai più semplici sistemi vettorizzati. Innanzitutto sono molto più complessi da implementare e testare. Ci sono più &#8220;parti mobili&#8221; che causano una maggiore probabilità di introdurre bug. Per mitigare questa criticità è possibile implementare una  metodologia di testing del software, come il <a href="http://en.wikipedia.org/wiki/Test-driven_development">test-driven development</a>.</p><p>In secondo luogo, hanno tempi di esecuzione più lenti da eseguire rispetto a un sistema vettorializzato. Le operazioni vettoriali ottimizzate non possono essere utilizzate quando si eseguono calcoli matematici. Discuteremo dei modi per superare queste limitazioni negli articoli successivi.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4abada0 elementor-widget elementor-widget-heading" data-id="4abada0" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Struttura di un sistema di Backtesting Event-Driven</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-e14f948 elementor-widget elementor-widget-text-editor" data-id="e14f948" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per applicare un approccio event-driven a un sistema di backtesting è necessario definire i componenti base (o oggetti) che gestiscono compiti specifici:</p><ul><li><strong>Event</strong>: l&#8217;<code style="color: #e83e8c;">Event</code> è la classe fondamentale di un sistema event-driven. Contiene un attributto &#8220;tipo&#8221; (ad esempo, &#8220;MARKET&#8221;, &#8220;SIGNAL&#8221;, &#8220;ORDER&#8221; o &#8220;FILL&#8221;) che determina come viene gestito uno specifico evento all&#8217;interno dell&#8217;event-loop.</li><li><strong>Event Queue</strong>: la Coda degli Eventi è un oggetto Python Queue che memorizza tutti gli oggetti della sotto-classe Event generati dal resto del software.</li><li><strong>DataHandler</strong>: il <code style="color: #e83e8c;">DataHandler</code> è una <a href="http://en.wikipedia.org/wiki/Class_%28computer_programming%29#Abstract_and_concrete">classe base astratta</a> (ABC) che presenta un&#8217;interfaccia per la gestione di dati storici o del mercato in tempo reale. Fornisce una significativa flessibilità in quanto i moduli della strategia e del portfolio possono essere riutilizzati da entrambi gli approcci. Il DataHandler genera un nuovo MarketEvent ad loop del sistema (vedi sotto).</li><li><strong>Strategy: </strong>anche la <code style="color: #e83e8c;">Strategy</code> è una classe ABC e presenta un&#8217;interfaccia per elaborare i dati di mercato e generare i corrispondenti SignalEvents, che vengono infine utilizzati dall&#8217;oggetto Portfolio. Un SignalEvent contiene un simbolo ticker, una direzione (LONG or SHORT) e un timestamp.</li><li><strong>Portfolio</strong>: si tratta di una classe ABC che implementa la gestione degli ordini associata alle posizioni attuali e future di una strategia. Svolge anche la gestione del rischio in tutto il portafoglio, compresa l&#8217;esposizione settoriale e il dimensionamento delle posizioni. In un&#8217;implementazione più sofisticata, questo potrebbe essere delegato a una classe RiskManagement. La classe <code style="color: #e83e8c;">Portfolio</code> prende un SignalEvents dalla coda e genera uno o più OrderEvents che vengono aggiunti alla coda.</li><li><strong>ExecutionHandler</strong>: l&#8217;<code style="color: #e83e8c;">ExecutionHandler</code> simula una connessione a una società di intermediazione o broker. Il suo compito consiste nel prelevare gli OrderEvents dalla coda ed eseguirli, tramite un approccio simulato o una connessione reale verso il broker. Una volta eseguiti gli ordini, il gestore crea i FillEvents, che descrivono ciò che è stato effettivamente scambiato, comprese le commissioni, lo spread e lo slippage (se modellato).</li><li><strong>Loop</strong> &#8211; Tutti questi componenti sono racchiusi in un event-loop che gestisce correttamente tutti i tipi di eventi, indirizzandoli al componente appropriato.</li></ul><p>Questo è il modello base di un motore di trading. Vi è un significativo margine di espansione, in particolare per quanto riguarda l&#8217;utilizzo del portafoglio. Inoltre, i diversi modelli di costo delle transazioni possono essere implementati utilizzando una propria gerarchia di classi. In questa fase però introdurrebbe una complessità inutile all&#8217;interno di questa serie di articoli, quindi al momento non viene approfondita ulteriormente. Nei tutorial successivi si potrà pensare di  espandere il sistema per includere ulteriori gradi di realismo.</p><p>Di seguito potete trovare il codice Python che mostra  come il backtester funziona in pratica. Ci sono due loop nidificati all&#8217;interno del codice. Il loop esterno è usato per dare al backtester un impulso, o ritmo. Nel live trading questa è la frequenza con cui vengono acquisiti i nuovi dati di mercato. Per le strategie di backtesting questo non è strettamente necessario poiché il backtester utilizza i dati di mercato forniti in forma di drip-feed (vedi la riga <code style="color: #e83e8c;">bars.update_bars ())</code>.</p><p>Il ciclo interno gestisce effettivamente gli eventi dall&#8217;oggetto Queue. Gli Eventi specifici sono delegati al rispettivo componente e successivamente vengono aggiunti nuovi eventi alla coda. Quando la coda degli eventi è vuota, si riprende il ciclo esterno:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-359238b elementor-widget elementor-widget-bdt-source-code" data-id="359238b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Dichiarazione dei componenti e rispettive classi 
bars = DataHandler(..)
strategy = Strategy(..)
port = Portfolio(..)
broker = ExecutionHandler(..)

while True:
    # Update delle barre dei prezzi (codice specifico per il backtesting, opposto al live trading)
    if bars.continue_backtest == True:
        bars.update_bars()
    else:
        break

    # Gestione degli eventi
    while True:
        try:
            event = events.get(False)
        except Queue.Empty:
            break
        else:
            if event is not None:
                if event.type == &#039;MARKET&#039;:
                    strategy.calculate_signals(event)
                    port.update_timeindex(event)

                elif event.type == &#039;SIGNAL&#039;:
                    port.update_signal(event)

                elif event.type == &#039;ORDER&#039;:
                    broker.execute_order(event)

                elif event.type == &#039;FILL&#039;:
                    port.update_fill(event)

    # pausa di 10 minuti
    time.sleep(10 * 60)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-1db4344 elementor-widget elementor-widget-text-editor" data-id="1db4344" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Questo è lo schema di base di come è progettato un ambiente di backtesting basato sugli eventi. Nel prossimo articolo si descrive la gerarchia della classe Events.					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">Motore di Backtesting con Python &#8211; Parte I (Struttura Base)</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Value at Risk (VaR) per il Risk Management nel Trading Algoritmico</title>
		<link>https://datatrading.info/value-at-risk-var-per-il-risk-management-nel-trading-algoritmico/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Thu, 13 Apr 2017 14:55:25 +0000</pubDate>
				<category><![CDATA[Tutorial Trading Algoritmico]]></category>
		<category><![CDATA[Tutorial Money Management]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=819</guid>

					<description><![CDATA[<p>La stima del rischio di perdite per una strategia di trading algoritmica, o portafoglio di strategie, è di estrema importanza per la crescita del capitale a lungo termine. Molte tecniche per la gestione del rischio sono state sviluppate per l&#8217;uso in contesti istituzionali. Una tecnica in particolare, nota come Value at Risk, o VaR, sarà &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/value-at-risk-var-per-il-risk-management-nel-trading-algoritmico/"> <span class="screen-reader-text">Value at Risk (VaR) per il Risk Management nel Trading Algoritmico</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/value-at-risk-var-per-il-risk-management-nel-trading-algoritmico/">Value at Risk (VaR) per il Risk Management nel Trading Algoritmico</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="819" class="elementor elementor-819">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-d3700de elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="d3700de" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-473371d" data-id="473371d" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-68c281f elementor-widget elementor-widget-text-editor" data-id="68c281f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>La stima del rischio di perdite per una strategia di trading algoritmica, o portafoglio di strategie, è di estrema importanza per la crescita del capitale a lungo termine. Molte tecniche per la gestione del rischio sono state sviluppate per l&#8217;uso in contesti istituzionali. Una tecnica in particolare, nota come <b>Value at Risk</b>, o <b>VaR</b>, sarà l&#8217;argomento di questo articolo.</p><p>Applicheremo il concetto di VaR a una singola strategia o a una serie di strategie per aiutarci a quantificare il rischio nel nostro portafoglio di trading. La definizione di VaR è la seguente:</p><p><em><b>Il VaR fornisce una stima, con un certo grado di confidenza, delle dimensioni delle perdite di un portafoglio in un determinato periodo di tempo.</b></em></p><p>In questo caso, il &#8220;portafoglio&#8221; può riferirsi a una singola strategia, a un gruppo di strategie, agli ordini di un trader, a un desk, a un hedge fund o a un&#8217;intera banca d&#8217;investimento. Il &#8220;grado di confidenza&#8221; è un valore, di solito pari al 95% o 99%. Il &#8220;determinato periodo di tempo&#8221; sarà scelto come il periodo di tempo che produrrebbe il minimo <i>market impact</i> se un portafoglio dovesse essere liquidato, cioè, secondo un’altro punto di vista, la lunghezza del periodo di detenzione di un dato asset nel portafoglio (holding period).</p><p>Ad esempio, un VaR pari a 500.000 USD con un livello di confidenza del 95% per un periodo di tempo di un giorno significa semplicemente che esiste una probabilità del 95% di perdere non più di 500.000 USD nel giorno successivo. Matematicamente questo è affermato come:</p><p style="text-align: center;">\(\begin{eqnarray}<br />P(L \leq -5.0 \times 10^5) = 0.05<br />\end{eqnarray}\)</p><p>O, più in generale, per la perdita L che supera un valore VaR con un livello di confidenza c si ha:</p><p style="text-align: center;">\(\begin{eqnarray}<br />P(L \leq -VaR) = 1-c<br />\end{eqnarray}\)</p><p>L&#8217;uso del VaR come misura di rischio presuppone l&#8217;ipotesi di normalità dei rendimenti, secondo la quale le perdite e i ricavi dell&#8217;investimento si distribuiscono secondo una normale con media pari al rendimento medio e varianza pari alla volatilità dell&#8217;investimento. Per il calcolo della varianza di portafoglio è necessario conoscere le correlazioni reciproche fra i titoli facenti parte del portafoglio, facendo ricorso alla matrice di varianze e covarianze.</p><p>È importante notare che il VaR non può anticipare cambiamenti nella composizione del portafoglio durante la giornata. Invece, riflette il rischio del portafoglio, data l&#8217;attuale composizione del portafoglio.</p><p>Il calcolo &#8220;standard&#8221; del VaR formula le seguenti ipotesi:</p><ul><li><b>Condizioni di mercato standard</b> &#8211; Il VaR non dovrebbe considerare gli eventi estremi o &#8220;risk tail&#8221;, piuttosto dovrebbe fornire l&#8217;aspettativa delle perdite durante la normale operatività zione normale &#8220;day per day&#8221;.</li><li><b>Volatilità e correlazioni</b> &#8211; Il VaR richiede la volatilità delle attività in esame, nonché le rispettive correlazioni. Queste due quantità sono difficili da stimare e sono soggette a cambiamenti continui.</li><li><b>Normalità dei resi</b> &#8211; il VaR, nella sua forma standard, presuppone che i rendimenti dell’asset o del portafoglio siano normalmente distribuiti. Ciò porta a calcoli analitici più semplici, ma approssima NON realisticamente per la maggior parte delle attività.</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7d90259 elementor-widget elementor-widget-heading" data-id="7d90259" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Vantaggi e Svantaggio</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-46b0e3e elementor-widget elementor-widget-text-editor" data-id="46b0e3e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il VaR è pervasivo nel settore finanziario, quindi dovresti avere familiarità con i vantaggi e gli svantaggi della tecnica. Alcuni dei vantaggi del VaR sono i seguenti:</p><ul><li>Il VaR è molto semplice da calcolare per le singole attività, le strategie algoritmiche, i portafogli quantistici, gli hedge fund e anche per i desk bancari.</li><li>Il periodo di tempo associato al VaR può essere modificato per diverse strategie di trading che hanno orizzonti temporali diversi.</li><li>Differenti valori del VaR possono essere associati a diverse forme di rischio, per esempio suddivise per classi di asset o tipologie di strumento. Ciò rende facile interpretare, ad esempio, dove si concentra la maggior parte del rischio del portafoglio.</li><li>Le singole strategie possono essere limitate all’interno di interi portafogli in base al singolo VaR.</li><li>Il VaR è semplice da interpretare dagli investitori e dei gestori di fondi esterni (potenzialmente) non tecnici.</li></ul><p>Tuttavia, il VaR non è privo di svantaggi:</p><ul><li>Il VaR non quantifica l&#8217;entità della perdita attesa oltre al valore del VaR, cioè valuta la probabilità di avere una perdita superiore ad uno specifico valore, ma non di quanto superi questo valore.</li><li>Non tiene conto di eventi estremi, ma solo delle condizioni tipiche di mercato.</li><li>Dal momento che utilizza i dati storici (è retrospettivo) non prenderà in considerazione i dati futuri del mercato che possono modificare le volatilità e le correlazioni tra gli asset.</li><li>Il VaR non deve essere usato in autonomia. Dovrebbe essere sempre utilizzato all’interno di una suite di tecniche per la gestione del rischio, come la diversificazione, l&#8217;allocazione ottimale del portafoglio e l&#8217;uso prudente della leva finanziaria.</li></ul><p> </p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a03dcf3 elementor-widget elementor-widget-heading" data-id="a03dcf3" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Metodo di Calcolo</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-e3dd980 elementor-widget elementor-widget-text-editor" data-id="e3dd980" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Finora non abbiamo descritto come calcolare effettivamente il VaR, né nel caso generale né in un concreto esempio di trading. Ci sono tre tecniche principali:</p><ul><li><p>il metodo varianza-covarianza, assumendo che i rendimenti sono sempre distribuiti secondo una normale);</p></li><li><p>il metodo Monte Carlo, dove i rendimenti futuri delle attività sono simulate in maniera più o meno casuale, dati alcuni parametri;</p></li><li><p>la simulazione storica, dove si assume che i rendimenti delle attività si distribuiranno come si sono distribuite in passato.</p></li></ul><p>In questo articolo ci concentreremo sul metodo Varianza-covarianza e negli articoli successivi considereremo i metodi Monte Carlo e la Simulazione Storica.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-10882e3 elementor-widget elementor-widget-heading" data-id="10882e3" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Metodo della Varianza-Covarianza</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-b078d24 elementor-widget elementor-widget-text-editor" data-id="b078d24" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Si considera un portafoglio di <i><b>P</b></i> dollari, con un livello di confidenza <i><b>c</b></i>. Inoltre si considerano i profitti giornalieri, con una deviazione standard storica patrimoniale (o della strategia) σ e la media μ. In questo caso il VaR giornaliero, con il metodo varianza-covarianza per un singolo asset (o strategia) viene calcolato come:</p><p style="text-align: center;">\(\begin{eqnarray}<br />P &#8211; \left( P (\alpha(1-c) + 1) \right)<br />\end{eqnarray}\)</p><p>Dove α è l&#8217;inverso della funzione di distribuzione cumulativa di una distribuzione normale con media μ e deviazione standard σ.</p><p>In un ambiente Python possiamo usare le librerie SciPy e Pandas per calcolare questi valori. Se impostiamo \(P=10^6\) e \(c=0.99\), possiamo usare il <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html">metodo ppf di SciPy</a> per generare i valori della funzione di distribuzione cumulativa inversa per una distribuzione normale, dove μ e σ sono ottenuti da alcuni dati finanziari reali.</p><p>Nel seguente codice si utilizzano i rendimenti giornalieri storici di CitiGroup (ma si può facilmente sostituire questi valori con i profitti di una strategia algoritmica):</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e7e199d elementor-widget elementor-widget-bdt-source-code" data-id="e7e199d" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># var.py

import datetime
import numpy as np
from pandas_datareader import data as pdr
from scipy.stats import norm


def var_cov_var(P, c, mu, sigma):
    &quot;&quot;&quot;
    Calcolo della varianza-covarianza del Value-at-Risk giornaliero
    utilizzando il livello di confidenza c, con media dei rendimenti mu
    e la deviazione standard dei rendimenti sigma, su un portafoglio
    di valore P.
    &quot;&quot;&quot;
    alpha = norm.ppf(1-c, mu, sigma)
    return P - P*(alpha + 1)

if __name__ == &quot;__main__&quot;:
    ticker = &quot;C&quot;
    start = datetime.datetime(2010, 1, 1)
    end = datetime.datetime(2014, 1, 1)

    citi = pdr.get_data_yahoo(ticker, start, end)
    citi[&quot;rets&quot;] = citi[&quot;Adj Close&quot;].pct_change()

    P = 1e6   # 1,000,000 USD
    c = 0.99  # 99% intervallo di confidenza
    mu = np.mean(citi[&quot;rets&quot;])
    sigma = np.std(citi[&quot;rets&quot;])

    var = var_cov_var(P, c, mu, sigma)
    print(&quot;Value-at-Risk: {}0.2f&quot;.format(var))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-e1a4d45 elementor-widget elementor-widget-text-editor" data-id="e1a4d45" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il valore calcolato del VaR è dato da:</p><p><strong>Value-at-Risk: $ 56510.29</strong></p><p>Il VaR è una tecnica estremamente utile e amapiamente utilizzata in tutti i settori della gestione finanziaria, ma non è esente da difetti. Dobbiamo ancora discutere il valore reale di ciò che potrebbe essere perso in un portafoglio, piuttosto che il numero di volte che tale perdita superi una specifica soglia.</p><p>Nei successi articoli si introdurranno alcuni metodi alternativi per calcolare il VaR, e soprattutto delineeremo il concetto di <strong>Expected Shortfall</strong> (noto anche come Value at Risk Condizionale), che fornisce una probabilità alla perdita di una determinata quantità.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2e0dcb1 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="2e0dcb1" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-eec1f41 elementor-widget elementor-widget-text-editor" data-id="eec1f41" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo utilizzando il modulo di backtesting vettoriale VectorBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/VectorBacktest">https://github.com/datatrading-info/VectorBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/value-at-risk-var-per-il-risk-management-nel-trading-algoritmico/">Value at Risk (VaR) per il Risk Management nel Trading Algoritmico</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
