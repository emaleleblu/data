<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Tutorial Strategie Sistematiche Archivi - Data Trading</title>
	<atom:link href="https://datatrading.info/category/tutorial-strategie-sistematiche/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Tecnologie Digitali applicate al Trading</description>
	<lastBuildDate>Sat, 24 Sep 2022 06:10:23 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://datatrading.info/wp-content/uploads/2019/04/favico.-300x300.jpg</url>
	<title>Tutorial Strategie Sistematiche Archivi - Data Trading</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Strategia di trading sull&#8217;indice S&#038;P500 con i modelli ARIMA e GARCH</title>
		<link>https://datatrading.info/strategia-di-trading-sullindice-sp500-con-i-modelli-arima-e-garch/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 20 Jun 2018 15:22:00 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Strategie]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=6321</guid>

					<description><![CDATA[<p>In questo articolo descriviamo come applicare tutte le  metodologie presentate nei precedenti articoli relativi all&#8217;analisi delle serie temporali ad una strategia di trading sull&#8217;indice S&#38;P500 del mercato azionario statunitense. Vediamo come combinando i modelli ARIMA e GARCH possiamo  significativamente sovraperformare un approccio &#8220;Buy-and-Hold&#8221; a lungo termine. Panoramica della strategia L&#8217;idea della strategia è relativamente semplice ma se &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/strategia-di-trading-sullindice-sp500-con-i-modelli-arima-e-garch/"> <span class="screen-reader-text">Strategia di trading sull&#8217;indice S&#038;P500 con i modelli ARIMA e GARCH</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/strategia-di-trading-sullindice-sp500-con-i-modelli-arima-e-garch/">Strategia di trading sull&#8217;indice S&#038;P500 con i modelli ARIMA e GARCH</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="6321" class="elementor elementor-6321">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-b8666d0 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="b8666d0" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-351d1ba" data-id="351d1ba" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-53db58c elementor-widget elementor-widget-text-editor" data-id="53db58c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo descriviamo come applicare tutte le  metodologie presentate nei precedenti articoli relativi all&#8217;<a href="https://datatrading.info/tutorial/data-science/">analisi delle serie temporali</a> ad una strategia di trading sull&#8217;indice S&amp;P500 del mercato azionario statunitense.</p><p>Vediamo come combinando i modelli <a href="https://datatrading.info/modelli-autoregressivi-integrati-a-media-mobile-arimap-d-q/">ARIMA</a> e <a href="https://datatrading.info/modelli-di-eteroschedasticita-condizionale-autoregressiva-generalizzata-garchp-q/">GARCH</a> possiamo  significativamente sovraperformare un approccio &#8220;Buy-and-Hold&#8221; a lungo termine.</p><h2>Panoramica della strategia</h2><p>L&#8217;idea della strategia è relativamente semplice ma se vuoi sperimentarla ti consiglio vivamente di leggere i precedenti  post <a href="https://datatrading.info/tutorial/data-science/">sull&#8217;analisi delle serie temporali</a> per capire i concetti matematici alla base di questo studio!</p><p>La strategia viene eseguita su base &#8220;rolling&#8221;:</p><ol><li>Per ogni giorno, <em>n</em>, si usano i rendimenti logaritmici differenziati di un indice del mercato azionario dei <span style="font-size: 15px; font-style: normal; font-weight: 400;">precedenti <em>k</em> giorni </span>come finestra per adattare un modello ARIMA e GARCH ottimale.</li><li>Il modello combinato è usato per fare una previsione per i rendimenti del giorno successivo.</li><li>Se la previsione è negativa il titolo viene shortato alla chiusura, mentre se è positiva si va long.</li><li>Se la previsione è nella stessa direzione del giorno precedente, non cambia nulla.</li></ol><p>Per questa strategia abbiamo usato il periodo storico massimo dei dati disponibili su Yahoo Finance per l&#8217;S&amp;P500. Inoltre abbiamo considerato <em>k=500</em> come parametro che può essere ottimizzato per migliorare le prestazioni o ridurre il drawdown.</p><p>Eseguiamo un semplice  backtest vettorializzato usando Python. Quindi le prestazioni ottenute in un sistema di trading reale sarebbero probabilmente leggermente inferiori a quelle ottenute nel backtest, a causa delle commissioni e dello slippage.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2579d3c elementor-widget elementor-widget-text-editor" data-id="2579d3c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h2>Implementazione della strategia</h2>
<p>Per implementare la strategia usiamo tilizzeremo parte del codice che abbiamo creato in precedenza nella serie di articoli sull&#8217;analisi delle serie temporali.</p>
<p>Quando si tratta di modellazione delle serie temporali di dati finanziari, i modelli autoregressivi (modelli che utilizzano valori precedenti per prevedere il futuro) come ARMA, ARIMA o GARCH e le sue varie varianti sono&nbsp; quelli solitamente preferiti per spiegare le basi della modellazione delle serie temporali. Tuttavia, l&#8217;applicazione pratica di queste tecniche&nbsp; in strategie di trading reali e il confronto con strategie benchmark (come il Buy and Hold) non sono così comuni. Inoltre, non è facile trovare un&#8217;implementazione pronta per l&#8217;uso che possa essere facilmente replicata per altri mercati, asset, ecc.</p><h4 id="86e3" class="wc lf ja bm lg wd we wf lk wg wh wi lo kg wj kh ls kj wk kk lw km wl kn ma wm fw">Modello ARIMA+GARCH</h4>
<p id="73ae" class="pw-post-body-paragraph vj vk ja vl b vm vn kb vo vp vq ke vr lp vs vt vu lt vv vw vx lx vy vz wa wb it fw" data-selectable-paragraph="">Per adattare il modello ARIMA+GARCH, seguiamo il modo convenzionale che prevede di adattare il modello ARIMA e poi applicare il modello GARCH ai rendimenti.&nbsp;La previsione finale consiste nella somma della previsione ARIMA più la previsione GARCH. Iniziamo recuperando i prezzi storici dell&#8217;indice SP500 dal 2000 al 2018 e calcolare i ritorni logaritmici, tramite le librerie <code>yfinance</code>, <code>numpy</code> e <code>pandas</code> di Python.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7317481 elementor-widget elementor-widget-code-highlight" data-id="7317481" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp>import yfinance as yf
import pandas as pd
import numpy as np

symbol='^GSPC'
start = '2002-01-01'
end = '2018-12-31'
SP500 = yf.download(symbol, start=start, end=end)

log_ret = np.log(SP500['Adj Close']) - np.log(SP500['Adj Close'].shift(1))</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-a47d529 elementor-widget elementor-widget-text-editor" data-id="a47d529" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Una volta ottenuto il DataFrame con i rendimenti dell&#8217;indice, creiamo il set di dati relativi agli ultimi k giorni per adattare il modello. Inoltre, creiamo un DataFrame chiamato <code>forecasts</code> per memorizzare i risultati del nostro modello.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d45eb67 elementor-widget elementor-widget-code-highlight" data-id="d45eb67" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp># Creazione del dataset
windowLength = 500
foreLength = len(log_ret) - windowLength

windowed_ds = []
for i in range(foreLength-1):
    windowed_ds.append(log_ret[i:i + windowLength])

# creazione del dataframe forecasts con zeri
forecasts = log_ret.iloc[windowLength:].copy() * 0</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-61f8f50 elementor-widget elementor-widget-text-editor" data-id="61f8f50" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p id="4038" class="pw-post-body-paragraph vj vk ja vl b vm wn kb vo vp wo ke vr lp wp vt vu lt wq vw vx lx wr vz wa wb it fw" data-selectable-paragraph="">Per convalidare il nostro set di dati, dobbiamo considerare che la prima finestra termina il  &#8220;2003–12–24&#8221; e la data della prima previsione è &#8220;2003–12–26&#8221;, allo stesso modo l&#8217;ultima finestra termina al &#8220;2018–12–28&#8221; e l&#8217;ultima previsione al &#8216;2018–12–29&#8217;.</p><p id="0300" class="pw-post-body-paragraph vj vk ja vl b vm wn kb vo vp wo ke vr lp wp vt vu lt wq vw vx lx wr vz wa wb it fw" data-selectable-paragraph="">Ora che abbiamo i nostri set di dati e creato i nostri target, dobbiamo analizzare ogni set e adattare i modelli. A tale scopo usiamo i pacchetti <code class="fl xg xh xi xj b">pmdarima</code> e <code class="fl xg xh xi xj b">arch</code>, che possono essere installati con <code class="fl xg xh xi xj b">pip install pmdarima, arch</code>.</p><p id="504a" class="pw-post-body-paragraph vj vk ja vl b vm wn kb vo vp wo ke vr lp wp vt vu lt wq vw vx lx wr vz wa wb it fw" data-selectable-paragraph="">Invece di analizzare i vari iperparametri (p e q) per il modello ARIMA e selezionare quello con il migliore adattamento in base  all&#8217;Akaike Information Criterion (AIC) più basso, la libreria <code class="fl xg xh xi xj b">pmdarima</code> comprende la  classe <code class="fl xg xh xi xj b">AutoARIMA</code> che permette di ottenere automaticamente l&#8217;adattamento migliore. Tuttavia, non potevo evitare che si adattasse a p o q uguale a zero, anche quando si specificano i parametri <code class="fl xg xh xi xj b">start_p </code>e . <code class="fl xg xh xi xj b">start_q</code>. Quindi, sono passato alla vecchia maniera.</p><p id="4661" class="pw-post-body-paragraph vj vk ja vl b vm wn kb vo vp wo ke vr lp wp vt vu lt wq vw vx lx wr vz wa wb it fw" data-selectable-paragraph="">Per prima cosa creiamo una funzione fit_arima che riceve una serie e restituisce l&#8217;adattamento miglior e, a partire dagli intervalli per p e q.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-005d8d5 elementor-widget elementor-widget-code-highlight" data-id="005d8d5" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp>import pmdarima
import arch

import warnings

warnings.filterwarnings("ignore")


def fit_arima(series, range_p=range(0, 6), range_q=range(0, 6)):
    final_order = (0, 0, 0)
    best_aic = np.inf
    arima = pmdarima.ARIMA(order=final_order)

    for p in range_p:
        for q in range_q:
            if (p == 0) and (q == 0):
                next
            arima.order = (p, 0, q)
            arima.fit(series)

            aic = arima.aic()

            if aic < best_aic:
                best_aic = aic
                final_order = (p, 0, q)

    arima.order = final_order
    return arima.fit(series)</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-3452f32 elementor-widget elementor-widget-text-editor" data-id="3452f32" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Creiamo ora un ciclo dove richiamare il metodo  fit_arima per ogni set di dati, usando i residui per adattare un modello GARCH(1,1) e quindi calcoliamo la previsione di un set per entrambi i modelli. Il risultato finale sarà la somma di entrambe le previsioni.

Nota: questo approccio in due fasi non è l&#8217;ideale perchè le parti ARIMA e GARCH devono essere trattate e ridotte al minimo come un unico modello. Tuttavia, python no dispone di una simile libreria.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-728f320 elementor-widget elementor-widget-code-highlight" data-id="728f320" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp>
for i, window in enumerate(windowed_ds):
    # ARIMA model
    arima = fit_arima(window)
    arima_pred = arima.predict(n_periods=1)

    # GARCH model
    garch = arch.arch_model(arima.resid())
    garch_fit = garch.fit(disp='off', show_warning=False, )
    garch_pred = garch_fit.forecast(horizon=1).mean.iloc[-1]['h.1']

    forecasts.iloc[i] = arima_pred + garch_pred

    print(f'Date {str(forecasts.index[i].date())} : Fitted ARIMA order {arima.order} - Prediction={forecasts.iloc[i]}')
</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-0ee24f5 elementor-widget elementor-widget-text-editor" data-id="0ee24f5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Dopo aver calcolato le previsioni, effettuiamo un confronto confronto tra la strategia ARIMA+GARCH e il benchmark Buy and Hold.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f37b957 elementor-widget elementor-widget-code-highlight" data-id="f37b957" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp>
for i, window in enumerate(windowed_ds):
    # ARIMA model
    arima = fit_arima(window)
    arima_pred = arima.predict(n_periods=1)

    # GARCH model
    garch = arch.arch_model(arima.resid())
    garch_fit = garch.fit(disp='off', show_warning=False, )
    garch_pred = garch_fit.forecast(horizon=1).mean.iloc[-1]['h.1']

    forecasts.iloc[i] = arima_pred + garch_pred

    print(f'Date {str(forecasts.index[i].date())} : Fitted ARIMA order {arima.order} - Prediction={forecasts.iloc[i]}')
</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-eaa38fe elementor-widget elementor-widget-text-editor" data-id="eaa38fe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Una volta calcolate le nostre previsioni, faremo implementiamo il codice per fornire il confronto tra la strategia Buy and Hold e ARIMA+GARCH.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-97a5618 elementor-widget elementor-widget-code-highlight" data-id="97a5618" data-element_type="widget" data-widget_type="code-highlight.default">
				<div class="elementor-widget-container">
					<div class="prismjs-okaidia copy-to-clipboard word-wrap">
			<pre data-line="" class="highlight-height language-python ">
				<code readonly="true" class="language-python">
					<xmp>
# Memorizzazione dei nuovi segnali calcolati
forecasts.columns=['Date','Signal']
forecasts.set_index('Date', inplace=True)
forecasts.to_csv('prova.csv')

# Otteniamo il periodo che ci interessa
forecasts = forecasts[(forecasts.index>='2004-01-01') & (forecasts.index<='2018-12-31')]

# Calcolo direzione delle previsioni
forecasts['Signal'] = np.sign(forecasts['Signal'])
forecasts.index = pd.to_datetime(forecasts.index)

# Creo un dataframe che contiene le statistiche della strategia
stats=SP500.copy()
stats['LogRets']=log_ret
stats = stats[(stats.index>='2004-01-01') & (stats.index<='2018-12-31')]
stats.loc[stats.index, 'StratSignal'] = forecasts.loc[stats.index, 'Signal']
stats['StratLogRets'] = stats['LogRets'] * stats['StratSignal']
stats.loc[stats.index, 'CumStratLogRets'] = stats['StratLogRets'].cumsum()
stats.loc[stats.index, 'CumStratRets'] = np.exp(stats['CumStratLogRets'])

# Calcolo del confronto con il benchmark
start_stats = pd.to_datetime('2004-01-02')
end_stats = pd.to_datetime('2012-12-31')

results = stats.loc[(stats.index > start_stats) & (stats.index < end_stats), ['Adj Close', 'LogRets', 'StratLogRets']].copy()

results['CumLogRets'] = results['LogRets'].cumsum()
results['CumRets'] = 100 * (np.exp(results['CumLogRets']) - 1)

results['CumStratLogRets'] = results['StratLogRets'].cumsum()
results['CumStratRets'] = 100 * (np.exp(results['CumStratLogRets']) - 1)

buy_hold_first = SP500.loc[start_stats, 'Adj Close']
buy_hold_last = SP500.loc[end_stats, 'Adj Close']
buy_hold = (buy_hold_last-buy_hold_first)/buy_hold_first

strategy = np.exp(results.loc[results.index[-1], 'CumStratLogRets']) - 1

pct_pos_returns = (results['LogRets'] > 0).mean() * 100
pct_strat_pos_returns = (results['StratLogRets'] > 0).mean() * 100

print(f'Returns:')
print(f'Buy_n_Hold - Return in period: {100 * buy_hold:.2f}% - Positive returns: {pct_pos_returns:.2f}%')
print(f'Strategy - Return in period: {100 * strategy:.2f}% - Positive returns: {pct_strat_pos_returns:.2f}%')

import matplotlib.pyplot as plt

columns = ['CumLogRets', 'CumStratLogRets']
plot_df = results[columns]
plot_df.plot(figsize=(15,7))
</xmp>
				</code>
			</pre>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-8739741 elementor-widget elementor-widget-image" data-id="8739741" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="700" height="343" src="https://datatrading.info/wp-content/uploads/trading-algoritmico-ARIMA_GARCH-strategy-returns.png" class="attachment-large size-large" alt="trading-algoritmico-ARIMA_GARCH-strategy-returns" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/trading-algoritmico-ARIMA_GARCH-strategy-returns.png 700w, https://datatrading.info/wp-content/uploads/trading-algoritmico-ARIMA_GARCH-strategy-returns-300x147.png 300w, https://datatrading.info/wp-content/uploads/trading-algoritmico-ARIMA_GARCH-strategy-returns-160x78.png 160w" sizes="(max-width: 700px) 100vw, 700px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1bdaf7c elementor-widget elementor-widget-text-editor" data-id="1bdaf7c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<h2>Conclusione</h2>
<p>Nel grafico vediamo che l&#8217;equity della strategia rimane sotto il benchmark Buy &amp; Hold per quasi 3 anni, ma durante il crollo del mercato azionario del 2008/2009 va molto bene. E&#8217; probabile che in questo periodo si è verificata una correlazione seriale significativa ed è stata ben catturata dai modelli ARIMA e GARCH. Dal 2009 il mercato si è ripreso ed è entrato in quella che sembra essere più una tendenza stocastica, le prestazioni del modello ricominciano a risentirne.</p>
<p>Si noti che questa strategia può essere facilmente applicata a diversi indici del mercato azionario, azioni o altre classi di attività.&nbsp;Ti incoraggio vivamente a provare lo studio per altri strumenti, poiché potresti ottenere risultati migliori da quelli qui presentati.</p>
<h2>Prossimi passi</h2>
<p>Ora che abbiamo terminato la descrizione dei modelli della famiglia ARIMA e GARCH, continuiamo l&#8217;analisi delle serie temporali considerando i processi a memoria lunga, i modelli dello spazio degli stati e le serie temporali cointegrate.</p>
<p>Queste successive aree dell&#8217;analisi delle serie temporali ci introducono modelli che possono migliorare le nostre previsioni rispetto a quanto descritto finora, il che aumenterà significativamente la nostra redditività e/o ridurrà il rischio.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/strategia-di-trading-sullindice-sp500-con-i-modelli-arima-e-garch/">Strategia di trading sull&#8217;indice S&#038;P500 con i modelli ARIMA e GARCH</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DataTrader – Trading Algoritmico Avanzato: il Gestore del Portfolio</title>
		<link>https://datatrading.info/datatrader-trading-algoritmico-avanzato-il-gestore-del-portfolio/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Fri, 15 Jun 2018 10:42:44 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial DataTrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2764</guid>

					<description><![CDATA[<p>Nell&#8217;attuale serie sull&#8217;infrastruttura di trading avanzata abbiamo descritto sia la classe di posizione che la classe di portafoglio , due componenti essenziali di un solido backtesting e di un sistema di live trading. In questo articolo estenderemo la discussione alla classe Portfolio Handler , che completerà la descrizione del portfolio Order Management System (OMS). L&#8217;OMS è la spina dorsale di qualsiasi &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-il-gestore-del-portfolio/"> <span class="screen-reader-text">DataTrader – Trading Algoritmico Avanzato: il Gestore del Portfolio</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-il-gestore-del-portfolio/">DataTrader – Trading Algoritmico Avanzato: il Gestore del Portfolio</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2764" class="elementor elementor-2764">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-d43cb27 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="d43cb27" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-43073cb" data-id="43073cb" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-6f93a7c elementor-widget elementor-widget-text-editor" data-id="6f93a7c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nell&#8217;attuale serie <strong>sull&#8217;infrastruttura di trading avanzata</strong> abbiamo descritto sia la <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/">classe di posizione</a> che la <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/">classe di portafoglio</a> , due componenti essenziali di un solido backtesting e di un sistema di live trading. In questo articolo estenderemo la discussione alla <strong>classe Portfolio Handler</strong> , che completerà la descrizione del portfolio Order Management System (OMS).</p><p>L&#8217;OMS è la spina dorsale di qualsiasi infrastruttura di trading quantitativo. Deve tenere traccia delle posizioni aperte (e chiuse) negli asset, deve raggruppare insieme quelle posizioni all&#8217;interno di un portafoglio (con liquidità) e deve modificare quel portafoglio con nuovi segnali di trading, sovrapposizioni di gestione del rischio e regole di dimensionamento delle posizioni.</p><p>In questo articolo discuteremo la classe <code>PortfolioHandler</code>. Questa specifica classe ha il compito di gestire un oggetto <code>Portfolio</code>, dicendogli se aprire/chiudere le posizioni in base alle informazioni che riceve dalle classi <code>Strategy</code>, <code>PositionSizer</code>, <code>RiskManager </code>e <code>ExecutionHandler</code>. Questa classe è estremamente importante in quanto lega insieme il resto dei componenti.</p><p>Il seguente codice presentato in questo articolo proviene da <a href="https://github.com/datatrading-info/DataTrader">DataTrader</a>, motore open-source per il backtesting e il live trading. E&#8217; rilasciato con una licenza MIT open source  e l&#8217;ultima versione è sempre disponibile su <a href="https://github.com/datatrading-info/DataTrader">https://github.com/datatrading-info/DataTrader</a>. </p><p>Nel <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/">precedente articolo</a> abbiamo elencato un <strong>promemoria dei componenti</strong> del sistema che descriveva in dettaglio come tutti i componenti di <a href="https://github.com/datatrading-info/DataTrader">DataTrader</a> si collegano insieme. Potete darci un&#8217;occhiata per ricordarsi come interagiscono.</p><p>Rivolgiamo ora la nostra attenzione alla classe <code>PortfolioHandler</code> e vediamo come interagisce con l&#8217;oggetto <code>Portfolio</code>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c4f928a elementor-widget elementor-widget-heading" data-id="c4f928a" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">PortfolioHandler</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-db0c112 elementor-widget elementor-widget-text-editor" data-id="db0c112" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>La prima questione da discutere è il motivo per cui il vecchio approccio della classe  <code>Portfolio </code>implementato in <a href="https://github.com/datatrading-info/DTForex">DTForex</a> è stato ora sostituito con una classe  <code>Portfolio </code>che implementa calcoli complessi per monitorare le <code>Position</code>, e con una classe <code>PortfolioHandler</code> meno complessa.</p><p>Abbiamo adottato questo approccio in modo da vare un oggetto <code>Portfolio</code> più pulito e preveda solo il monitoraggio del saldo/patrimonio e delle posizioni aperte. Lo scopo principale di questo approccio è quello di consentire &#8220;teoricamente&#8221; la creazione di diversi oggetti &#8220;portafoglio&#8221; (ad esempio dal <code>PositionSizer </code>o dal <code>RiskManager</code>), e successivamente creare un insieme di trade necessari per &#8220;trasformare&#8221; il portafoglio corrente nel portafoglio teoricamente desiderato.</p><p>Questo processo è molto più semplice se la classe <code>Portfolio</code> gestisce semplicemente di un raggruppamento di oggetti <code>Position</code> e di un saldo del conto.</p><p>L&#8217;oggetto <code>Portfolio </code>non prevede l&#8217;interazione con gli eventi in coda, il <code>PositionSizer</code>, il <code>RiskManager </code>e il <code>PriceHandler</code>. Queste interazioni vengono gestite dal nuovo oggetto, il <code>PortfolioHandler</code>.</p><p>Abbiamo creato l&#8217;oggetto <code>PortfolioHandler</code> nel file <code>portfolio_handler.py </code>e di seguito si può consultare il listato completo. di seguito.</p><p><em>Nota che uno qualsiasi di questi elenchi è soggetto ad aggiornamenti, poiché il progetto è soggetto a continue modifiche e miglioramenti.</em></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1de35ad elementor-widget elementor-widget-heading" data-id="1de35ad" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">portfolio_handler.py</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-dbb297c elementor-widget elementor-widget-bdt-source-code" data-id="dbb297c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from order import SuggestedOrder
from portfolio import Portfolio


class PortfolioHandler(object):
    def __init__(
        self, initial_cash, events_queue,
        price_handler, position_sizer, risk_manager
    ):
        &quot;&quot;&quot;
        PortfolioHandler è progettato per interagire con un
        backtest o trading dal vivo, in generale una architettura
        basato sugli eventi. Espone due metodi, on_signal e
        on_fill, che gestiscono come gli oggetti SignalEvent
        e FillEvent vengono trattati.

        Ogni PortfolioHandler contiene un oggetto Portfolio,
        che memorizza gli effettivi oggetti Posizione.

        Il PortfolioHandler accetta un handle per un oggetto
        PositionSizer che determina un meccanismo, basato sul
        Portfolio corrente, per dimensionare un nuovo Ordine.

        PortfolioHandler prende anche un handle per il
        RiskManager, che viene utilizzato per modificare qualsiasi
        Ordine in modo da rimanere in linea con i parametri di rischio.
        &quot;&quot;&quot;
        self.initial_cash = initial_cash
        self.events_queue = events_queue
        self.price_handler = price_handler
        self.position_sizer = position_sizer
        self.risk_manager = risk_manager
        self.portfolio = Portfolio(price_handler, initial_cash)

    def _create_order_from_signal(self, signal_event):
        &quot;&quot;&quot;
        Prende un oggetto SignalEvent e lo usa per creare un oggetto
        SuggestedOrder. Questi non sono oggetti OrderEvent,
        poiché devono ancora essere inviati all&#039;oggetto RiskManager.
        In questa fase sono semplicemente &quot;suggerimenti&quot; che il
        RiskManager verificherà, modificherà o eliminerà.
        &quot;&quot;&quot;
        order = SuggestedOrder(
            signal_event.ticker, signal_event.action
        )
        return order

    def _place_orders_onto_queue(self, order_list):
        &quot;&quot;&quot;
        Una volta che il RiskManager ha verificato, modificato o eliminato
        ogni oggetto Ordine, vengono inseriti nella coda degli eventi,
        per essere infine eseguiti dal ExecutionHandler.
        &quot;&quot;&quot;
        for order_event in order_list:
            self.events_queue.put(order_event)

    def _convert_fill_to_portfolio_update(self, fill_event):
        &quot;&quot;&quot;
        Al ricevimento di un FillEvent, PortfolioHandler converte
        l&#039;evento in una transazione che viene archiviata nell&#039;oggetto
        Portafoglio. Ciò garantisce che il broker e il portafoglio locale
        siano &quot;sincronizzati&quot;.

        Inoltre, a fini di backtest, il valore del portafoglio può
        essere stimato in modo realistico, semplicemente modificando
        il modo in cui l&#039;oggetto ExecutionHandler gestisce lo slippage,
        i costi di transazione, la liquidità e l&#039;impatto sul mercato.
        &quot;&quot;&quot;
        action = fill_event.action
        ticker = fill_event.ticker
        quantity = fill_event.quantity
        price = fill_event.price
        commission = fill_event.commission
        # Crea o modifa la posizione dalle informazioni di portafoglio
        self.portfolio.transact_position(
            action, ticker, quantity,
            price, commission
        )

    def on_signal(self, signal_event):
        &quot;&quot;&quot;
        Questo è chiamato dal backtester o dall&#039;architettura del trading live
        per formare gli ordini iniziali dal SignalEvent.

        Questi ordini vengono ridimensionati dall&#039;oggetto PositionSizer e quindi
        inviato al RiskManager per verificarlo, modificarlo o eliminarlo.

        Una volta ricevuti dal RiskManager vengono convertiti in
        oggetti OrderEvent completi e rinviati alla coda degli eventi.
        &quot;&quot;&quot;

        # Crea la lista dell&#039;ordine iniziale da un segnale £vent
        initial_order = self._create_order_from_signal(signal_event)
        # Dimensiona la quantità dell&#039;ordine iniziale
        sized_order = self.position_sizer.size_order(
            self.portfolio, initial_order
        )
        # Affina o elimina l&#039;ordine tramite l&#039;overlay del gestore del rischio
        order_events = self.risk_manager.refine_orders(
            self.portfolio, sized_order
        )
        # Inserisce ordini nella coda degli eventi
        self._place_orders_onto_queue(order_events)

    def on_fill(self, fill_event):
        &quot;&quot;&quot;
        Questo è chiamato dal backtester o dall&#039;architettura del trading live
        per prendere un FillEvent e aggiornare l&#039;oggetto Portfolio con le nuovi
        posizioni o le posizioni modificate.

        In un ambiente di backtest, questi FillEvents verranno simulati
        da un modello che rappresenta l&#039;esecuzione, mentre nel trading dal vivo
        provengono direttamente da un broker (come Interactive Broker).
        &quot;&quot;&quot;
        self._convert_fill_to_portfolio_update(fill_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7f526df elementor-widget elementor-widget-text-editor" data-id="7f526df" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il <code>PortfolioHandler</code> importa l&#8217;oggetto <code>SuggestedOrder</code> e l&#8217;oggetto <code>Portfolio</code>. Il primo è un oggetto differente rispetto a <code>OrderEvent</code> perché non ha attraversato il processo di dimensionamento della posizione o di gestione del rischio. Una volta che un ordine ha superato entrambi i processi, diventa un <code>OrderEvent</code> <span style="color: var( --e-global-color-text ); font-size: 1rem;">completo.</span></p><p>Per inizializzare un <code>PortfolioHandler</code> è necessario un saldo di iniziale e i riferimenti alla coda degli eventi, al gestore del prezzo, al sizer delle posizioni e al gestore del rischio. Infine creiamo l&#8217;oggetto <code>Portfolio</code> associato al suo interno . Si noti che esso stesso richiede l&#8217;accesso al gestore dei prezzi e al saldo iniziale:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3b33876 elementor-widget elementor-widget-bdt-source-code" data-id="3b33876" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from order import SuggestedOrder
from portfolio import Portfolio


class PortfolioHandler(object):
    def __init__(
        self, initial_cash, events_queue,
        price_handler, position_sizer, risk_manager
    ):
        &quot;&quot;&quot;
        PortfolioHandler è progettato per interagire con un
        backtest o trading dal vivo, in generale una architettura
        basato sugli eventi. Espone due metodi, on_signal e
        on_fill, che gestiscono come gli oggetti SignalEvent
        e FillEvent vengono trattati.

        Ogni PortfolioHandler contiene un oggetto Portfolio,
        che memorizza gli effettivi oggetti Posizione.

        Il PortfolioHandler accetta un handle per un oggetto
        PositionSizer che determina un meccanismo, basato sul
        Portfolio corrente, per dimensionare un nuovo Ordine.

        PortfolioHandler prende anche un handle per il
        RiskManager, che viene utilizzato per modificare qualsiasi
        Ordine in modo da rimanere in linea con i parametri di rischio.
        &quot;&quot;&quot;
        self.initial_cash = initial_cash
        self.events_queue = events_queue
        self.price_handler = price_handler
        self.position_sizer = position_sizer
        self.risk_manager = risk_manager
        self.portfolio = Portfolio(price_handler, initial_cash)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-107c4c2 elementor-widget elementor-widget-text-editor" data-id="107c4c2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nel seguente metodo, <code>_create_order_from_signal </code>creiamo semplicemente il <code>SuggestedOrder </code>dal ticker e dal tipo di operazione. In questa fase si prevede di gestire solo gli ordini a mercato. Gli ordini limite e le forme di esecuzione più esotiche sono oggetto di successive implementazioni:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2d4b176 elementor-widget elementor-widget-bdt-source-code" data-id="2d4b176" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _create_order_from_signal(self, signal_event):
        &quot;&quot;&quot;
        Prende un oggetto SignalEvent e lo usa per creare un oggetto
        SuggestedOrder. Questi non sono oggetti OrderEvent,
        poiché devono ancora essere inviati all&#039;oggetto RiskManager.
        In questa fase sono semplicemente &quot;suggerimenti&quot; che il
        RiskManager verificherà, modificherà o eliminerà.
        &quot;&quot;&quot;
        order = SuggestedOrder(
            signal_event.ticker, signal_event.action
        )
        return order</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-16f4195 elementor-widget elementor-widget-text-editor" data-id="16f4195" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><code>_place_orders_onto_queue </code>è un semplice metodo di supporto che accetta un elenco di oggetti <code>OrderEvent</code> e li aggiunge alla coda degli eventi:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4281066 elementor-widget elementor-widget-bdt-source-code" data-id="4281066" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _place_orders_onto_queue(self, order_list):
        &quot;&quot;&quot;
        Una volta che il RiskManager ha verificato, modificato o eliminato
        ogni oggetto Ordine, vengono inseriti nella coda degli eventi,
        per essere infine eseguiti dal ExecutionHandler.
        &quot;&quot;&quot;
        for order_event in order_list:
            self.events_queue.put(order_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2f8714f elementor-widget elementor-widget-text-editor" data-id="2f8714f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il seguente metodo </span><code>_convert_fill_to_portfolio_update</code><span>, accetta un </span><code>FillEvent</code><span> e quindi aggiorna l&#8217;oggetto  </span><code>Portfolio</code><span> interno per tenere conto della transazione di riempimento. Come si può vedere, mostra che il </span><code>PortfolioHandler</code> <span>non esegue calcoli matematici, ma delega i calcoli alla classe </span><code>Portfolio</code><span>:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c811764 elementor-widget elementor-widget-bdt-source-code" data-id="c811764" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _convert_fill_to_portfolio_update(self, fill_event):
        &quot;&quot;&quot;
        Al ricevimento di un FillEvent, PortfolioHandler converte
        l&#039;evento in una transazione che viene archiviata nell&#039;oggetto
        Portafoglio. Ciò garantisce che il broker e il portafoglio locale
        siano &quot;sincronizzati&quot;.

        Inoltre, a fini di backtest, il valore del portafoglio può
        essere stimato in modo realistico, semplicemente modificando
        il modo in cui l&#039;oggetto ExecutionHandler gestisce lo slippage,
        i costi di transazione, la liquidità e l&#039;impatto sul mercato.
        &quot;&quot;&quot;
        action = fill_event.action
        ticker = fill_event.ticker
        quantity = fill_event.quantity
        price = fill_event.price
        commission = fill_event.commission
        # Crea o modifa la posizione dalle informazioni di portafoglio
        self.portfolio.transact_position(
            action, ticker, quantity,
            price, commission
        )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9859437 elementor-widget elementor-widget-text-editor" data-id="9859437" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo <code>on_signal</code> lega insieme alcuni dei metodi precedenti. Crea l&#8217;ordine suggerito<span style="color: var( --e-global-color-text ); font-size: 1rem;"> </span><span style="color: var( --e-global-color-text ); font-size: 1rem;">iniziale</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">, quindi lo invia all&#8217;oggetto </span><code>PositionSizer</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> (insieme al portfolio) per essere dimensionato. Una volta restituito l&#8217;ordine dimensionato, si invia al </span><code>RiskManager</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> per gestire qualsiasi rischio associato agli impatti del nuovo ordine sul portafoglio corrente.</span></p><p>Il gestore del rischio restituisce quindi un <em>elenco</em> di ordini. Perché una lista? Ebbene, bisogna considerare il fatto che un trade generato può indurre il gestore del rischio a creare un ordine di copertura in un altro titolo. Quindi è necessario eventualmente restituire più di un ordine.</p><p>Una volta creato l&#8217;elenco degli ordini, vengono tutti inseriti nella coda degli eventi:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5f98c04 elementor-widget elementor-widget-bdt-source-code" data-id="5f98c04" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def on_signal(self, signal_event):
        &quot;&quot;&quot;
        Questo è chiamato dal backtester o dall&#039;architettura del trading live
        per formare gli ordini iniziali dal SignalEvent.

        Questi ordini vengono ridimensionati dall&#039;oggetto PositionSizer e quindi
        inviato al RiskManager per verificarlo, modificarlo o eliminarlo.

        Una volta ricevuti dal RiskManager vengono convertiti in
        oggetti OrderEvent completi e rinviati alla coda degli eventi.
        &quot;&quot;&quot;

        # Crea la lista dell&#039;ordine iniziale da un segnale £vent
        initial_order = self._create_order_from_signal(signal_event)
        # Dimensiona la quantità dell&#039;ordine iniziale
        sized_order = self.position_sizer.size_order(
            self.portfolio, initial_order
        )
        # Affina o elimina l&#039;ordine tramite l&#039;overlay del gestore del rischio
        order_events = self.risk_manager.refine_orders(
            self.portfolio, sized_order
        )
        # Inserisce ordini nella coda degli eventi
        self._place_orders_onto_queue(order_events)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-6845b15 elementor-widget elementor-widget-text-editor" data-id="6845b15" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il metodo finale del  </span><code>PortfolioHandler</code><span> è il </span><code>on_fill</code><span>. Questo richiama semplicemente il metodo precedente </span><code>_convert_fill_to_portfolio_update</code><span>. Questi due metodi sono stati separati, poiché nelle versioni successive di </span><a href="https://github.com/datatrading-info/DataTrader"><span>DataTrader</span></a><span> potrebbe essere necessaria una logica più sofisticata. Non desideriamo modificare l&#8217;interfaccia </span><code>on_fill</code><span> del PortfolioHandler a meno che non sia assolutamente necessario. Questo aiuta a mantenere </span><a href="https://en.wikipedia.org/wiki/Backward_compatibility"><span>la compatibilità con le versioni precedenti</span></a><span> :</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a8a71ef elementor-widget elementor-widget-bdt-source-code" data-id="a8a71ef" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def on_fill(self, fill_event):
        &quot;&quot;&quot;
        Questo è chiamato dal backtester o dall&#039;architettura del trading live
        per prendere un FillEvent e aggiornare l&#039;oggetto Portfolio con le nuovi
        posizioni o le posizioni modificate.

        In un ambiente di backtest, questi FillEvents verranno simulati
        da un modello che rappresenta l&#039;esecuzione, mentre nel trading dal vivo
        provengono direttamente da un broker (come Interactive Broker).
        &quot;&quot;&quot;
        self._convert_fill_to_portfolio_update(fill_event)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-494d79a elementor-widget elementor-widget-text-editor" data-id="494d79a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questo completa la descrizione della classe <code>PortfolioHandler</code>. Per completezza puoi trovare il codice completo per la classe <code>PortfolioHandler</code> su Github.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e3d4fd7 elementor-widget elementor-widget-heading" data-id="e3d4fd7" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">portfolio_handler_test.py</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-43554dd elementor-widget elementor-widget-text-editor" data-id="43554dd" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ora che abbiamo creato il <code>PortfolioHandler</code>, dobbiamo testarlo. Per fortuna, la maggior parte dei test matematici si verifica nelle classi <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/">Position</a> e <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/">Portfolio</a>. Tuttavia, è ancora necessario verificare che il <code>PortfolioHandler</code> &#8220;faccia la cosa giusta&#8221; quando riceve segnali generati dalla strategia e i riempimenti generati dall&#8217;esecuzione.</p><p>Sebbene i seguenti test possano sembrare &#8220;banali&#8221;, posso assicurare che <span style="color: var( --e-global-color-text ); font-size: 1rem;">è assolutamente vitale assicurarsi di avere un sistema funzionante man mano che viene aggiunta più complessità, </span><span style="color: var( --e-global-color-text ); font-size: 1rem;">anche se può essere abbastanza noioso scrivere codice di unit test. Uno degli aspetti più frustranti dello sviluppo del software è </span><em style="color: var( --e-global-color-text ); font-size: 1rem;">non</em><span style="color: var( --e-global-color-text ); font-size: 1rem;"> fare gli unit test per così &#8220;ottenere rapidamente una risposta&#8221; e poi rendersi conto di avere un bug </span><em style="color: var( --e-global-color-text ); font-size: 1rem;">e</em><span style="color: var( --e-global-color-text ); font-size: 1rem;"> non avere idea di dove si trovi in una vasta raccolta di moduli!</span></p><p>Eseguendo gli unit test <em>mentre scriviamo i singoli moduli</em> si evita questo problema <span style="color: var( --e-global-color-text ); font-size: 1rem;">il più possibile</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">. Se viene scoperto un bug, di solito è molto più semplice rintracciarlo. Il tempo speso per testare le unità </span><em style="color: var( --e-global-color-text ); font-size: 1rem;">non</em><span style="color: var( --e-global-color-text ); font-size: 1rem;"> è </span><em style="color: var( --e-global-color-text ); font-size: 1rem;">mai sprecato</em><span style="color: var( --e-global-color-text ); font-size: 1rem;">!</span></p><p>Di seguito è riportato un listato completo di <code>portfolio_handler_test.py</code>. Dopo il listato si analizza i singoli oggetti e metodi, come in precedenza:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2da9195 elementor-widget elementor-widget-bdt-source-code" data-id="2da9195" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import datetime
from decimal import Decimal
import queue
import unittest

from event import FillEvent, OrderEvent, SignalEvent
from portfolio import PortfolioHandler


class PriceHandlerMock(object):
    def __init__(self):
        pass

    def get_best_bid_ask(self, ticker):
        prices = {
            &quot;MSFT&quot;: (Decimal(&quot;50.28&quot;), Decimal(&quot;50.31&quot;)),
            &quot;GOOG&quot;: (Decimal(&quot;705.46&quot;), Decimal(&quot;705.46&quot;)),
            &quot;AMZN&quot;: (Decimal(&quot;564.14&quot;), Decimal(&quot;565.14&quot;)),
        }
        return prices[ticker]


class PositionSizerMock(object):
    def __init__(self):
        pass

    def size_order(self, portfolio, initial_order):
        &quot;&quot;&quot;
        Questo oggetto PositionSizerMock modifica semplicemente
        la quantità per essere 100 per qualsiasi azione negoziata.
        &quot;&quot;&quot;
        initial_order.quantity = 100
        return initial_order


class RiskManagerMock(object):
    def __init__(self):
        pass

    def refine_orders(self, portfolio, sized_order):
        &quot;&quot;&quot;
        Questo oggetto RiskManagerMock consente semplicemente
        la verifica dell&#039;ordine, crea il corrispondente
        OrderEvent e lo aggiunge ad un elenco.
        &quot;&quot;&quot;
        order_event = OrderEvent(
            sized_order.ticker,
            sized_order.action,
            sized_order.quantity
        )
        return [order_event]


class TestSimpleSignalOrderFillCycleForPortfolioHandler(unittest.TestCase):
    &quot;&quot;&quot;
    Verifica un semplice ciclo di segnale, ordine e riempimento per il
    PortfolioHandler. Questo è, in effetti, un controllo di integrità.
    &quot;&quot;&quot;
    def setUp(self):
        &quot;&quot;&quot;
        Impostare l&#039;oggetto PortfolioHandler fornendolo
        $ 500.000,00 USD di capitale iniziale.
        &quot;&quot;&quot;
        initial_cash = Decimal(&quot;500000.00&quot;)
        events_queue = queue.Queue()
        price_handler = PriceHandlerMock()
        position_sizer = PositionSizerMock()
        risk_manager = RiskManagerMock()
        # Create the PortfolioHandler object from the rest
        self.portfolio_handler = PortfolioHandler(
            initial_cash, events_queue, price_handler,
            position_sizer, risk_manager
        )

    def test_create_order_from_signal_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_create_order_from_signal&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        signal_event = SignalEvent(&quot;MSFT&quot;, &quot;BOT&quot;)
        order = self.portfolio_handler._create_order_from_signal(signal_event)
        self.assertEqual(order.ticker, &quot;MSFT&quot;)
        self.assertEqual(order.action, &quot;BOT&quot;)
        self.assertEqual(order.quantity, 0)

    def test_place_orders_onto_queue_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_place_orders_onto_queue&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        order = OrderEvent(&quot;MSFT&quot;, &quot;BOT&quot;, 100)
        order_list = [order]
        self.portfolio_handler._place_orders_onto_queue(order_list)
        ret_order = self.portfolio_handler.events_queue.get()
        self.assertEqual(ret_order.ticker, &quot;MSFT&quot;)
        self.assertEqual(ret_order.action, &quot;BOT&quot;)
        self.assertEqual(ret_order.quantity, 100)

    def test_convert_fill_to_portfolio_update_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_convert_fill_to_portfolio_update&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        fill_event_buy = FillEvent(
            datetime.datetime.utcnow(), &quot;MSFT&quot;, &quot;BOT&quot;,
            100, &quot;ARCA&quot;, Decimal(&quot;50.25&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio_handler._convert_fill_to_portfolio_update(fill_event_buy)

        # Controlla i valori di Portfolio all&#039;interno di PortfolioHandler
        port = self.portfolio_handler.portfolio
        self.assertEqual(port.cur_cash, Decimal(&quot;494974.00&quot;))

    def test_on_signal_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;on_signal&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        signal_event = SignalEvent(&quot;MSFT&quot;, &quot;BOT&quot;)
        self.portfolio_handler.on_signal(signal_event)
        ret_order = self.portfolio_handler.events_queue.get()
        self.assertEqual(ret_order.ticker, &quot;MSFT&quot;)
        self.assertEqual(ret_order.action, &quot;BOT&quot;)
        self.assertEqual(ret_order.quantity, 100)


if __name__ == &quot;__main__&quot;:
    unittest.main()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-d914c2a elementor-widget elementor-widget-text-editor" data-id="d914c2a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>La prima operazione è importare i moduli corretti. Usiamo il modulo <a href="https://docs.python.org/3.5/library/decimal.html">Decimal</a>, come negli articoli precedenti, così come il modulo <a href="https://docs.python.org/3/library/unittest.html">unittest</a> . Abbiamo anche bisogno di importare vari oggetti <code>Event</code> utilizzati da <code>PortfolioHandler</code> per comunicare. Infine importiamo lo stesso <code>PortfolioHandler</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-aaeca6a elementor-widget elementor-widget-bdt-source-code" data-id="aaeca6a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import datetime
from decimal import Decimal
import queue
import unittest

from event import FillEvent, OrderEvent, SignalEvent
from portfolio import PortfolioHandler</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c9e3bcd elementor-widget elementor-widget-text-editor" data-id="c9e3bcd" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Dobbiamo creare tre </span><a href="https://en.wikipedia.org/wiki/Mock_object"><span>oggetti &#8220;fittizi&#8221;</span></a><span> (vedere l&#8217; </span><a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/"><span>articolo precedente</span></a><span> per una descrizione degli oggetti fittizi), uno per ciascuno </span><code>PriceHandler</code><span>, </span><code>PositionSizer</code> <span>e </span><code>RiskManager</code><span>. Il primo, </span><code>PriceHandlerMock</code> <span>ci fornisce i prezzi denaro / lettera statici per tre azioni: MSFT, GOOG e AMZN. Essenzialmente vogliamo simulare il metodo </span><code>get_best_bid_ask</code><span> per i nostri unit test ripetibili:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a223fad elementor-widget elementor-widget-bdt-source-code" data-id="a223fad" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class PriceHandlerMock(object):
    def __init__(self):
        pass

    def get_best_bid_ask(self, ticker):
        prices = {
            &quot;MSFT&quot;: (Decimal(&quot;50.28&quot;), Decimal(&quot;50.31&quot;)),
            &quot;GOOG&quot;: (Decimal(&quot;705.46&quot;), Decimal(&quot;705.46&quot;)),
            &quot;AMZN&quot;: (Decimal(&quot;564.14&quot;), Decimal(&quot;565.14&quot;)),
        }
        return prices[ticker]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4763b88 elementor-widget elementor-widget-text-editor" data-id="4763b88" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il secondo oggetto fittizio è il <code>PositionSizerMock</code>. Imposta semplicemente la quantità dell&#8217;ordine pari a 100, che è una scelta arbitraria, ma è necessario fissarla per i test unitari. Simula il metodo <code>size_order</code> che si troverà nella &#8220;vera&#8221; classe <code>PositionSizer</code>, quando sarà completa:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b095f45 elementor-widget elementor-widget-bdt-source-code" data-id="b095f45" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class PositionSizerMock(object):
    def __init__(self):
        pass

    def size_order(self, portfolio, initial_order):
        &quot;&quot;&quot;
        Questo oggetto PositionSizerMock modifica semplicemente
        la quantità per essere 100 per qualsiasi azione negoziata.
        &quot;&quot;&quot;
        initial_order.quantity = 100
        return initial_order</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-34453fe elementor-widget elementor-widget-text-editor" data-id="34453fe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>L&#8217;ultimo oggetto fittizio è il </span><code>RiskManagerMock</code><span>. Non fa altro che creare un oggetto </span><code>OrderEvent</code><span> e inserirlo in un elenco. Fondamentalmente, non esiste una vera gestione del rischio! Anche se questo può sembrare artificioso, ci consente di eseguire un &#8220;controllo di integrità&#8221; per verificare che </span><code>PortfolioHandler</code> <span>può semplicemente effettuare le transazioni più elementari di ordini, esecuzioni e segnali. Man mano che creiamo oggetti </span><code>RiskManager</code><span> più sofisticati ,  crescerà la lista di unit test, al fine di testare la nuova funzionalità. In questo modo ci assicuriamo continuamente che la base di codice funzioni come previsto:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d9440cf elementor-widget elementor-widget-bdt-source-code" data-id="d9440cf" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class RiskManagerMock(object):
    def __init__(self):
        pass

    def refine_orders(self, portfolio, sized_order):
        &quot;&quot;&quot;
        Questo oggetto RiskManagerMock consente semplicemente
        la verifica dell&#039;ordine, crea il corrispondente
        OrderEvent e lo aggiunge ad un elenco.
        &quot;&quot;&quot;
        order_event = OrderEvent(
            sized_order.ticker,
            sized_order.action,
            sized_order.quantity
        )
        return [order_event]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-a3c666f elementor-widget elementor-widget-text-editor" data-id="a3c666f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ora che abbiamo definito i tre oggetti fittizi, possiamo creare gli specifici unit test. Viene chiamata la classe che li esegue <code>TestSimpleSignalOrderFillCycleForPortfolioHandler</code>. Sebbene dettagliata, ci dice esattamente per quale test è stata progettata, vale a dire testare un semplice ciclo di segnale-ordine-riempimento all&#8217;interno del gestore del portafoglio.</p><p>Per fare ciò, creiamo un saldo di cassa iniziale di 500.000 USD, una coda di eventi e i tre oggetti fittizi sopra menzionati. Infine, creiamo lo stesso <code>PortfolioHandler</code> e lo colleghiamo alla classe di test:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d6da7b0 elementor-widget elementor-widget-bdt-source-code" data-id="d6da7b0" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class TestSimpleSignalOrderFillCycleForPortfolioHandler(unittest.TestCase):
    &quot;&quot;&quot;
    Verifica un semplice ciclo di segnale, ordine e riempimento per il
    PortfolioHandler. Questo è, in effetti, un controllo di integrità.
    &quot;&quot;&quot;
    def setUp(self):
        &quot;&quot;&quot;
        Impostare l&#039;oggetto PortfolioHandler fornendolo
        $ 500.000,00 USD di capitale iniziale.
        &quot;&quot;&quot;
        initial_cash = Decimal(&quot;500000.00&quot;)
        events_queue = queue.Queue()
        price_handler = PriceHandlerMock()
        position_sizer = PositionSizerMock()
        risk_manager = RiskManagerMock()
        # Create the PortfolioHandler object from the rest
        self.portfolio_handler = PortfolioHandler(
            initial_cash, events_queue, price_handler,
            position_sizer, risk_manager
        )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-066c77e elementor-widget elementor-widget-text-editor" data-id="066c77e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il primo test genera semplicemente un falso <code>SignalEvent </code>per acquistare Microsoft. Verifichiamo quindi che sia stato generato l&#8217;ordine corretto. Notare che una quantità non è stata impostata in questa fase (è zero). Controlliamo tutte le proprietà per assicurarci che l&#8217;ordine sia stato creato correttamente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-417f92a elementor-widget elementor-widget-bdt-source-code" data-id="417f92a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_create_order_from_signal_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_create_order_from_signal&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        signal_event = SignalEvent(&quot;MSFT&quot;, &quot;BOT&quot;)
        order = self.portfolio_handler._create_order_from_signal(signal_event)
        self.assertEqual(order.ticker, &quot;MSFT&quot;)
        self.assertEqual(order.action, &quot;BOT&quot;)
        self.assertEqual(order.quantity, 0)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-fd75c39 elementor-widget elementor-widget-text-editor" data-id="fd75c39" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il prossimo test consiste nel verificare se gli ordini sono stati inseriti correttamente nella coda (e recuperati). Si noti che dobbiamo racchiudere il </span><code>OrderEvent</code> <span>in un elenco, in quanto </span><code>RiskManager</code> <span>produce un elenco di ordini, a causa della suddetta necessità di coprire eventualmente o aggiungere ulteriori ordini oltre a quelli suggeriti dalla </span><code>Strategy</code><span>. Infine, affermiamo che l&#8217;ordine restituito (che viene prelevato dalla coda) contiene le informazioni appropriate:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-35e2be6 elementor-widget elementor-widget-bdt-source-code" data-id="35e2be6" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_place_orders_onto_queue_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_place_orders_onto_queue&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        order = OrderEvent(&quot;MSFT&quot;, &quot;BOT&quot;, 100)
        order_list = [order]
        self.portfolio_handler._place_orders_onto_queue(order_list)
        ret_order = self.portfolio_handler.events_queue.get()
        self.assertEqual(ret_order.ticker, &quot;MSFT&quot;)
        self.assertEqual(ret_order.action, &quot;BOT&quot;)
        self.assertEqual(ret_order.quantity, 100)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8a9b368 elementor-widget elementor-widget-text-editor" data-id="8a9b368" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il seguente test crea un <code>FillEvent</code>, come se fosse stato appena ricevuto da un oggetto <code>ExecutionHandler</code>. Al gestore del portafoglio viene quindi chiesto di convertire il riempimento in un effettivo aggiornamento del portafoglio (ovvero registrare la transazione all&#8217;interno dell&#8217;oggetto <code>Portfolio</code>).</p><p>Il test consiste nel verificare che il saldo corrente all&#8217;interno del <code>Portfolio</code> sia effettivamente corretto:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7ff0066 elementor-widget elementor-widget-bdt-source-code" data-id="7ff0066" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_convert_fill_to_portfolio_update_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;_convert_fill_to_portfolio_update&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        fill_event_buy = FillEvent(
            datetime.datetime.utcnow(), &quot;MSFT&quot;, &quot;BOT&quot;,
            100, &quot;ARCA&quot;, Decimal(&quot;50.25&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio_handler._convert_fill_to_portfolio_update(fill_event_buy)

        # Controlla i valori di Portfolio all&#039;interno di PortfolioHandler
        port = self.portfolio_handler.portfolio
        self.assertEqual(port.cur_cash, Decimal(&quot;494974.00&quot;))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-76803f9 elementor-widget elementor-widget-text-editor" data-id="76803f9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il test finale verifica semplicemente il metodo <code>on_signal</code> creando un oggetto <code>SignalEvent</code>, posizionandolo in coda e quindi recuperandolo per verificare che i valori dell&#8217;ordine siano quelli previsti. Questo verifica la gestione di base &#8220;end to end&#8221; degli oggetti <code>PositionSizer </code>e <code>RiskManager</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-37766e6 elementor-widget elementor-widget-bdt-source-code" data-id="37766e6" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_on_signal_basic_check(self):
        &quot;&quot;&quot;
        Verifica il metodo &quot;on_signal&quot;
        per il controllo di integrità.
        &quot;&quot;&quot;
        signal_event = SignalEvent(&quot;MSFT&quot;, &quot;BOT&quot;)
        self.portfolio_handler.on_signal(signal_event)
        ret_order = self.portfolio_handler.events_queue.get()
        self.assertEqual(ret_order.ticker, &quot;MSFT&quot;)
        self.assertEqual(ret_order.action, &quot;BOT&quot;)
        self.assertEqual(ret_order.quantity, 100)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-007ae68 elementor-widget elementor-widget-text-editor" data-id="007ae68" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Possiamo vedere chiaramente che ci sono molti più test da fare qui. Abbiamo solo scalfito la superficie con il tipo di situazioni che possono verificarsi. Tuttavia, è sempre utile disporre di una serie di controlli di integrità. Il framework di unit test è altamente estensibile e quando ci imbattiamo in nuove situazioni / bug, possiamo semplicemente scrivere nuovi test e correggere il problema.</span></p><p><span>Per completezza puoi trovare il codice completo per il test </span><code>PortfolioHandler</code> <span>su Github.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8e00b30 elementor-widget elementor-widget-heading" data-id="8e00b30" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Prossimi Passi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-0f983af elementor-widget elementor-widget-text-editor" data-id="0f983af" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Abbiamo ora coperto tre degli oggetti principali per il sistema di gestione degli ordini, vale a dire il </span><code>Position</code><span>, il </span><code>Portfolio</code> <span>e il </span><code>PortfolioHandler</code><span>. Questi sono gli aspetti matematici &#8220;centrali&#8221; del codice e come tali dobbiamo essere sicuri che funzionino come previsto.</span></p><p><span>Anche se discutere di questi oggetti non è così eccitante come costruire un oggetto </span><code>Strategy</code><span>, o anche un </span><code>RiskManager</code><span>, è fondamentale che funzionino, altrimenti il ​​resto dell&#8217;infrastruttura di backtesting e live trading sarà, nella migliore delle ipotesi, inutile e, nel peggiore dei casi, altamente non redditizia!</span></p><p><span>Abbiamo molti altri componenti da descrivere oltre a quelli menzionati sopra, tra cui il </span><code>PriceHandler</code><span>, la classe </span><code>Backtest</code><span>, i vari </span><code>ExecutionHandler</code> <span>che potrebbero collegarsi a </span><a href="https://www.interactivebrokers.co.uk"><span>Interactive Brokers</span></a><span> o </span><a href="http://www.oanda.com/"><span>OANDA</span></a><span> , così come l&#8217;implementazione di un oggetto </span><code>Strategy</code><span> non banale .</span></p><p><span>Nel prossimo articolo vedremo una o più di queste classi.</span></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-il-gestore-del-portfolio/">DataTrader – Trading Algoritmico Avanzato: il Gestore del Portfolio</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DataTrader – Trading Algoritmico Avanzato: la Classe Portfolio</title>
		<link>https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Tue, 12 Jun 2018 10:40:11 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial DataTrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2748</guid>

					<description><![CDATA[<p>Nell&#8217;articolo&#160;precedente&#160;nella serie&#160;Trading Algoritmico Avanzato&#160;abbiamo descritto e presentato il codice e&#160;gli unit test iniziali per la classe&#160;Position&#160;che memorizza le informazioni sulla posizione di un trade.&#160;In questo articolo consideriamo la classe&#160;Portfolio, utilizzata per memorizzare un elenco di classi&#160;Position, nonché un saldo del conto. Nell&#8217;ultimo mese abbiamo fatto molti progressi sul progetto&#160;DataTrader&#160;, il&#160;motore open source per il backtesting &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/"> <span class="screen-reader-text">DataTrader – Trading Algoritmico Avanzato: la Classe Portfolio</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/">DataTrader – Trading Algoritmico Avanzato: la Classe Portfolio</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2748" class="elementor elementor-2748">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-cdd8be9 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="cdd8be9" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-f837cf4" data-id="f837cf4" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-4747105 elementor-widget elementor-widget-text-editor" data-id="4747105" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nell&#8217;articolo <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/">precedente</a> nella serie <strong>Trading Algoritmico Avanzato</strong> abbiamo descritto e presentato il codice e <span style="color: var( --e-global-color-text ); font-size: 1rem;">gli unit test iniziali per la classe </span><code>Position</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> che memorizza le informazioni sulla posizione di un trade. In questo articolo consideriamo la classe </span><code>Portfolio</code><span style="color: var( --e-global-color-text ); font-size: 1rem;">, utilizzata per memorizzare un elenco di classi </span><code>Position</code><span style="color: var( --e-global-color-text ); font-size: 1rem;">, nonché un saldo del conto.</span></p><p>Nell&#8217;ultimo mese abbiamo fatto molti progressi sul progetto <a href="https://github.com/datatrading-info/DataTrader">DataTrader</a> , il <a href="https://github.com/datatrading-info/DataTrader">motore</a> open source per il backtesting e il live-trading che l&#8217;oggetto di questi articoli. In effetti, abbiamo finalizzato l&#8217;intera &#8220;prima bozza&#8221; end-to-end del codice, che fa uso di una semplicistica strategia di test (e altamente non redditizia!), usata solo per garantire che il codice funzioni come dovrebbe. Tuttavia, è doveroso scrivere questi articoli in sequenza, descrivendo le funzionalità dei singoli moduli.</p><p>In questo modo spero che sarà più facile per molti di voi contribuire al progetto aggiungendo vari nuovi componenti, come gestori del rischio o sizer di portafoglio che altri nella comunità di DataTrading possono utilizzare.</p><p>In questa fase c&#8217;è poca o nessuna documentazione oltre a questi articoli, ma una parte importante per rendere DataTrader una valida libreria di backtest è prevede una documentazione  estremamente dettagliata. Una volta che il codice sarà più consolidato, inizieremo a produrre una documentazione approfondita e tutorial che dovrebbero aiutare a eseguire il backtest in modo rapido e semplice, indipendentemente dalla tua scelta del sistema operativo o dalla frequenza di trading.</p><p>Per ribadire, il progetto può sempre essere trovato su  <a href="https://github.com/datatrading-info/DataTrader">https://github.com/datatrading-info/DataTrader</a> con una licenza MIT open source.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-80ab2c6 elementor-widget elementor-widget-heading" data-id="80ab2c6" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Promemoria per la progettazione dei componenti</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-f5421af elementor-widget elementor-widget-text-editor" data-id="f5421af" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nell&#8217;articolo <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/">precedente</a> abbiamo introdotto brevemente i moduli che compongono DataTrader. Ora vediamo di ampliare questo elenco per includere il set &#8220;completo&#8221; delle componenti necessarie per un backtest.</p><p>Molti di questi moduli risulteranno familiari agli utenti di <a href="https://github.com/datatrading-info/DTForex">DTForex</a> e al precedente backtester basato su eventi utilizzato (<a href="https://github.com/datatrading-info/DataBacktest">DataBacktest</a>). La principale differenza è che queste classi sono state oggetto di unit test e comprendo molto più funzionalità rispetto alle versioni precedenti.</p><p>Il design di DataTrader è il seguente:</p><ul><li><strong>Position </strong>&#8211; la classe <code>Position</code> incapsula tutti i dati associati a una posizione aperta in un asset. In altre parole, tiene traccia dei profitti e delle perdite (PnL) realizzati e non realizzati calcolando la media delle &#8220;gambe&#8221; multiple della transazione, inclusi i costi di transazione.</li><li><strong>Portfolio</strong> &#8211; La classe <code>Portfolio</code> che racchiude un elenco di <code>Position</code>, nonché un saldo del conto, equity e PnL.</li><li><strong>PositionSizer</strong> &#8211; La classe <code>PositionSizer</code> fornisce a<code>PortfolioHandler</code>(vedi seguito) una guida su come dimensionare le posizioni una volta ricevuto un segnale da una strategia. Ad esempio, <code>PositionSizer</code> potrebbe incorporare un approccio basato sul <a href="https://datatrading.info/money-management-tramite-il-criterio-di-kelly/">criterio di Kelly</a> .</li><li><strong>RiskManager</strong> &#8211; La classe  <code>RiskManager</code> è utilizzata da <code>PortfolioHandler</code> per verificare, modificare o porre il veto a qualsiasi ipotetico trade che passa dal <code>PositionSizer</code>, in base alla corrente composizione del portafoglio e a considerazioni sul rischio esterno (come la correlazione agli indici o la volatilità).</li><li><strong>PortfolioHandler</strong> &#8211; La classe <code>PortfolioHandler</code> è responsabile della gestione del <code>Portfolio</code>, dell&#8217;interazione con <code>RiskManager</code> e <code>PositionSizer</code> nonché dell&#8217;invio degli ordini che devono essere eseguiti da un <code>ExecutionHandler</code>.</li><li><strong>Event</strong> &#8211; La classe <code>Event</code> e la sua sottoclasse ereditata vengono utilizzate per trasmettere i messaggi Event a ciascun componente del sistema. Vengono sempre inviati a una <a href="https://docs.python.org/3.5/library/queue.html">coda</a> di eventi Python per essere letti da questi componenti. Le sottoclassi di Event includono <code>TickEvent</code>, <code>OrderEvent</code>, <code>SignalEvent</code> e <code>FillEvent</code>.</li><li><strong>Strategy</strong> &#8211; La classe <code>Strategy</code> gestisce la logica di generazione dei segnali di trading in base alle informazioni sui prezzi. Invia questi segnali al <code>PortfolioHandler</code>.</li><li><strong>ExecutionHandler</strong> : La classe <code>ExecutionHandler</code> legge gli <code>OrderEvent</code> e produce <code>FillEvent</code>, in base a uno scenario di riempimento simulato o alle informazioni di riempimento effettive ricevute da un broker, come Interactive Brokers.</li><li><strong>PriceHandler</strong> &#8211; Questa classe è progettata per essere eredita da sottoclassi che consentono la connessione verso più origini dati come, ad esempio, CSV, HDF5, RDBMS (MySQL, SQLServer, PostgreSQL), MongoDB o un&#8217;API di streaming live di un broker.</li><li><strong>Backtest</strong> : La classe <code>Backtest</code> lega insieme tutti i componenti precedenti per produrre un backtest simulato. Viene &#8220;sostituito&#8221; con una classe per un motore di live trading (da sviluppare), insieme a un <code>PriceHandler </code>e <code>ExecutionHandler</code>, una volta che si vuole passare al live trading.</li></ul><p>Cosa manca a questo elenco? Probabilmente il modulo mancante più importante è un meccanismo per calcolare le statistiche della strategia di trading e visualizzare i risultati. Ciò include metriche di performance come il Sharpe Ratio e il Maximum Drawdown, nonché una curva di equity, un profilo dei rendimenti e una curva di drawdown.</p><p>Piuttosto che <a href="https://it.wikipedia.org/wiki/Accoppiamento_(informatica)">accoppiare fortemente</a> i risultati alla classe <code>PortfolioHandler</code>, come nei precedenti DTForex e DataBacktest, generiamo una classe <code>Result</code> o <code>Statistic</code> che calcola e memorizza le metriche delle performance, in base ai risultati di un backtest . Possiamo quindi utilizzare queste classi per produrre ulteriori funzionalità &#8220;client&#8221;, come un&#8217;interfaccia web o uno strumento GUI, per visualizzare i risultati di un backtest.</p><p>Inoltre, nell&#8217;elenco precedente non si fa menzione di robustezza, memorizzazione o monitoraggio. Questi sono componenti cruciali in un motore di backtesting e live trading da utilizzare in produzione e verranno aggiunti man mano che il progetto si sviluppa. Questi componenti probabilmente faranno uso di una qualche forma di infrastruttura server / cloud, come <a href="http://aws.amazon.com/">Amazon Web Services</a> (o altri fornitori di servizi cloud).</p><p>Rivolgiamo ora la nostra attenzione alla classe <code>Portfolio</code>. Negli articoli successivi considereremo il <code>PortfolioHandler</code> e come si interagisce con il <code>PositionSizer</code> e <code>RiskManager</code>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e351b08 elementor-widget elementor-widget-heading" data-id="e351b08" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Portfolio</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-4bdd0a0 elementor-widget elementor-widget-text-editor" data-id="4bdd0a0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Da sottolineare di nuovo che in questo progetto la classe <code>Portfolio</code> implementata per DataTrader è molto diversa da quella utilizzata in DTForex o DataBacktest. In DataTrader abbiamo diviso il portfolio in due classi, una chiamata <code>Portfolio</code>e l&#8217;altra chiamata <code>PortfolioHandler</code>.</p><p>Perchè adottiamo questo approccio? In primo luogo, si vuole creare una classe <code>Portfolio</code> snella che si occupi solamente di memorizzare il valore in contanti del portafoglio e un elenco di oggetti <code>Position</code>. L&#8217;unico metodo che viene chiamato <a href="https://en.wikipedia.org/wiki/C%2B%2B_classes#Declaration_and_usage">pubblicamente</a> (per prendere in prestito un termine C ++!) è  <code>transact_position</code>, che prevede semplicemente di aggiornare la posizione di <code>Portfolio</code> in una particolare equity. Gestisce tutti i necessari calcoli di profitti e perdite (PnL), attualizzando sia il <em>PnL realizzato</em> che il <em>PnL non realizzato</em>.</p><p>Questo significa che la classe <code>PortfolioHandler</code> può concentrarsi su altre attività, come l&#8217;interazione con le classi <code>RiskManager</code> e <code>PositionSizer</code>, lasciando tutti i necessari calcoli finanziari a <code>Portfolio</code>. Questo approccio permette anche di testare in modo più semplice ogni classe individualmente, poiché una è focalizzata nel calcolo finanziario, mentre l&#8217;altra viene utilizzata maggiormente per interagire con gli altri componenti.</p><p>Descriveremo i listati di codice per entrambi i file <code>position.py</code> e <code>position_test.py</code>  e quindi illustreremo il funzionamento di ciascuno di essi.</p><p><em>Da notare che questi codici sono soggetti a modifiche, poiché si apportano continuamente modifiche per migliorare questo progetto. Infine speriamo che altri collaboreranno fornendo <a href="https://en.wikipedia.org/wiki/Pull_request">richieste pull</a> al codebase.</em></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1ea8965 elementor-widget elementor-widget-heading" data-id="1ea8965" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">portfolio.py</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-4fb8de8 elementor-widget elementor-widget-bdt-source-code" data-id="4fb8de8" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
from position import Position


class Portfolio(object):
    def __init__(self, price_handler, cash):
        &quot;&quot;&quot;
        Alla creazione, l&#039;oggetto Portfolio non contiene posizioni
        e tutti i valori vengono &quot;ripristinati&quot; con il capitale
        iniziale e senza PnL - realizzato o non realizzato.
        &quot;&quot;&quot;
        self.price_handler = price_handler
        self.init_cash = cash
        self.cur_cash = cash
        self.positions = {}
        self._reset_values()

    def _reset_values(self):
        &quot;&quot;&quot;
        Questo viene chiamato dopo ogni aggiunta di
        posizione o modifica. Permette che i calcoli
        siano eseguito &quot;da zero&quot; in modo da minimizzare
        errori.

        Tutto il contanti venie ripristinato ai valori
        iniziali e il PnL è impostato a zero.
        &quot;&quot;&quot;
        self.cur_cash = self.init_cash
        self.equity = self.cur_cash
        self.unrealised_pnl = Decimal(&#039;0.00&#039;)
        self.realised_pnl = Decimal(&#039;0.00&#039;)

    def _update_portfolio(self):
        &quot;&quot;&quot;
         Aggiorna i valori totali del portafoglio (contanti, capitale,
        PnL non realizzato, PnL realizzato, costo base ecc.)
        su i valori correnti per tutti i ticker.

        Questo metodo viene chiamato dopo ogni modifica della posizione.
        &quot;&quot;&quot;
        for ticker in self.positions:
            pt = self.positions[ticker]
            self.unrealised_pnl += pt.unrealised_pnl
            self.realised_pnl += pt.realised_pnl
            self.cur_cash -= pt.cost_basis
            pnl_diff = pt.realised_pnl - pt.unrealised_pnl
            self.cur_cash += pnl_diff
            self.equity += (
                pt.market_value - pt.cost_basis + pnl_diff
            )

    def _add_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Aggiunge un nuovo oggetto Position al Portfolio. Questo
        richiede di ottenere il miglior prezzo bid / ask dal
        gestore del prezzo al fine di calcolare un ragionevole
        &quot; valore di mercato &quot;.

        Una volta aggiunta la posizione, i valori del portafoglio
        vengono aggiornati.
        &quot;&quot;&quot;
        self._reset_values()
        if ticker not in self.positions:
            bid, ask = self.price_handler.get_best_bid_ask(ticker)
            position = Position(
                action, ticker, quantity,
                price, commission, bid, ask
            )
            self.positions[ticker] = position
            self._update_portfolio()
        else:
            print(
                &quot;Ticker %s is already in the positions list. &quot; \
                &quot;Could not add a new position.&quot; % ticker
            )

    def _modify_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Modifica un oggetto Posizione corrente nel Portafoglio.
        Ciò richiede di ottenere il miglior prezzo bid / ask dal
        gestore del prezzo al fine di calcolare un ragionevole
        &quot; valore di mercato &quot;.

        Una volta modificata la posizione, il portafoglio valorizza
        vengono aggiornati.
        &quot;&quot;&quot;
        self._reset_values()
        if ticker in self.positions:
            self.positions[ticker].transact_shares(
                action, quantity, price, commission
            )
            bid, ask = self.price_handler.get_best_bid_ask(ticker)
            self.positions[ticker].update_market_value(bid, ask)
            self._update_portfolio()
        else:
            print(
                &quot;Ticker %s not in the current position list. &quot; \
                &quot;Could not modify a current position.&quot; % ticker
            )

    def transact_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Gestisce qualsiasi nuova posizione o modifica a 
        una posizione corrente, chiamando il rispettivo
        metodi _add_position e _modify_position. 

        Quindi, questo singolo metodo verrà chiamato da 
        PortfolioHandler per aggiornare il Portfolio stesso.
        &quot;&quot;&quot;
        if ticker not in self.positions:
            self._add_position(
                action, ticker, quantity,
                price, commission
            )
        else:
            self._modify_position(
                action, ticker, quantity,
                price, commission
            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-56390ea elementor-widget elementor-widget-text-editor" data-id="56390ea" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come per il codice di <code>position.py </code>nell&#8217;articolo precedente, facciamo un ampio uso del modulo <a href="https://docs.python.org/3.5/library/decimal.html">Decimal</a> di Python . Come accennato in precedenza, questa è un requisito fondamentale nei calcoli finanziari, altrimenti si introducono errori di arrotondamento dovuti alla <a href="http://floating-point-gui.de/">matematica delle operazioni in virgola mobile</a> .</p><p>Nel metodo di inizializzazione della classe <code>Portfolio</code> prendiamo due parametri di input: un <code>PriceHandler</code> e un saldo di cassa iniziale (che è un tipo di dati Decimal, non un valore in virgola mobile). Questo è tutto ciò di cui abbiamo bisogno per creare un&#8217;istanza <code>Portfolio</code>.</p><p>Nel metodo stesso creiamo due valori: una liquidità iniziale e una liquidità corrente. Creiamo quindi un dizionario di posizioni e infine chiamiamo il metodo <code>_reset_values</code>, che azzera tutti i calcoli di cassa e azzera tutti i valori PnL:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8b1b502 elementor-widget elementor-widget-bdt-source-code" data-id="8b1b502" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
from position import Position


class Portfolio(object):
    def __init__(self, price_handler, cash):
        &quot;&quot;&quot;
        Alla creazione, l&#039;oggetto Portfolio non contiene posizioni
        e tutti i valori vengono &quot;ripristinati&quot; con il capitale
        iniziale e senza PnL - realizzato o non realizzato.
        &quot;&quot;&quot;
        self.price_handler = price_handler
        self.init_cash = cash
        self.cur_cash = cash
        self.positions = {}
        self._reset_values()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9d10173 elementor-widget elementor-widget-text-editor" data-id="9d10173" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come accennato in precedenza, <code>_reset_values </code>è richiamato durante l&#8217;inizializzazione, ma è anche durante <span style="color: var( --e-global-color-text ); font-size: 1rem;">la modifica di ogni posizione. Può sembrare ingombrante, ma riduce notevolmente gli errori nel processo di calcolo. Reimposta semplicemente i valori di liquidità e di capitale correnti al valore iniziale e quindi azzera i valori PnL:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-dccc4c2 elementor-widget elementor-widget-bdt-source-code" data-id="dccc4c2" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _reset_values(self):
        &quot;&quot;&quot;
        Questo viene chiamato dopo ogni aggiunta di
        posizione o modifica. Permette che i calcoli
        siano eseguito &quot;da zero&quot; in modo da minimizzare
        errori.

        Tutto il contanti venie ripristinato ai valori
        iniziali e il PnL è impostato a zero.
        &quot;&quot;&quot;
        self.cur_cash = self.init_cash
        self.equity = self.cur_cash
        self.unrealised_pnl = Decimal(&#039;0.00&#039;)
        self.realised_pnl = Decimal(&#039;0.00&#039;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-fe25e5b elementor-widget elementor-widget-text-editor" data-id="fe25e5b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo successivo è <code>_update_portfolio</code>. Questo metodo viene chiamato anche dopo ogni modifica della posizione (cioè transazione). Per ogni ticker nel <code>Portfolio</code>, ogni PnL delle <em>posizioni</em> sono aggiunti al <span style="color: var( --e-global-color-text ); font-size: 1rem;">il PnL non realizzato e realizzato dell&#8217;intero </span><em style="color: var( --e-global-color-text ); font-size: 1rem;">portafoglio</em><span style="color: var( --e-global-color-text ); font-size: 1rem;">, mentre la liquidità disponibile corrente viene ridotta in base al </span><a style="background-color: #ffffff; font-size: 1rem;" href="http://www.investopedia.com/terms/c/costbasis.asp">costo base</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> delle posizioni . Infine, la differenza tra PnL realizzato e non realizzato viene applicata alla liquidità corrente e si rettifica l&#8217;equity totale del portafoglio:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-11847c1 elementor-widget elementor-widget-bdt-source-code" data-id="11847c1" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _update_portfolio(self):
        &quot;&quot;&quot;
         Aggiorna i valori totali del portafoglio (contanti, capitale,
        PnL non realizzato, PnL realizzato, costo base ecc.)
        su i valori correnti per tutti i ticker.

        Questo metodo viene chiamato dopo ogni modifica della posizione.
        &quot;&quot;&quot;
        for ticker in self.positions:
            pt = self.positions[ticker]
            self.unrealised_pnl += pt.unrealised_pnl
            self.realised_pnl += pt.realised_pnl
            self.cur_cash -= pt.cost_basis
            pnl_diff = pt.realised_pnl - pt.unrealised_pnl
            self.cur_cash += pnl_diff
            self.equity += (
                pt.market_value - pt.cost_basis + pnl_diff
            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-70485eb elementor-widget elementor-widget-text-editor" data-id="70485eb" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Anche se questo può sembrare un po&#8217; complesso, abbiamo implementato questi calcoli in modo che riflettano il le logiche in cui i portafogli vengono modificati nelle principali società di intermediazione, in particolare <a href="http://www.interactivebrokers.com/">Interactive Brokers</a> . Significa che il motore di backtesting dovrebbe produrre valori vicini a quelli del live trading, nell&#8217;ipotesi di slippage e costi di transazione.</p><p>I prossimi due metodi sono <code>_add_position </code>e <code>_modify_position</code>. In origine, questi due metodi erano metodi richiamabili &#8220;pubblicamente&#8221; per creare nuove posizioni e successivamente modificarle. In seguito abbiamo voluto rendere trasparente all&#8217;utente la gestione di aggiungere o modificare una posizione, e così abbiamo introdotto un metodo wrapper, chiamato <code>transact_position </code>che ora utilizza il metodo corretto  a seconda dell&#8217;esistenza di un ticker nell&#8217;elenco delle posizioni.</p><p>Il metodo <code>_add_position </code><span style="color: var( --e-global-color-text ); font-size: 1rem;">prevede in input un&#8217;azione (acquisto o vendita), un simbolo ticker e una quantità di asset, il prezzo di riempimento e il costo della commissione, come parametri. Per prima cosa si ripristina i valori dell&#8217;intero portafoglio e quindi otteniamo il miglior prezzo di offerta e domanda del ticker dall&#8217;oggetto di gestione dei prezzi. Quindi creiamo il nuovo </span><code>Position</code><span style="color: var( --e-global-color-text ); font-size: 1rem;">, utilizzando questi prezzi di offerta e domanda per ottenere un &#8220;valore di mercato&#8221; aggiornato. Infine aggiungiamo l&#8217;istanza&#8217; </span><code>Position</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> al dizionario delle posizioni, utilizzando il simbolo ticker come chiave*</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">.</span></p><p>Da notare che chiediamo a <code>_update_portfolio </code>di aggiornare tutti i valori di mercato in questa fase. Il metodo gestisce anche il caso in cui la posizione esiste già, stampando alcune informazioni sulla console. In futuro sostituiremo tutte le istanze dell&#8217;output sulla console con meccanismi di registrazione più robusti.</p><p><em><sup>*</sup>Questo comporta in seguito implicazioni di progettazione, quando si tratterà di rinominare i simboli ticker, classi di azioni multiple e altre azioni societarie. Tuttavia, per semplicità in questa fase utilizzeremo il simbolo ticker poiché è unico per i nostri scopi.</em></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a26b9e4 elementor-widget elementor-widget-bdt-source-code" data-id="a26b9e4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _add_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Aggiunge un nuovo oggetto Position al Portfolio. Questo
        richiede di ottenere il miglior prezzo bid / ask dal
        gestore del prezzo al fine di calcolare un ragionevole
        &quot; valore di mercato &quot;.

        Una volta aggiunta la posizione, i valori del portafoglio
        vengono aggiornati.
        &quot;&quot;&quot;
        self._reset_values()
        if ticker not in self.positions:
            bid, ask = self.price_handler.get_best_bid_ask(ticker)
            position = Position(
                action, ticker, quantity,
                price, commission, bid, ask
            )
            self.positions[ticker] = position
            self._update_portfolio()
        else:
            print(
                &quot;Ticker %s is already in the positions list. &quot; \
                &quot;Could not add a new position.&quot; % ticker
            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c24f5b9 elementor-widget elementor-widget-text-editor" data-id="c24f5b9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><code>_modify_position</code> <span>è simile ad &#8220;add_position&#8221; tranne per il fatto che richiama </span><code>transact_shares</code> <span>della classe </span><code>Position</code> <span>invece di creare una nuova posizione:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5d2ed6a elementor-widget elementor-widget-bdt-source-code" data-id="5d2ed6a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _modify_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Modifica un oggetto Posizione corrente nel Portafoglio.
        Ciò richiede di ottenere il miglior prezzo bid / ask dal
        gestore del prezzo al fine di calcolare un ragionevole
        &quot; valore di mercato &quot;.

        Una volta modificata la posizione, il portafoglio valorizza
        vengono aggiornati.
        &quot;&quot;&quot;
        self._reset_values()
        if ticker in self.positions:
            self.positions[ticker].transact_shares(
                action, quantity, price, commission
            )
            bid, ask = self.price_handler.get_best_bid_ask(ticker)
            self.positions[ticker].update_market_value(bid, ask)
            self._update_portfolio()
        else:
            print(
                &quot;Ticker %s not in the current position list. &quot; \
                &quot;Could not modify a current position.&quot; % ticker
            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-41f4d0c elementor-widget elementor-widget-text-editor" data-id="41f4d0c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo che viene effettivamente chiamato esternamente è <code>transact_position</code>. Comprende sia la creazione che la modifica di un oggetto <code>Position</code>. Sceglie semplicemente il metodo corretto tra <code>_add_position </code>e <code>_modify_position </code>quando si effettua una nuova transazione:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5790e1c elementor-widget elementor-widget-bdt-source-code" data-id="5790e1c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def transact_position(self, action, ticker, quantity, price, commission):
        &quot;&quot;&quot;
        Gestisce qualsiasi nuova posizione o modifica a 
        una posizione corrente, chiamando il rispettivo
        metodi _add_position e _modify_position. 

        Quindi, questo singolo metodo verrà chiamato da 
        PortfolioHandler per aggiornare il Portfolio stesso.
        &quot;&quot;&quot;
        if ticker not in self.positions:
            self._add_position(
                action, ticker, quantity,
                price, commission
            )
        else:
            self._modify_position(
                action, ticker, quantity,
                price, commission
            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7608e8c elementor-widget elementor-widget-text-editor" data-id="7608e8c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Questo conclude la classe </span><code>Portfolio</code><span>. Fornisce un robusto meccanismo autonomo per raggruppare le classi </span><code>Position</code><span> con un saldo di cassa.</span></p><p><span>Per completezza puoi trovare il codice completo per la classe </span><code>Portfolio</code><span> su <a href="https://github.com/datatrading-info/DataTrader">Github</a></span><span>.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4c867ef elementor-widget elementor-widget-heading" data-id="4c867ef" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">portfolio_test.py</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-d48993d elementor-widget elementor-widget-text-editor" data-id="d48993d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come per <code>position_test.py</code>, abbiamo creato <code>portfolio_test.py</code>, che include un unit test per verificare l&#8217;integrità di base per più transazioni di azioni AMZN e GOOG. Sicuramente è necessario fare più lavoro per controllare portafogli più grandi e diversificati, ma almeno possiamo assicurarci che il sistema stia calcolando i valori come dovrebbe.</p><p>Come per i test per la classe <code>Position</code>, questi sono stati confrontati con i valori prodotti da Interactive Brokers utilizzando l&#8217;account demo di Trader Workstation. Come prima, in futuro è sempre possibile trovare nuovi casi limite e bug, ma speriamo che l&#8217;attuale controllo di integrità e test di calcolo dovrebbero fornire fiducia nel funzionamento del <code>Portfolio</code>.</p><p>Il listato completo di <code>position_test.py </code>è il seguente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a99683a elementor-widget elementor-widget-bdt-source-code" data-id="a99683a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
import unittest

from portfolio import Portfolio


class PriceHandlerMock(object):
    def __init__(self):
        pass

    def get_best_bid_ask(self, ticker):
        prices = {
            &quot;GOOG&quot;: (Decimal(&quot;705.46&quot;), Decimal(&quot;705.46&quot;)),
            &quot;AMZN&quot;: (Decimal(&quot;564.14&quot;), Decimal(&quot;565.14&quot;)),
        }
        return prices[ticker]


class TestAmazonGooglePortfolio(unittest.TestCase):
    &quot;&quot;&quot;
    Prova un portafoglio composto da Amazon e
    Google con vari ordini per creare
    &quot;round-trip&quot; per entrambi.

    Questi ordini sono stati eseguiti in un conto demo
    di Interactive Brokers e verificata l&#039;uguaglianza
    per contanti, equità e PnL.
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Imposta l&#039;oggetto Portfolio che memorizzerà una
        raccolta di oggetti Position, prevedendo
        $500.000,00 USD per il saldo iniziale del conte
        &quot;&quot;&quot;
        ph = PriceHandlerMock()
        cash = Decimal(&quot;500000.00&quot;)
        self.portfolio = Portfolio(ph, cash)


    def test_calculate_round_trip(self):
        &quot;&quot;&quot;
        Acquisto/vendita più lotti di AMZN e GOOG
        a vari prezzi / commissioni per controllare
        il calcolo e la gestione dei costi.
        &quot;&quot;&quot;
        # Acquista 300 AMZN su due transazion
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;AMZN&quot;, 100,
            Decimal(&quot;566.56&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;AMZN&quot;, 200,
            Decimal(&quot;566.395&quot;), Decimal(&quot;1.00&quot;)
        )
        # Acquista 200 GOOG su una transazione
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;GOOG&quot;, 200,
            Decimal(&quot;707.50&quot;), Decimal(&quot;1.00&quot;)
        )
        # Aggiunge 100 azioni sulla posizione di AMZN
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;AMZN&quot;, 100,
            Decimal(&quot;565.83&quot;), Decimal(&quot;1.00&quot;)
        )
        # Aggiunge 200 azioni alla posizione di GOOG
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;GOOG&quot;, 200,
            Decimal(&quot;705.545&quot;), Decimal(&quot;1.00&quot;)
        )
        # Vende 200 azioni di AMZN
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;AMZN&quot;, 200,
            Decimal(&quot;565.59&quot;), Decimal(&quot;1.00&quot;)
        )
        # Transazioni Multiple costruite in una (in IB)
        # Vendi 300 GOOG dal portfolio
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.92&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.90&quot;), Decimal(&quot;0.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.92&quot;), Decimal(&quot;0.50&quot;)
        )
        # Infine vendiamo le rimanenti 100 azioni di GOOG
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.78&quot;), Decimal(&quot;1.00&quot;)
        )

        # I numeri seguenti sono derivati dall&#039;account demo di 
        # Interactive Brokers usando i seguenti trade con i 
        # prezzi forniti dal loro feed dati in demo.
        self.assertEqual(self.portfolio.cur_cash, Decimal(&quot;499100.50&quot;))
        self.assertEqual(self.portfolio.equity, Decimal(&quot;499100.50&quot;))
        self.assertEqual(self.portfolio.unrealised_pnl, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.portfolio.realised_pnl, Decimal(&quot;-899.50&quot;))


if __name__ == &quot;__main__&quot;:
    unittest.main()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-df5337e elementor-widget elementor-widget-text-editor" data-id="df5337e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il primo compito è eseguire le  corrette importazioni. Importiamo il modulo </span><a href="https://docs.python.org/3/library/unittest.html"><span>unittest</span></a><span> e l&#8217;oggetto </span><code>Portfolio</code> <span>stesso:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9c59872 elementor-widget elementor-widget-bdt-source-code" data-id="9c59872" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
import unittest

from portfolio import Portfolio</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8a84738 elementor-widget elementor-widget-text-editor" data-id="8a84738" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per creare una classe <code>Portfolio</code> funzionante , abbiamo bisogno di una classe <code>PriceHandler</code> per fornire valori bid e ask per ogni ticker. Tuttavia, non abbiamo ancora codificato alcun oggetto di gestione dei prezzi, quindi cosa dobbiamo fare?</p><p>A quanto pare, questo è un modello comune negli unit test. Per superare questa difficoltà, possiamo creare un <a href="https://en.wikipedia.org/wiki/Mock_object">oggetto fittizio</a> . In sostanza, un mock-object è una classe che <em>simula</em> il comportamento della sua controparte reale, consentendo così di testare la funzionalità su altre classi che ne fanno uso. Quindi è necessario creare una classe <code>PriceHandlerMock</code> che fornisca la stessa interfaccia di a <code>PriceHandler</code>, ma restituisca solo valori preimpostati, invece di eseguire calcoli su<span style="color: var( --e-global-color-text ); font-size: 1rem;"> prezzi </span><span style="color: var( --e-global-color-text ); font-size: 1rem;">&#8220;reali&#8221;</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">.</span></p><p>L&#8217;oggetto <code>PriceHandlerMock</code> ha un metodo di inizializzazione vuoto, ma espone il metodo <code>get_best_bid_ask</code> che si trova sul reale <code>PriceHandler</code>. Restituisce semplicemente valori bid/ask preimpostati per le azioni GOOG e AMZN con cui effettueremo le transazioni nei seguenti ulteriori unit test:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ccba098 elementor-widget elementor-widget-bdt-source-code" data-id="ccba098" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class PriceHandlerMock(object):
    def __init__(self):
        pass

    def get_best_bid_ask(self, ticker):
        prices = {
            &quot;GOOG&quot;: (Decimal(&quot;705.46&quot;), Decimal(&quot;705.46&quot;)),
            &quot;AMZN&quot;: (Decimal(&quot;564.14&quot;), Decimal(&quot;565.14&quot;)),
        }
        return prices[ticker]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-917dd3b elementor-widget elementor-widget-text-editor" data-id="917dd3b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Gli unit test consistono nel creare una nuova classe chiamata in modo piuttosto parlante </span><code>TestAmazonGooglePortfolio</code> che, c<span>ome tutti gli unit test in Python, è derivato dalla classe </span><code>unittest.TestCase</code><span>.</span></p><p><span>Nel metodo </span><code>setUp</code><span> impostiamo l&#8217;oggetto fittizio del gestore del prezzo, il saldo iniziale e creiamo un </span><code>Portfolio</code><span>:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7101640 elementor-widget elementor-widget-bdt-source-code" data-id="7101640" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class TestAmazonGooglePortfolio(unittest.TestCase):
    &quot;&quot;&quot;
    Prova un portafoglio composto da Amazon e
    Google con vari ordini per creare
    &quot;round-trip&quot; per entrambi.

    Questi ordini sono stati eseguiti in un conto demo
    di Interactive Brokers e verificata l&#039;uguaglianza
    per contanti, equità e PnL.
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Imposta l&#039;oggetto Portfolio che memorizzerà una
        raccolta di oggetti Position, prevedendo
        $500.000,00 USD per il saldo iniziale del conte
        &quot;&quot;&quot;
        ph = PriceHandlerMock()
        cash = Decimal(&quot;500000.00&quot;)
        self.portfolio = Portfolio(ph, cash)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-1c22a01 elementor-widget elementor-widget-text-editor" data-id="1c22a01" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>L&#8217;unico metodo di unit test che creiamo è chiamato </span><code>test_calculate_round_trip</code><span>. Il suo obiettivo è calcolare i trade round-trip per AMZN e GOOG, assicurandosi che i calcoli finanziari delle classi </span><code>Position</code><span>e </span><code>Portfolio</code> <span>siano corretti.  In questo caso &#8220;corretto&#8221; significa che corrispondono ai valori calcolati da Interactive Brokers quando abbiamo eseguito questa situazione in Trader Workstation. Abbiamo codificato questi valori negli unit test.</span></p><p><span>La prima parte del metodo esegue più transazioni sia per GOOG che per AMZN a vari prezzi e costi di commissione. Abbiamo preso questi prezzi direttamente da quelli calcolati da Interactive Brokers (IB) quando abbiamo effettuato questi trade nel conto demo. &#8220;BOT&#8221; è la terminologia IB per l&#8217;acquisto di un&#8217;azione, mentre &#8220;SLD&#8221; è la terminologia per la vendita di un&#8217;azione.</span></p><p><span>Una volta completata la serie completa di transazioni, le posizioni vengono entrambe compensate con quantità zero. Non avranno alcun PnL non realizzato, ma avranno un PnL realizzato, così come modifiche alla liquidità corrente e al valore del patrimonio netto totale:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b7aa525 elementor-widget elementor-widget-bdt-source-code" data-id="b7aa525" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_calculate_round_trip(self):
        &quot;&quot;&quot;
        Acquisto/vendita più lotti di AMZN e GOOG
        a vari prezzi / commissioni per controllare
        il calcolo e la gestione dei costi.
        &quot;&quot;&quot;
        # Acquista 300 AMZN su due transazion
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;AMZN&quot;, 100,
            Decimal(&quot;566.56&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;AMZN&quot;, 200,
            Decimal(&quot;566.395&quot;), Decimal(&quot;1.00&quot;)
        )
        # Acquista 200 GOOG su una transazione
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;GOOG&quot;, 200,
            Decimal(&quot;707.50&quot;), Decimal(&quot;1.00&quot;)
        )
        # Aggiunge 100 azioni sulla posizione di AMZN
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;AMZN&quot;, 100,
            Decimal(&quot;565.83&quot;), Decimal(&quot;1.00&quot;)
        )
        # Aggiunge 200 azioni alla posizione di GOOG
        self.portfolio.transact_position(
            &quot;BOT&quot;, &quot;GOOG&quot;, 200,
            Decimal(&quot;705.545&quot;), Decimal(&quot;1.00&quot;)
        )
        # Vende 200 azioni di AMZN
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;AMZN&quot;, 200,
            Decimal(&quot;565.59&quot;), Decimal(&quot;1.00&quot;)
        )
        # Transazioni Multiple costruite in una (in IB)
        # Vendi 300 GOOG dal portfolio
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.92&quot;), Decimal(&quot;1.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.90&quot;), Decimal(&quot;0.00&quot;)
        )
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.92&quot;), Decimal(&quot;0.50&quot;)
        )
        # Infine vendiamo le rimanenti 100 azioni di GOOG
        self.portfolio.transact_position(
            &quot;SLD&quot;, &quot;GOOG&quot;, 100,
            Decimal(&quot;704.78&quot;), Decimal(&quot;1.00&quot;)
        )

        # I numeri seguenti sono derivati dall&#039;account demo di 
        # Interactive Brokers usando i seguenti trade con i 
        # prezzi forniti dal loro feed dati in demo.
        self.assertEqual(self.portfolio.cur_cash, Decimal(&quot;499100.50&quot;))
        self.assertEqual(self.portfolio.equity, Decimal(&quot;499100.50&quot;))
        self.assertEqual(self.portfolio.unrealised_pnl, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.portfolio.realised_pnl, Decimal(&quot;-899.50&quot;))


if __name__ == &quot;__main__&quot;:
    unittest.main()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2ec5dd9 elementor-widget elementor-widget-text-editor" data-id="2ec5dd9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Chiaramente c&#8217;è spazio per produrre molti più unit test per questa classe, specialmente quando vengono utilizzate posizioni più esotiche, come quelle con forex, futures o opzioni. Tuttavia, in questa fase vogliamo semplicemente gestire azioni ed ETF, il che significa una gestione delle posizioni più diretta.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-729ff42 elementor-widget elementor-widget-heading" data-id="729ff42" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Prossimi Passi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-94e24ad elementor-widget elementor-widget-text-editor" data-id="94e24ad" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Ora che abbiamo discusso sia le classo  </span><code>Position</code> <span>e </span><code>Portfolio</code><span> dobbiamo approfondire il </span><code>PortfolioHandler</code><span>. Questa è la classe che interagisce con </span><code>PositionSizer</code><span>e </span><code>RiskManager</code> <span>per produrre ordini e ricevere esecuzioni che alla fine determinano il portafoglio azionario (e quindi la redditività!).</span></p><p><span>Dal momento che siamo molto più avanti con l&#8217;effettivo sviluppo effettivo del software di </span><a href="https://github.com/datatrading-info/DataTrader"><span>DataTrader</span></a><span> rispetto agli articoli che spiegano come funziona, presenteremo al più presto alcune strategie di trading avanzate utilizzando questo software, piuttosto che aspettare che tutti gli articoli siano stati completati.</span></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-la-classe-portfolio/">DataTrader – Trading Algoritmico Avanzato: la Classe Portfolio</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DataTrader – Trading Algoritmico Avanzato: Gestione delle Posizioni</title>
		<link>https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sat, 09 Jun 2018 14:36:54 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial DataTrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2733</guid>

					<description><![CDATA[<p>In questo articolo descriviamo i primi risultati della nuova infrastruttura avanzata di trading che vogliamo implementare, seguendo le linee guida pubblicate nel precedente articolo. In queste linee guida abbiamo previsto di&#160;riutilizzare e migliorare il più possibile il codice base di DataBacktest (backtesting basato su eventi) e di DTForex al fine di non duplicare sforzi e &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/"> <span class="screen-reader-text">DataTrader – Trading Algoritmico Avanzato: Gestione delle Posizioni</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/">DataTrader – Trading Algoritmico Avanzato: Gestione delle Posizioni</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2733" class="elementor elementor-2733">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-0fb6daf elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="0fb6daf" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-e353f1a" data-id="e353f1a" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-ab0b22e elementor-widget elementor-widget-text-editor" data-id="ab0b22e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo descriviamo i primi risultati della nuova infrastruttura avanzata di trading che vogliamo implementare, seguendo le linee guida pubblicate nel <a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/">precedente articolo</a>.</p><p>In queste linee guida abbiamo previsto di <span style="color: var( --e-global-color-text ); font-size: 1rem;">riutilizzare e migliorare il più possibile il codice base di </span><a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">DataBacktest (backtesting basato su eventi)</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> e di </span><a href="https://datatrading.info/dtforex-1-trading-automatico-sul-forex-tramite-le-api-di-oanda/">DTForex</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> al fine di non duplicare sforzi e lavoro. Nonostante vari tentativi di utilizzare gran parte del codice di queste due librerie, abbiamo concluso che è necessario &#8220;ricominciare da zero&#8221; e rivedere le modalità di gestione/dimensionamento delle posizioni, la gestione del rischio e la costruzione del portafoglio.</span></p><p>In particolare, bisogna modificare il design di DTForex e di DataBacktest in modo da integrare il corretto dimensionamento della posizione e dei livelli di gestione del rischio, che non erano presenti nelle versioni precedenti. Questi due componenti forniscono solidi strumenti per la costruzione del portafoglio che aiutano nella creazione di portafogli &#8220;professionali&#8221;, piuttosto che quelli presenti in un semplice backtester vettorizzato.</p><p>In questa fase non prevediamo di implementare nessuna logica specifica per la gestione del rischio o di dimensionamento della posizione, poiché questa logica è altamente specifica per ogni singolo trader. Sarà comunque oggetto di esempi per semplici scenari come il posizionamento tramite il criterio di Kelly o livelli di rischio in base alla volatilità, ma non implementeremo complesse gestioni per il rischio e per le posizioni. In questo modo è possibile utilizzare le versioni &#8220;standard&#8221; che sviluppiamo, ma anche sostituire completamente questi componenti con la logica personalizzata che meglio si adatta alle proprie esigenze. La filosofia del sistema non costringe a utilizzare una particolare metodologia di gestione del rischio.</p><p>Ad oggi abbiamo codificato le basi per la gestione del portafoglio. L&#8217;intero strumento di backtest e trading, che abbiamo chiamato <strong>DataTrader</strong> , è lungi dall&#8217;essere pronto per la produzione. In effetti, possiamo dire che in questa fase siamo in uno stato &#8220;pre-alfa&#8221;! Nonostante il fatto che il sistema sia agli inizi del suo sviluppo, abbiamo compiuto uno sforzo significativo per effettuare gli <a href="https://it.wikipedia.org/wiki/Unit_testing">unit test</a> delle prime componenti, nonché nel testare i valori calcolati dal broker esterno. Al momento siamo abbastanza fiduciosi nel meccanismo di gestione della posizione. Tuttavia, in caso di nuovi casi limite, si possono semplicemente aggiungere nuovi unit test per migliorare ulteriormente la robustezza.</p><p>Il progetto è ora disponibile (in uno stato estremamente precoce!) su <a href="https://github.com/datatrading-info/DataTrader">github.com/datatrading-info/DataTrader</a> con licenza MIT open source liberale. In questa fase manca la documentazione, quindi aggiungo il link solo per coloro che desiderano navigare nel codice.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7641eee elementor-widget elementor-widget-heading" data-id="7641eee" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Progettazione dei componenti</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-c7cefff elementor-widget elementor-widget-text-editor" data-id="c7cefff" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Nel </span><a href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/"><span>precedente articolo</span></a><span> di questa serie sul Trading Algoritmico Avanzato abbiamo descritto la roadmap per lo sviluppo dell&#8217;infrastruttura software. In questo articolo descriviamo uno degli aspetti più importanti del sistema, ovvero la componente </span><code>Position</code><span>, che costituisce la base del </span><code>Portfolio</code><span>e successivamente del </span><code>PortfolioHandler</code><span>.</span></p><p><span>Quando si progetta un tale sistema è necessario considerare come si dividono le comportamenti in vari sottomoduli separati . Ciò non solo permette di evitare un forte accoppiamento dei componenti, ma consente anche test molto più semplici, poiché ogni componente può essere testato separatamente.</span></p><p><span>Il design scelto per l&#8217;infrastruttura di gestione del portafoglio è costituito dai seguenti componenti:</span></p><ul><li><strong><span>Position</span></strong><span> : questa classe incapsula tutti i dati associati a una posizione aperta per un asset. In altre parole, tiene traccia dei profitti e delle perdite (PnL) realizzati e non realizzati calcolando la media delle &#8220;gambe&#8221; multiple della transazione, inclusi i costi di transazione.</span></li><li><strong><span>Portfolio</span></strong><span> &#8211; La classe Portfolio che racchiude un elenco di posizioni, nonché un saldo del conto, equity e PnL.</span></li><li><strong><span>PositionSizer</span></strong><span> &#8211; La classe PositionSizer fornisce al PortfolioHandler (di seguito) una guida su come dimensionare le posizioni una volta ricevuto un segnale di strategia. Ad esempio, PositionSizer potrebbe incorporare un approccio del criterio di Kelly.</span></li><li><strong><span>RiskManager</span></strong><span> &#8211; Il RiskManager viene utilizzato dal PortfolioHandler per verificare, modificare o porre il veto a qualsiasi negoziazione suggerita che passa dal PositionSizer, sulla base dell&#8217;attuale composizione del portafoglio e di considerazioni di rischio esterno (come la correlazione agli indici o la volatilità).</span></li><li><strong><span>PortfolioHandler</span></strong><span> &#8211; La classe PortfolioHandler è responsabile della gestione del portafoglio corrente, interagendo con RiskManager e PositionSizer, nonché inviando ordini da eseguire da un gestore di esecuzione.</span></li></ul><p><span>Notare che questa organizzazione di componenti è in qualche modo diversa dal modo in cui opera il sistema di backtest in </span><a href="https://datatrading.info/dtforex-1-trading-automatico-sul-forex-tramite-le-api-di-oanda/"><span>DTForex</span></a><span> . In tal caso l&#8217;oggetto </span><code>Portfolio</code><span> è l&#8217;equivalente alla precedente classe </span><code>PortfolioHandler</code>.<span> In questo nuovo progetto sono stati divise in due classi separate in modo da prevedere una gestione molto più semplice del rischio  e del dimensionamento della posizione con le classi </span><code>RiskManager</code><span>e </span><code>PositionSizer</code><span>.</span></p><p><span>Rivolgeremo ora la nostra attenzione alla classe</span> <code>Position</code><span>. Negli articoli successivi vedremo le classi</span> <code>Portfolio</code><span>, </span><code>PortfolioHandler</code> <span>e le componenti per il dimensionamento del rischio/posizione.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4332d45 elementor-widget elementor-widget-heading" data-id="4332d45" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La classe Position</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-88c11e1 elementor-widget elementor-widget-text-editor" data-id="88c11e1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>La classe </span><code>Position</code><span> è molto simile all&#8217;omonima classe nel progetto </span><a href="https://datatrading.info/dtforex-1-trading-automatico-sul-forex-tramite-le-api-di-oanda/"><span>DTForex</span></a><span> , con la differenza che è stata progettata, almeno in questa fase, per essere utilizzata con strumenti azionari, piuttosto che nel mercato forex. Quindi non esiste la nozione di una valuta &#8220;base&#8221; o &#8220;quotata&#8221;. Tuttavia, conserviamo la possibilità di attualizzare il PnL non realizzato, tramite l&#8217;aggiornamento dei prezzi bid/ask quotati sul mercato.</span></p><p><span>Di seguito il listato  completo del codice e poi la descrizione del suo funzionamento.</span></p><p><em><span>Da notare che qualsiasi di questi listati è soggetto a modifiche, poiché si prevedono aggiornamenti continui a questo progetto.</span></em></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-724b47d elementor-widget elementor-widget-bdt-source-code" data-id="724b47d" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal


TWOPLACES = Decimal(&quot;0.01&quot;)
FIVEPLACES = Decimal(&quot;0.00001&quot;)


class Position(object):
    def __init__(
        self, action, ticker, init_quantity,
        init_price, init_commission,
        bid, ask
    ):
        &quot;&quot;&quot;
        Imposta il &quot;conto&quot; iniziale della posizione che è zero per
        la maggior parte degli item, ad eccezione dell&#039;iniziale
        acquisto / vendita.

        Quindi calcola i valori iniziali e infine aggiorna il
        valore di mercato della transazione.
        &quot;&quot;&quot;
        self.action = action
        self.ticker = ticker
        self.quantity = init_quantity
        self.init_price = init_price
        self.init_commission = init_commission

        self.realised_pnl = Decimal(&quot;0.00&quot;)
        self.unrealised_pnl = Decimal(&quot;0.00&quot;)

        self.buys = Decimal(&quot;0&quot;)
        self.sells = Decimal(&quot;0&quot;)
        self.avg_bot = Decimal(&quot;0.00&quot;)
        self.avg_sld = Decimal(&quot;0.00&quot;)
        self.total_bot = Decimal(&quot;0.00&quot;)
        self.total_sld = Decimal(&quot;0.00&quot;)
        self.total_commission = init_commission

        self._calculate_initial_value()
        self.update_market_value(bid, ask)

    def _calculate_initial_value(self):
        &quot;&quot;&quot;
        A seconda che l&#039;azione fosse un acquisto o una vendita (&quot; BOT &quot;
        o &quot; SLD &quot;) si calcola il costo medio di acquisto, il costo totale
        di acquisto, prezzo medio e costo basi.

        Infine, calcola il totale netto con e senza commissioni.

        &quot;&quot;&quot;

        if self.action == &quot;BOT&quot;:
            self.buys = self.quantity
            self.avg_bot = self.init_price.quantize(FIVEPLACES)
            self.total_bot = (self.buys * self.avg_bot).quantize(TWOPLACES)
            self.avg_price = (
                (self.init_price * self.quantity + self.init_commission)/self.quantity
            ).quantize(FIVEPLACES)
            self.cost_basis = (
                self.quantity * self.avg_price
            ).quantize(TWOPLACES)
        else:  # action == &quot;SLD&quot;
            self.sells = self.quantity
            self.avg_sld = self.init_price.quantize(FIVEPLACES)
            self.total_sld = (self.sells * self.avg_sld).quantize(TWOPLACES)
            self.avg_price = (
                (self.init_price * self.quantity - self.init_commission)/self.quantity
            ).quantize(FIVEPLACES)
            self.cost_basis = (
                -self.quantity * self.avg_price
            ).quantize(TWOPLACES)
        self.net = self.buys - self.sells
        self.net_total = (self.total_sld - self.total_bot).quantize(TWOPLACES)
        self.net_incl_comm = (self.net_total - self.init_commission)
                               .quantize(TWOPLACES)

    def update_market_value(self, bid, ask):
        &quot;&quot;&quot;
        Il valore di mercato è difficile da calcolare davo che abbiamo accesso
        alla parte superiore del portafoglio ordini tramite Interactive
        Brokers, il che significa che il vero prezzo è sconosciuto
        fino all&#039;esecuzione.

        Tuttavia, può essere stimato tramite il prezzo medio come
        differenza tra bid e ask. Una volta calcolato il valore di mercato,
        questo consente il calcolo del profitto realizzato e non realizzato,
        e la perdita per qualsiasi transazione.
        &quot;&quot;&quot;
        midpoint = (bid+ask)/Decimal(&quot;2.0&quot;)
        self.market_value = (
            self.quantity * midpoint
        ).quantize(TWOPLACES)

        self.unrealised_pnl = (
            self.market_value - self.cost_basis
        ).quantize(TWOPLACES)
        
        self.realised_pnl = (
            self.market_value + self.net_incl_comm
        )

    def transact_shares(self, action, quantity, price, commission):
        &quot;&quot;&quot;
        Calcola le rettifiche alla classe Position che si verificano
        una volta acquistate e vendute nuove azioni.

        Si preoccupa di aggiornare la media e il totale degli 
        acquisti/vendite, calcola i costi base e PnL,
        come effettuato tramite Interactive Brokers TWS.       
        &quot;&quot;&quot;
        prev_quantity = self.quantity
        prev_commission = self.total_commission

        self.total_commission += commission

        if action == &quot;BOT&quot;:
            self.avg_bot = (
                (self.avg_bot*self.buys + price*quantity)/(self.buys + quantity)
            ).quantize(FIVEPLACES)
            if self.action != &quot;SLD&quot;:
                self.avg_price = (
                    (
                        self.avg_price*self.buys +
                        price*quantity+commission
                    )/(self.buys + quantity)
                ).quantize(FIVEPLACES)
            self.buys += quantity
            self.total_bot = (self.buys * self.avg_bot).quantize(TWOPLACES)

        else:
            self.avg_sld = (
                (self.avg_sld*self.sells + price*quantity)/(self.sells + quantity)
            ).quantize(FIVEPLACES)
            if self.action != &quot;BOT&quot;:
                self.avg_price = (
                    (
                        self.avg_price*self.sells +
                        price*quantity-commission
                    )/(self.sells + quantity)
                ).quantize(FIVEPLACES)
            self.sells += quantity
            self.total_sld = (self.sells * self.avg_sld).quantize(TWOPLACES)

        # Aggiornamento valori netti, inclusi commissioni
        self.net = self.buys - self.sells
        self.quantity = self.net
        self.net_total = (
            self.total_sld - self.total_bot
        ).quantize(TWOPLACES)
        self.net_incl_comm = (
            self.net_total - self.total_commission
        ).quantize(TWOPLACES)

        # Aggiornamento prezzo medio e costi base
        self.cost_basis = (
            self.quantity * self.avg_price
        ).quantize(TWOPLACES)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-266500c elementor-widget elementor-widget-text-editor" data-id="266500c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Da notare che l&#8217;intero progetto fa un uso estensivo del modulo </span><a href="https://docs.python.org/3.5/library/decimal.html"><span>Decimal</span></a><span> . Questa è una requisito fondamentale nelle applicazioni finanziarie, altrimenti si finisce per causare errori di arrotondamento significativi a causa della </span><a href="https://floating-point-gui.de/"><span>matematica nella gestione in virgola mobile</span></a><span> .</span></p><p><span>Abbiamo quindi introdotto due variabili, </span><code>TWOPLACES </code><span>e </span><code>FIVEPLACES</code><span>, che sono utilizzate successivamente per definire il livello di precisione desiderato per l&#8217;arrotondamento nei calcoli.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0783526 elementor-widget elementor-widget-bdt-source-code" data-id="0783526" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>TWOPLACES = Decimale ( &quot;0,01&quot; ) 
CINQUE POSTI = Decimale ( &quot;0,00001&quot; )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-ed7cc74 elementor-widget elementor-widget-text-editor" data-id="ed7cc74" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>La classe </span><code>Position</code><span> richiede un&#8217;azione di transazione: &#8220;Acquista&#8221; o &#8220;Vendi&#8221;. Abbiamo utilizzato i codici </span><strong><span>BOT</span></strong><span> e </span><strong><span>SLD</span></strong><span> di <a href="https://www.interactivebrokers.com">Interactive Brokers</a> in tutto il codice. Inoltre, la classe </span><code>Position</code> <span>richiede un simbolo &#8216;ticker&#8217;, una quantità da negoziare, il prezzo di acquisto o di vendita e la commissione.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-db813b7 elementor-widget elementor-widget-bdt-source-code" data-id="db813b7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>
class Position(object):
    def __init__(
        self, action, ticker, init_quantity,
        init_price, init_commission,
        bid, ask
    ):
        &quot;&quot;&quot;
        Imposta il &quot;conto&quot; iniziale della posizione che è zero per
        la maggior parte degli item, ad eccezione dell&#039;iniziale
        acquisto / vendita.

        Quindi calcola i valori iniziali e infine aggiorna il
        valore di mercato della transazione.
        &quot;&quot;&quot;
        self.action = action
        self.ticker = ticker
        self.quantity = init_quantity
        self.init_price = init_price
        self.init_commission = init_commission
</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-d951a75 elementor-widget elementor-widget-text-editor" data-id="d951a75" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Inoltre la classe </span><code>Position</code> <span>tiene traccia di poche altre metriche, che rispecchiano pienamente quelli gestiti da Interactive Brokers. In particolare si gestisce il PnL, la quantità di acquisti e vendite, il prezzo medio di acquisto e il prezzo medio di vendita, il prezzo di acquisto totale e il prezzo di vendita totale, nonché la commissione totale applicata fino ad oggi.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-86f7c97 elementor-widget elementor-widget-bdt-source-code" data-id="86f7c97" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>        self.realised_pnl = Decimal(&quot;0.00&quot;)
        self.unrealised_pnl = Decimal(&quot;0.00&quot;)

        self.buys = Decimal(&quot;0&quot;)
        self.sells = Decimal(&quot;0&quot;)
        self.avg_bot = Decimal(&quot;0.00&quot;)
        self.avg_sld = Decimal(&quot;0.00&quot;)
        self.total_bot = Decimal(&quot;0.00&quot;)
        self.total_sld = Decimal(&quot;0.00&quot;)
        self.total_commission = init_commission</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2108122 elementor-widget elementor-widget-text-editor" data-id="2108122" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>La classe </span><code>Position</code><span> è stata strutturata in questo modo perché è molto difficile definire l&#8217;idea di un &#8220;trade&#8221;. Ad esempio, immaginiamo di eseguire le seguenti transazioni:</span></p><ul><li><strong><span>Giorno 1</span></strong><span> : acquisto di 100 azioni di GOOG. Totale 100.</span></li><li><strong><span>Giorno 2</span></strong><span> : acquisto di 200 azioni di GOOG. Totale 300.</span></li><li><strong><span>Giorno 3</span></strong><span> &#8211; Vendita di 400 azioni di GOOG. Totale -100.</span></li><li><strong><span>Giorno 4</span></strong><span> &#8211; Acquisto di 200 azioni di GOOG. Totale 100.</span></li><li><strong><span>Giorno 5</span></strong><span> &#8211; Vendita di 100 azioni di GOOG. Totale 0.</span></li></ul><p><span>Questo costituisce un &#8220;round trip&#8221;. Come possiamo determinare il profitto in questo caso? Calcoliamo il profitto su ogni parte della transazione? Calcoliamo il profitto solo quando la quantità torna a zero?</span></p><p><span>Questi problemi vengono risolti utilizzando un PnL realizzato e non realizzato. In questo modo possiamo conoscere in ogni momento quanto abbiamo guadagnao </span><em><span>fino ad oggi</span></em><span> e quanto </span><em><span>potremmo guadagnare,</span></em><span> tenendo traccia di questi due valori. A livello di </span><code>Portfolio</code><span> possiamo semplicemente sommare questi valori e calcolare valore totale del PnL in qualsiasi momento.</span></p><p><span>Infine, nel metodo di inizializzazione </span><code>__init__</code><span>, calcoliamo i valori iniziali e aggiorniamo il valore di mercato con l&#8217;ultimo bid/ask:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-56c4c4f elementor-widget elementor-widget-bdt-source-code" data-id="56c4c4f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>        self._calculate_initial_value()
        self.update_market_value(bid, ask)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4ba4468 elementor-widget elementor-widget-text-editor" data-id="4ba4468" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il metodo </span><code>_calculate_initial_value</code> <span>è il seguente:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f93e567 elementor-widget elementor-widget-bdt-source-code" data-id="f93e567" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def _calculate_initial_value(self):
        &quot;&quot;&quot;
        A seconda che l&#039;azione fosse un acquisto o una vendita (&quot; BOT &quot;
        o &quot; SLD &quot;) si calcola il costo medio di acquisto, il costo totale
        di acquisto, prezzo medio e costo basi.

        Infine, calcola il totale netto con e senza commissioni.

        &quot;&quot;&quot;

        if self.action == &quot;BOT&quot;:
            self.buys = self.quantity
            self.avg_bot = self.init_price.quantize(FIVEPLACES)
            self.total_bot = (self.buys * self.avg_bot).quantize(TWOPLACES)
            self.avg_price = (
                (self.init_price * self.quantity + self.init_commission)/self.quantity
            ).quantize(FIVEPLACES)
            self.cost_basis = (
                self.quantity * self.avg_price
            ).quantize(TWOPLACES)
        else:  # action == &quot;SLD&quot;
            self.sells = self.quantity
            self.avg_sld = self.init_price.quantize(FIVEPLACES)
            self.total_sld = (self.sells * self.avg_sld).quantize(TWOPLACES)
            self.avg_price = (
                (self.init_price * self.quantity - self.init_commission)/self.quantity
            ).quantize(FIVEPLACES)
            self.cost_basis = (
                -self.quantity * self.avg_price
            ).quantize(TWOPLACES)
        self.net = self.buys - self.sells
        self.net_total = (self.total_sld - self.total_bot).quantize(TWOPLACES)
        self.net_incl_comm = (self.net_total - self.init_commission)
                                  .quantize(TWOPLACES)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-36a7edb elementor-widget elementor-widget-text-editor" data-id="36a7edb" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Questo metodo esegue i calcoli iniziali all&#8217;apertura di una nuova posizione. Per le azioni  &#8220;BOT&#8221; (acquisti), il numero di acquisti viene incrementato, vengono calcolati i valori medi e totali acquistati, così come il </span><em><span>prezzo</span></em><span> medio della posizione. La </span><em><span>costo base</span></em><span> è calcolato come la quantità corrente moltiplicata per il prezzo medio pagato, che corrisponde al &#8220;prezzo totale pagato finora&#8221;. Inoltre, vengono calcolati anche la quantità netta, il totale netto e la commissione netta.</span></p><p><span>Il metodo successivo è </span><code>update_market_value</code><span>. Questo è un metodo complicato da implementare poiché si basa su un approccio specifico per il calcolo del &#8220;valore di mercato&#8221;. Non esiste una scelta corretta, poiché non esiste il &#8220;valore di mercato&#8221;. Ci sono però alcuni utili approcci:</span></p><ul><li><span><strong>Punto medio</strong> &#8211; Una scelta comune è prendere il punto medio dello spread denaro-lettera. Questo prende i prezzi di offerta e domanda più alti del portafoglio ordini (per un particolare exchange) e calcola la media.</span></li><li><strong>Ultimo prezzo</strong><span><strong> negoziato</strong> &#8211; Questo è l&#8217;ultimo prezzo a cui è stato scambiato un titolo. Calcolarlo è complicato perché lo scambio potrebbe essere avvenuto su più prezzi (lotti diversi a prezzi diversi). Quindi potrebbe essere una media ponderata.</span></li><li><strong><span>Bid o Ask</span></strong><span> &#8211; A seconda del lato della transazione (cioè un acquisto o una vendita), come indicazione si può utilizzare il prezzo bid o ask più alto.</span></li></ul><p><span>Tuttavia, nessuno di questi prezzi sarà probabilmente quello applicato nella realtà. Le dinamiche del portafoglio ordini, lo slippage e l&#8217;impatto del mercato faranno sì che il prezzo di vendita reale differisca dal bid / ask attualmente quotato.</span></p><p><span>Nel seguente metodo abbiamo optato per il calcolo del punto medio per fornire un senso di &#8220;valore di mercato&#8221;. È importante sottolineare, tuttavia, che questo valore può trovare la sua strada nei calcoli della gestione del rischio e del dimensionamento della posizione, quindi è necessario assicurarsi di essere soddisfatti di come viene calcolato e modificarlo di conseguenza se si desidera utilizzarlo nei tuoi motori di trading.</span></p><p><span>Una volta calcolato il valore di mercato permette il successivo calcolo del PnL non realizzato e realizzato della posizione:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0f691f3 elementor-widget elementor-widget-bdt-source-code" data-id="0f691f3" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def update_market_value(self, bid, ask):
        &quot;&quot;&quot;
        Il valore di mercato è difficile da calcolare davo che abbiamo accesso
        alla parte superiore del portafoglio ordini tramite Interactive
        Brokers, il che significa che il vero prezzo è sconosciuto
        fino all&#039;esecuzione.

        Tuttavia, può essere stimato tramite il prezzo medio come
        differenza tra bid e ask. Una volta calcolato il valore di mercato,
        questo consente il calcolo del profitto realizzato e non realizzato,
        e la perdita per qualsiasi transazione.
        &quot;&quot;&quot;
        midpoint = (bid+ask)/Decimal(&quot;2.0&quot;)
        self.market_value = (
            self.quantity * midpoint
        ).quantize(TWOPLACES)

        self.unrealised_pnl = (
            self.market_value - self.cost_basis
        ).quantize(TWOPLACES)

        self.realised_pnl = (
            self.market_value + self.net_incl_comm
        )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-75706aa elementor-widget elementor-widget-text-editor" data-id="75706aa" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il metodo finale è <code>transact_shares</code>. Questo è il metodo chiamato dalla classe <code>Portfolio</code> per eseguire effettivamente una transazione. Non riportiamo l&#8217;intero il metodo, che si può trovare nel listato precedente e su <a href="https://github.com/datatrading-info/DataTrader/blob/main/datatrader/position.py">Github</a>, ma ci concentriamo su alcune sezioni importanti.</p><p>Nel listato di codice riportato di seguito si evidenzia che se l&#8217;azione è un acquisto (&#8220;BOT&#8221;), il prezzo medio di acquisto viene ricalcolato. Se l&#8217;azione originale era anch&#8217;essa un acquisto, il prezzo medio viene necessariamente modificato. Il totale degli acquisti viene aumentato della nuova quantità e il prezzo totale di acquisto viene modificato. La logica è simile per il lato vendita / &#8220;SLD&#8221;:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0b01a46 elementor-widget elementor-widget-bdt-source-code" data-id="0b01a46" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>      if action == &quot;BOT&quot;:
            self.avg_bot = (
                (self.avg_bot*self.buys + price*quantity)/(self.buys + quantity)
            ).quantize(FIVEPLACES)
            if self.action != &quot;SLD&quot;:
                self.avg_price = (
                    (
                        self.avg_price*self.buys +
                        price*quantity+commission
                    )/(self.buys + quantity)
                ).quantize(FIVEPLACES)
            self.buys += quantity
            self.total_bot = (self.buys * self.avg_bot).quantize(TWOPLACES)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9e72dcc elementor-widget elementor-widget-text-editor" data-id="9e72dcc" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Infine, i tutti valori netti vengono adeguati. </span><span>I calcoli sono relativamente semplici e possono essere seguiti nel seguente listato. </span><span>Si noti che sono tutti i valori sono arrotondati a due cifre decimali:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3417b63 elementor-widget elementor-widget-bdt-source-code" data-id="3417b63" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>        # Aggiustamento valori netti, incluse le commissioni
        self.net = self.buys - self.sells
        self.quantity = self.net
        self.net_total = (
            self.total_sld - self.total_bot
        ).quantize(TWOPLACES)
        self.net_incl_comm = (
            self.net_total - self.total_commission
        ).quantize(TWOPLACES)

        # Aggiustamento dei prezzi medi e i costi base
        self.cost_basis = (
            self.quantity * self.avg_price
        ).quantize(TWOPLACES)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9424661 elementor-widget elementor-widget-text-editor" data-id="9424661" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Questo conclude la spiegazione del codice implementato per la classe </span><code>Position</code><span>. Fornisce un robusto meccanismo per gestire il calcolo della posizione e la memorizzazione.</span></p><p><span>Per completezza puoi trovare il codice completo della classe </span><code>Position</code> <span>su Github in </span><span>position.py</span><span> .</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-84708f4 elementor-widget elementor-widget-heading" data-id="84708f4" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">position_test.py</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-72c7c51 elementor-widget elementor-widget-text-editor" data-id="72c7c51" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per testare i calcoli all&#8217;interno delle classe <code>Position</code> abbiamo creato i seguenti unit test, confrontandoli con transazioni simili effettuate all&#8217;interno di Interactive Brokers. E&#8217; sicuramente possibile rilevare in futuro  nuovi casi limite e bug che richiederanno la correzione degli errori, ma questi unit test forniscono un elevato livello di attendibilità nei risultati futuri.</p><p>Il listato completo del file <code>position_test.py</code> è il seguente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c731e95 elementor-widget elementor-widget-bdt-source-code" data-id="c731e95" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
import unittest

from position import Position


class TestRoundTripXOMPosition(unittest.TestCase):
    &quot;&quot;&quot;
    Prova un trade round-trip per Exxon-Mobil dove il trade iniziale
    è un acquisto / long di 100 azioni di XOM, al prezzo di
    $ 74,78, con una commissione di $ 1,00.
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Imposta l&#039;oggetto Position che memorizzerà il PnL.
        &quot;&quot;&quot;
        self.position = Position(
            &quot;BOT&quot;, &quot;XOM&quot;, Decimal(&#039;100&#039;),
            Decimal(&quot;74.78&quot;), Decimal(&quot;1.00&quot;),
            Decimal(&#039;74.78&#039;), Decimal(&#039;74.80&#039;)
        )

    def test_calculate_round_trip(self):
        &quot;&quot;&quot;
        Dopo il successivo acquisto, si effettuano altri due acquisti / long
        e poi chiudere la posizione con due ulteriori vendite / short.

        I seguenti prezzi sono stati confrontati con quelli calcolati
        tramite Interactive Brokers &#039;Trader Workstation (TWS).
        &quot;&quot;&quot;
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;100&#039;), Decimal(&#039;74.63&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;250&#039;), Decimal(&#039;74.620&#039;), Decimal(&#039;1.25&#039;)
        )
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;200&#039;), Decimal(&#039;74.58&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;250&#039;), Decimal(&#039;75.26&#039;), Decimal(&#039;1.25&#039;)
        )
        self.position.update_market_value(Decimal(&quot;77.75&quot;), Decimal(&quot;77.77&quot;))

        self.assertEqual(self.position.action, &quot;BOT&quot;)
        self.assertEqual(self.position.ticker, &quot;XOM&quot;)
        self.assertEqual(self.position.quantity, Decimal(&quot;0&quot;))

        self.assertEqual(self.position.buys, Decimal(&quot;450&quot;))
        self.assertEqual(self.position.sells, Decimal(&quot;450&quot;))
        self.assertEqual(self.position.net, Decimal(&quot;0&quot;))
        self.assertEqual(self.position.avg_bot, Decimal(&quot;74.65778&quot;))
        self.assertEqual(self.position.avg_sld, Decimal(&quot;74.95778&quot;))
        self.assertEqual(self.position.total_bot, Decimal(&quot;33596.00&quot;))
        self.assertEqual(self.position.total_sld, Decimal(&quot;33731.00&quot;))
        self.assertEqual(self.position.net_total, Decimal(&quot;135.00&quot;))
        self.assertEqual(self.position.total_commission, Decimal(&quot;5.50&quot;))
        self.assertEqual(self.position.net_incl_comm, Decimal(&quot;129.50&quot;))

        self.assertEqual(self.position.avg_price, Decimal(&quot;74.665&quot;))
        self.assertEqual(self.position.cost_basis, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.market_value, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.unrealised_pnl, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.realised_pnl, Decimal(&quot;129.50&quot;))


class TestRoundTripPGPosition(unittest.TestCase):
    &quot;&quot;&quot;
    Prova uno trade round-trip per Proctor &amp; Gamble dove il trade iniziale
    è una vendita / short di 100 azioni di PG, al prezzo di
    $ 77,69, con una commissione di $ 1,00.
    &quot;&quot;&quot;

    def setUp(self):
        self.position = Position(
            &quot;SLD&quot;, &quot;PG&quot;, Decimal(&#039;100&#039;),
            Decimal(&quot;77.69&quot;), Decimal(&quot;1.00&quot;),
            Decimal(&#039;77.68&#039;), Decimal(&#039;77.70&#039;)
        )

    def test_calculate_round_trip(self):
        &quot;&quot;&quot;
        Dopo la successiva vendita, eseguire altre due vendite / cortometraggi
        e poi chiudere la posizione con altri due acquisti / long.

        I seguenti prezzi sono stati confrontati con quelli calcolati
        tramite Interactive Brokers &#039;Trader Workstation (TWS).
        &quot;&quot;&quot;
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;100&#039;), Decimal(&#039;77.68&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;50&#039;), Decimal(&#039;77.70&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;100&#039;), Decimal(&#039;77.77&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;150&#039;), Decimal(&#039;77.73&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.update_market_value(Decimal(&quot;77.72&quot;), Decimal(&quot;77.72&quot;))

        self.assertEqual(self.position.action, &quot;SLD&quot;)
        self.assertEqual(self.position.ticker, &quot;PG&quot;)
        self.assertEqual(self.position.quantity, Decimal(&quot;0&quot;))

        self.assertEqual(self.position.buys, Decimal(&quot;250&quot;))
        self.assertEqual(self.position.sells, Decimal(&quot;250&quot;))
        self.assertEqual(self.position.net, Decimal(&quot;0&quot;))
        self.assertEqual(self.position.avg_bot, Decimal(&quot;77.746&quot;))
        self.assertEqual(self.position.avg_sld, Decimal(&quot;77.688&quot;))
        self.assertEqual(self.position.total_bot, Decimal(&quot;19436.50&quot;))
        self.assertEqual(self.position.total_sld, Decimal(&quot;19422.00&quot;))
        self.assertEqual(self.position.net_total, Decimal(&quot;-14.50&quot;))
        self.assertEqual(self.position.total_commission, Decimal(&quot;5.00&quot;))
        self.assertEqual(self.position.net_incl_comm, Decimal(&quot;-19.50&quot;))

        self.assertEqual(self.position.avg_price, Decimal(&quot;77.67600&quot;))
        self.assertEqual(self.position.cost_basis, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.market_value, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.unrealised_pnl, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.realised_pnl, Decimal(&quot;-19.50&quot;))


if __name__ == &quot;__main__&quot;:
    unittest.main()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-a9a0756 elementor-widget elementor-widget-text-editor" data-id="a9a0756" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Le importazioni per questo modulo sono semplici. Importiamo ancora una volta la classe </span><code>Decimal</code><span>, ma aggiungiamo anche il modulo </span><a href="https://docs.python.org/3.5/library/unittest.html"><span>unittest</span></a><span> e la stessa classe</span> <code>Position</code><span>, poiché è in fase di test:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-706e32b elementor-widget elementor-widget-bdt-source-code" data-id="706e32b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from decimal import Decimal
import unittest

from position import Position</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-73cff4a elementor-widget elementor-widget-text-editor" data-id="73cff4a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Per coloro che non hanno ancora visto uno unit test di Python, l&#8217;idea di base è quella di creare una classe chiamata </span><code>TestXXXX</code> <span>che eredita la classe </span><code>unittest.TestCase</code><span>, come riportato nel successivo listato. La classe espone un metodo</span> <code>setUp</code> <span>che consente di utilizzare qualsiasi dato o stato per il resto di </span><em><span>quel particolare test</span></em><span> . Ecco un esempio di configurazione di un unit test per un trade &#8220;round-trip&#8221; per Exxon-Mobil / XOM:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fc6e23e elementor-widget elementor-widget-bdt-source-code" data-id="fc6e23e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class TestRoundTripXOMPosition(unittest.TestCase):
    &quot;&quot;&quot;
    Prova un trade round-trip per Exxon-Mobil dove il trade iniziale
    è un acquisto / long di 100 azioni di XOM, al prezzo di
    $ 74,78, con una commissione di $ 1,00.
    &quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;
        Imposta l&#039;oggetto Position che memorizzerà il PnL.
        &quot;&quot;&quot;
        self.position = Position(
            &quot;BOT&quot;, &quot;XOM&quot;, Decimal(&#039;100&#039;),
            Decimal(&quot;74.78&quot;), Decimal(&quot;1.00&quot;),
            Decimal(&#039;74.78&#039;), Decimal(&#039;74.80&#039;)
        )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-3c08ba0 elementor-widget elementor-widget-text-editor" data-id="3c08ba0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Si noti che </span><code>self.position</code><span>è impostata per essere una nuova classe </span><code>Position</code><span>, in cui vengono acquistate 100 azioni di XOM per 74,78 USD.</span></p><p><span>I successivi metodi, nel formato di </span><code>test_XXXX</code><span>, consentono l&#8217;unit test dei vari aspetti del sistema. In questo particolare metodo, dopo l&#8217;acquisto iniziale, vengono effettuati altri due acquisti long e infine due vendite per portare a zero la posizione:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2464de0 elementor-widget elementor-widget-bdt-source-code" data-id="2464de0" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def test_calculate_round_trip(self):
        &quot;&quot;&quot;
        Dopo il successivo acquisto, si effettuano altri due acquisti / long
        e poi chiudere la posizione con due ulteriori vendite / short.

        I seguenti prezzi sono stati confrontati con quelli calcolati
        tramite Interactive Brokers &#039;Trader Workstation (TWS).
        &quot;&quot;&quot;
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;100&#039;), Decimal(&#039;74.63&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;BOT&quot;, Decimal(&#039;250&#039;), Decimal(&#039;74.620&#039;), Decimal(&#039;1.25&#039;)
        )
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;200&#039;), Decimal(&#039;74.58&#039;), Decimal(&#039;1.00&#039;)
        )
        self.position.transact_shares(
            &quot;SLD&quot;, Decimal(&#039;250&#039;), Decimal(&#039;75.26&#039;), Decimal(&#039;1.25&#039;)
        )
        self.position.update_market_value(Decimal(&quot;77.75&quot;), Decimal(&quot;77.77&quot;))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-9f0e719 elementor-widget elementor-widget-text-editor" data-id="9f0e719" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><code>transact_shares </code>viene chiamato quattro volte e infine il valore di mercato viene aggiornato da <code>update_market_value</code>. A questo punto <code>self.position </code>memorizza tutti i vari calcoli ed è pronto per essere testato, utilizzando il metodo <code>assertEqual</code> derivato dalla classe <code>unittest.TestCase</code>. Si noti come tutte le varie proprietà della classe <code>Position</code> vengono verificate rispetto a valori calcolati esternamente (in questo caso da Interactive Brokers TWS):</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-da09ecb elementor-widget elementor-widget-bdt-source-code" data-id="da09ecb" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>        self.assertEqual(self.position.action, &quot;BOT&quot;)
        self.assertEqual(self.position.ticker, &quot;XOM&quot;)
        self.assertEqual(self.position.quantity, Decimal(&quot;0&quot;))

        self.assertEqual(self.position.buys, Decimal(&quot;450&quot;))
        self.assertEqual(self.position.sells, Decimal(&quot;450&quot;))
        self.assertEqual(self.position.net, Decimal(&quot;0&quot;))
        self.assertEqual(self.position.avg_bot, Decimal(&quot;74.65778&quot;))
        self.assertEqual(self.position.avg_sld, Decimal(&quot;74.95778&quot;))
        self.assertEqual(self.position.total_bot, Decimal(&quot;33596.00&quot;))
        self.assertEqual(self.position.total_sld, Decimal(&quot;33731.00&quot;))
        self.assertEqual(self.position.net_total, Decimal(&quot;135.00&quot;))
        self.assertEqual(self.position.total_commission, Decimal(&quot;5.50&quot;))
        self.assertEqual(self.position.net_incl_comm, Decimal(&quot;129.50&quot;))

        self.assertEqual(self.position.avg_price, Decimal(&quot;74.665&quot;))
        self.assertEqual(self.position.cost_basis, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.market_value, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.unrealised_pnl, Decimal(&quot;0.00&quot;))
        self.assertEqual(self.position.realised_pnl, Decimal(&quot;129.50&quot;))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-3a627f7 elementor-widget elementor-widget-text-editor" data-id="3a627f7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Quando si eseguo questo specifico script Python all&#8217;interno di un ambiente virtuale (sotto la riga di comando in Ubuntu), ricevo il seguente output:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1674164 elementor-widget elementor-widget-bdt-source-code" data-id="1674164" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-markup-templating">
            <code>(datatrader)datatrading@desktop:~/sites/datatrader/approot/position$ python position_test.py 
..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-61ffbf5 elementor-widget elementor-widget-text-editor" data-id="61ffbf5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Si noti che ci sono </span><em><span>due</span></em><span> test all&#8217;interno del file, quindi si può dare un&#8217;occhiata al secondo test presente nel listato completo in modo da familiarizzare con i calcoli.</span></p><p><span>Chiaramente ci sono molti altri test che potrebbero essere effettuati sulla classe </span><code>Position</code><span>. In questa fase possiamo essere rassicurati che gestisce le funzionalità di base per detenere una posizione azionaria. Col tempo, la classe verrà probabilmente ampliata per far fronte a strumenti forex, futures e opzioni, consentendo di attuare una sofisticata strategia di investimento all&#8217;interno di un portafoglio.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a478079 elementor-widget elementor-widget-heading" data-id="a478079" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Prossimi Passi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-d772582 elementor-widget elementor-widget-text-editor" data-id="d772582" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nei seguenti articoli esamineremo le classi <code>Portfolio </code>e <code>PortfolioHandler</code>. Entrambi sono già stati codificati e testati. Se si desidera &#8220;saltare avanti&#8221; e vedere il codice, puoi dare un&#8217;occhiata al repository completo di DataTrader qui: <a href="https://github.com/datatrading-info/DataTrader">github.com/datatrading-info/DataTrader</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-gestione-delle-posizioni/">DataTrader – Trading Algoritmico Avanzato: Gestione delle Posizioni</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DataTrader &#8211; Trading Algoritmico Avanzato: Introduzione</title>
		<link>https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sun, 03 Jun 2018 07:22:00 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial DataTrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2514</guid>

					<description><![CDATA[<p>Fino ad oggi su DataTrading abbiamo considerato due principali motori di backtesting quantitativo e di trading live. Il primo è derivato dalla serie Backtesting Event-Drive.  Il secondo è un motore di trading live e backtesting sul Forex, DTForex, che si collega all&#8217;API del broker OANDA. In questo articolo introduciamo una versione più &#8220;aggiornata&#8221; della serie di &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/"> <span class="screen-reader-text">DataTrader &#8211; Trading Algoritmico Avanzato: Introduzione</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/">DataTrader &#8211; Trading Algoritmico Avanzato: Introduzione</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2514" class="elementor elementor-2514">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-215826a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="215826a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-7b9f208" data-id="7b9f208" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-06741ac elementor-widget elementor-widget-text-editor" data-id="06741ac" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Fino ad oggi su DataTrading abbiamo considerato due principali motori di backtesting quantitativo e di trading live. Il primo è derivato dalla serie <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">Backtesting Event-Drive</a>.  Il secondo è un motore di trading live e backtesting sul Forex, <a href="https://datatrading.info/dtforex-1-trading-automatico-sul-forex-tramite-le-api-di-oanda/">DTForex</a>, che si collega all&#8217;<a href="http://developer.oanda.com/">API del broker OANDA</a>.</p><p>In questo articolo introduciamo una versione più &#8220;aggiornata&#8221; della serie di backtesting guidata dagli eventi e/o del &#8220;DTForex&#8221; che funzioni su altre classi di asset. La funzionalità principale che vogliamo introdurre è il collegamento con <a href="https://www.interactivebrokers.com/">Interactive Brokers</a>. E&#8217; quindi arrivato il momento di aggiornare l&#8217;infrastruttura di trading che utilizziamo.</p><p>Per questi motivi abbiamo deciso di scrivere una nuova serie di articoli su come progettare e costruire un&#8217;infrastruttura end-to-end che implementi un portafoglio completo e un sistema di gestione degli ordini, compreso un ambiente di backtesting/ricerca, la possibilità di deploy su server remoti ed esecuzione algoritmica. Inoltre il sistema dovrà essere multi-asset, ma è generalmente preferibile iniziare con un singola asset class per ridurre al minimo l&#8217;eccessiva capacità di configurazione.</p><p>Inizieremo con le azioni / ETF statunitensi scambiati con Interactive Brokers, con frequenza giornaliera, poiché questa è spesso la richiesta più popolare.</p><p>In particolare, il risultato di questa serie di articoli sarà la mia nuova infrastruttura di trading personale, e del progetto DataTrading, quindi avrò molto interesse personale nell&#8217;assicurarmi che sia robusta, affidabile e altamente efficiente! Documenterò il processo in modo &#8220;end-to-end&#8221; in modo che sia possibile replicare completamente i risultati.</p><p>In questo modo qualsiasi articolo futuro di questo sito che discuta le prestazioni di una strategia di trading sarà basato su questa libreria, consentendo a chiunque di replicare <em>completamente</em> i risultati purché si utilizzi: </p><ul><li>a) gli stessi identici dati storici elaborati</li><li>b) un insieme identico di seed casuali a qualsiasi modello stocastico utilizzato all&#8217;interno del codice. </li></ul><p>Ovviamente vedremo come assicurarci che questi due criteri siano soddisfatti!</p><p>Anche in questo caso, come in precedenza, renderò disponibile il software su <a href="https://github.com/">GitHub</a> <span style="color: var( --e-global-color-text ); font-size: 1rem;">con una licenza open source in stile MIT open source</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">, insieme a tutti gli script e ai file di configurazione. In questo modo sarà possibile progettare il vostro sistema usando il mio come modello, o di iniziare a sviluppare strategie sapendo che avrete una solida libreria che farà il &#8220;lavoro sporco&#8221; per voi.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1e6b8c8 elementor-widget elementor-widget-heading" data-id="1e6b8c8" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Considerazioni sul Design del Sistema</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-b4f3be9 elementor-widget elementor-widget-text-editor" data-id="b4f3be9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>L&#8217;obiettivo finale di questo progetto è costruire un portafoglio e un sistema di gestione degli ordini completamente open source, ma di livello professionale, pronto per la produzione, con livelli di gestione del rischio tra le posizioni, i portafogli e l&#8217;infrastruttura nel suo insieme.</span></p><p><span>Sarà automatizzato end-to-end, il che significa che è necessario un intervento umano minimo affinché il sistema possa operare una volta impostato &#8220;live&#8221;. È impossibile eliminare completamente l&#8217;intervento umano, soprattutto quando si tratta di input di qualità dei dati (ad esempio in caso di tick errati), ma è certamente possibile prevedere che il sistema funzioni in modo automatizzato per la maggior parte del tempo.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-232a8ae elementor-widget elementor-widget-heading" data-id="232a8ae" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Considerazioni sul Trading Algoritmico</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-e0cf64e elementor-widget elementor-widget-text-editor" data-id="e0cf64e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il sistema rispecchierà l&#8217;infrastruttura che potrebbe essere trovata in un software commerciale o nei sistemi utilizzati da piccolo fondo quantistico o dal team quantistico di un trading desk. Sarà altamente modulare e liberamente configurabile. I componenti principali sono l&#8217;archivio dati (l&#8217;anagrafica dei titoli), il generatore di segnali, sistema di gestione portafoglio / ordini, il livello di rischio e l&#8217;interfaccia verso i broker.</p><p>Come descritto negli <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">articoli precedenti</a>, questi componenti tendono a sovrapporsi ed essere accorpati, ma di seguito è riportato un elenco di componenti di &#8220;livello istituzionale&#8221; attorno ai quali desideriamo costruire il sistema:</p><ul><li><strong>Integrazione con il fornitore di dati</strong> : il primo componente fondamentale prevede l&#8217;interazione con uno o più fornitori di dati, solitamente tramite una qualche forma di API. Il sistema supporterà inizialmente l&#8217;acquisizione dei dati tramite <a href="https://www.quandl.com/">Quandl</a> , <a href="http://www.iqfeed.net/">DTN IQFeed</a> e <a href="https://www.interactivebrokers.com/">Interactive Brokers</a>.</li><li><strong>Importazione e pulizia dei dati</strong>: tra l&#8217;archiviazione e il download dei dati è necessario un livello di filtraggio / pulizia che memorizzerà i dati solo se superano determinati controlli. Contrassegnerà i dati &#8220;cattivi&#8221; e attiva notifiche se i dati non sono disponibili.</li><li><strong>Memorizzazione dei dati sui prezzi</strong> : è necessario creare un database principale dei prezzi intraday, archiviando i simboli e i valori dei prezzi ottenuti da un broker o un fornitore di dati.</li><li><strong>Memorizzazione dei dati di trading</strong> &#8211; Tutti gli ordini, le operazioni e gli stati del portafoglio devono essere archiviati nel tempo. A questo scopo si prevede di usare una forma di serializzazione / persistenza degli oggetti, come la libreria <a href="https://docs.python.org/3/library/pickle.html">pickle</a> di Python .</li><li><strong>Archiviazione dei dati di configurazione</strong> : è necessario memorizzare in un database le informazioni di configurazione dipendenti dal tempo con un riferimento storico, in formato tabulare o, ancora una volta, in formato pickle.</li><li><strong>Ambiente di ricerca / backtesting</strong> &#8211; il sistema deve prevede un ambiente di ricerca / backtesting collegato al database dei prezzi e utilizzerà una logica avanzata per simulare il flusso di esecuzione degli ordini a mercato e quindi generare backtest realistici.</li><li><strong>Generazione dei segnali</strong> &#8211; Abbiamo già descritto gli approcci principali al machine learning, all&#8217;analisi di serie temporali e alle statistiche bayesiane. Possiamo implementare queste tecniche per generare i segnali e produrre raccomandazioni di trading per il gestore del portafoglio.</li><li><strong>Portfolio / Order Management</strong> &#8211; Il &#8220;cuore&#8221; del sistema è il portfolio e il sistema di gestione degli ordini (OMS) che riceve i segnali del generatore e li utilizza come &#8220;raccomandazioni&#8221; per la costruzione degli ordini. L&#8217;OMS comunica direttamente con la componente di gestione del rischio per determinare come devono essere costruiti questi ordini.</li><li><strong>Gestione del rischio</strong> &#8211; Il gestore del rischio fornisce un meccanismo di &#8220;veto&#8221; o di modifica per l&#8217;OMS, in modo da considerare/includere i specifici pesi settoriali, i vincoli di leva finanziaria, la disponibilità di margine del broker e i limiti di volume medio giornaliero. Il livello di rischio prevede anche la gestione della &#8220;copertura ombrello&#8221;, fornendo al portafoglio la capacità di copertura a livello di mercato o di settore.</li><li><strong>Interfaccia al broker</strong>: l&#8217;interfaccia consiste nel codice di connessione verso le API di un broker (in questo caso Interactive Brokers) e nell&#8217;implementazione di più tipi di ordine come market, limit, stop, ecc.</li><li><strong>Esecuzione algoritmica</strong> : implementa e utilizza algoritmi di esecuzione automatizzata al fine di mitigare gli effetti dell&#8217;impatto sul mercato.</li><li><strong>Performance e P&amp;L</strong> &#8211; L&#8217;analisi delle performance è fondamentalmente per rispondere alla domanda &#8220;Quanto ho guadagnato?&#8221;. In realtà non è una domanda così semplice a cui rispondere! Descriveremo in modo approfondito come contabilizzare correttamente il PnL in un sistema di trading professionale.</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8554c46 elementor-widget elementor-widget-heading" data-id="8554c46" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Considerazioni sullo Sviluppo del Software</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-5d0f4ef elementor-widget elementor-widget-text-editor" data-id="5d0f4ef" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>L&#8217;obbiettivo di questo sistema, a differenza della maggior parte dei sistemi di algotrading &#8220;retails&#8221;, è prestare la massima attenzione ad aspetti di solito trascurati, come l&#8217;alta disponibilità, la ridondanza, il monitoraggio, la rendicontazione, la contabilità, la qualità dei dati e la gestione del rischio all&#8217;interno del sistema. In questo modo si può creare un sistema che prevede un significativo grado di affidabilità nel processo di automazione, consentendo (eventualmente) di concentrarci sull&#8217;ottimizzazione della generazione del segnale e della gestione del portafoglio.</p><p>I seguenti concetti, la maggior parte dei quali sono presi dal settore dell&#8217;ingegneria del software professionale, forniranno la base del progetto:</p><ul><li><strong>Pianificazione automatizzata delle attività</strong>: si prevede un robusto software di pianificazione automatizzata delle attività, come la gestione dei cron jobs, al fine di garantire l&#8217;esecuzione di attività periodiche e schedulabili.</li><li><strong>Alta disponibilità</strong> : il sistema prevede un grado significativo di alta disponibilità grazie alla ridondanza, utilizzando più istanze dei database e server delle applicazioni.</li><li><strong>Backup e ripristino</strong> : si prevede l&#8217;esecuzione di backup di tutti i nostri dati utilizzando robusti sistemi cloud (come Amazon RDS), che consentiranno il ripristino diretto in caso di errore nei database.</li><li><strong>Monitoraggio</strong> &#8211; il sistema deve essere continuamente monitorato, comprese le metriche &#8220;normali&#8221; di utilizzo della CPU, utilizzo della RAM, capacità del disco rigido e I / O di rete, permettendoci di monitorare la &#8220;salute&#8221; del nostro sistema di trading nel tempo.</li><li><strong>Registrazione</strong> : per quanto possibile, il sistema deve registrare il più possibile in un sistema di logging al fine di consentire l&#8217;individuazione rapida di guasti e permettere direttamente il debug.</li><li><strong>Reporting</strong> &#8211; il sistema prevede di calcolare in real-time le performance, confrontala con i benchmark desiderati e valutare dinamicamente il rischio.</li><li><strong>Sistemi di controllo della versione</strong> : il codice sorgente, gli script e i file di configurazione devono essere gestiti tramite un controllo della versione, ovvero <a href="https://github.com/">GitHub</a> , evitando di copiare e incollare le nuove versioni del codice localmente e in remoto</li><li><strong>Sviluppo Test-Driven</strong>: come per <a href="https://datatrading.info/dtforex-1-trading-automatico-sul-forex-tramite-le-api-di-oanda/">DTForex</a> , si prevede un approccio di sviluppo completamente basato sui test (TDD), scrivendo i test unitari per il codice</li><li><strong>Distribuzione continua</strong> &#8211; Al fine di ridurre al minimo l&#8217;introduzione di bug che potrebbero eliminare rapidamente i profitti, si prevede di implementare i concetti di <a href="https://it.wikipedia.org/wiki/Integrazione_continua">integrazione continua</a> e <a href="https://en.wikipedia.org/wiki/Continuous_delivery">distribuzione continua</a> per il deploy sul server. Nei prossimi articoli si descriveranno maggiori dettagli su questo tema.</li><li><strong>Distribuzione remota</strong>: si prevede di utilizzare una distribuzione completamente basata su cloud / server remoto in modo tale che l&#8217;infrastruttura di trading non abbia una dipendenza locale.</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5e19451 elementor-widget elementor-widget-heading" data-id="5e19451" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Prossimi Passi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-f4ddd80 elementor-widget elementor-widget-text-editor" data-id="f4ddd80" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il primo passo è descrivere lo stack del software e gli strumenti da utilizzare per costruire il sistema di trading. Questo include l&#8217;hosting provider, il controllo della versione e i sistemi di distribuzione continua, gli strumenti di monitoraggio e i meccanismi di archiviazione dei dati (inclusi backup e ripristino), nonché la fondamentale scelta del broker e le prestazione dell&#8217;interfaccia API che mette a disposizione.</span></p>
<p><span>Nel prossimo articolo descriviamo tutti i fornitori che sono all&#8217;altezza delle prestazione previste dal sistema, oltre a una ragionevole&nbsp;</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">stima</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">&nbsp;</span><span style="color: var( --e-global-color-text ); font-size: 1rem;">dei costi. Inoltre descriviamo in modo dettagliato le effettive implementazioni di questa infrastruttura.</span></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/datatrader-trading-algoritmico-avanzato-introduzione/">DataTrader &#8211; Trading Algoritmico Avanzato: Introduzione</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Strategia di Mean Reversion per il Pairs Trading Intraday</title>
		<link>https://datatrading.info/strategia-di-mean-reversion-per-il-pairs-trading-intraday/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 23 May 2018 09:18:39 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Strategie]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=935</guid>

					<description><![CDATA[<p>In questo articolo si vuole descrivere la nostra prima strategia di trading intraday. Si basa su una classica idea di trading, quella delle &#8220;coppie di trading&#8221;.  La strategia crea generalmente uno &#8220;spread&#8221; tra la coppia di asset considerati, andando long su una e short sull&#8217;altra. Il rapporto tra long e short può essere definito in &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/strategia-di-mean-reversion-per-il-pairs-trading-intraday/"> <span class="screen-reader-text">Strategia di Mean Reversion per il Pairs Trading Intraday</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/strategia-di-mean-reversion-per-il-pairs-trading-intraday/">Strategia di Mean Reversion per il Pairs Trading Intraday</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="935" class="elementor elementor-935">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-8e2c07c elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="8e2c07c" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1fc1174" data-id="1fc1174" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-484b2bb elementor-widget elementor-widget-text-editor" data-id="484b2bb" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo si vuole descrivere la nostra prima strategia di trading intraday. Si basa su una classica idea di trading, quella delle &#8220;coppie di trading&#8221;. </p><p>La strategia crea generalmente uno &#8220;spread&#8221; tra la coppia di asset considerati, andando long su una e short sull&#8217;altra. Il rapporto tra long e short può essere definito in molti modi, ad esempio utilizzando tecniche di cointegrazione statistica sulle serie temporali. In questo esempio si calcola il &#8220;<em>hedge ratio</em>&#8221; (rapporto di copertura) tra gli asset tramite una <a href="http://en.wikipedia.org/wiki/Linear_regression_model">regressione lineare</a> a rotazione. Questo permette<br />di creare un &#8220;spread&#8221; che viene normalizzato in uno <a href="http://en.wikipedia.org/wiki/Standard_score">z-score</a>. I segnali di trading sono generati quando lo z-score supera una determinata soglia, nella convinzione che lo spread tornerà verso la media.</p><p>La logica della strategia prevede che gli asset considerati siano approssimativamente caratterizzate dallo stesso comportamento o andamento. L&#8217;idea base consiste nel considerare che lo spread dei prezzi ha un comportamento mean-reverting, dal momento che eventi &#8220;locali&#8221; (nel tempo) possono influenzare separatamente i singoli asset (come differenze di capitalizzazione, date di ribilanciamento o operazioni di blocco) ma nel lungo termine le serie di prezzi tendono ad essere cointegrate.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-56ada5a elementor-widget elementor-widget-heading" data-id="56ada5a" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La Strategia</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-d96f98e elementor-widget elementor-widget-text-editor" data-id="d96f98e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Al fine di ottenere Sharpe Ratio più alti, è necessario adottare strategie intraday ad alta frequenza.<br />Il primo importante problema è ottenere dati significativi, dato che i dati intraday di alta qualità non sono solitamente gratuiti. Come descritto negli <a href="https://datatrading.info/download-dello-storico-intraday-per-il-mercato-azionario-statunitenze-da-dtn-iqfeed-con-python/">articoli precedetti</a>, si utilizza il DTN IQFeed per acquisire le barre intraday al minuto e quindi si avrà bisogno di un account DTN per ottenere i dati richiesti per questa strategia. Il secondo problema consiste nel fatto che le simulazioni di backtesting impiegano molto più tempo, specialmente con il modello event-driven, descritto in questa <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">serie di articoli</a>. Se si vuol effettuare il backtesting di un portafolio diversificato con dati al minuto un numero significativo di anni passati, e quindi eseguire qualsiasi ottimizzazione dei parametri, ci si rende rapidamente conto che le simulazioni possono richiedere ore o persino giorni, se effettatu su modermo PC desktop. Questo dovrà essere preso in considerazione nel durante il processo di ricerca e studio della strategia.<br />Il terzo problema è la completa automazione dell&#8217;esecuzione nel live trading poiché ci si sta avvicinando al trading ad alta frequenza e quindi il sistema di esecuzione dove essere altamente performante. Questo significa che l&#8217;ambiente e il codice di esecuzione devono essere altamente affidabili e privi di errori, altrimenti potrebbe verificarsi significative perdite.<br />Questa strategia espande la precedente strategia multiday al fine di utilizzare i dati intraday.<br />In particolare, si usa barre OHLCV al minuto, a differenza di dati OHLCV giornalieri. Le regole per la strategia sono semplici:</p><ol><li>Identificare una coppia di titoli azionari le cui serie temporali hanno statisticamente un comportamento riconducile al mean-reverting. In questo caso, si considerano i due titoli azionari statunitensi con i ticker AREX e WLL.</li><li>Creare le serie temporali residue della coppia eseguendo una regressione lineare a rotazione, per una specifica finestra di ricerca, tramite l&#8217;algoritmo dei minimi quadrati ordinari (OLS). Questo periodo di ricerca è un parametro da ottimizzare.</li><li>Creare un z-score a rotazione delle serie temporali residue per lo stesso periodo di ricerca e utilizzarlo per determinare le soglie di ingresso / uscita per i segnali di trading.</li><li>Se la soglia superiore viene superata quando non si è sul mercato, allora si ENTRA a mercato (long o short dipende dalla direzione di rottura della soglia viene). Se invece viene superata la soglia inferiore quando si ha una posizione a mercato, allora si ESCE dal mercato. Anche le soglie superiore e inferiore sono parametri da ottimizzare.</li></ol><p>In effetti si potrebbe usare il test Cointegrated Augmented Dickey-Fuller (CADF) per identificare un parametro di copertura ancora più accurato. Questo potrebbe essere un&#8217;interessate evoluzione di questa strategia.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3448be9 elementor-widget elementor-widget-heading" data-id="3448be9" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Implementazione in Python</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-0d7a450 elementor-widget elementor-widget-text-editor" data-id="0d7a450" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come per tutti i tutorial con Python e Pandas, è necessario aver impostato un ambiente di backtesting con Python, come descritto in <a href="https://datatrading.info/sviluppo-di-un-backtesting-vettoriale-con-python-e-pandas/" data-wplink-edit="true">questo tutorial</a>. Una volta impostato, il primo passo è importare le necessarie librerie Python. Per questo backtest sono richiesti <a href="http://matplotlib.org/">matplotlib</a> e <a href="http://pandas.pydata.org/">pandas</a>.</p><p>In particolare si utilizza metodo <code style="color: #e83e8c;">rolling_apply</code>, al fine di applicare il calcolo dello z-score ad una finestra di ricerca a rotazione. Si importa <code style="color: #e83e8c;">statsmodels</code> perché fornisce un mezzo per calcolare l&#8217;algoritmo dei minimi quadrati ordinari (OLS) per la regressione lineare, al fine di  ottenere il rapporto di copertura per la costruzione dei residui.<br />Si prevede inoltre un <code style="color: #e83e8c;">DataHandler</code> e un <code style="color: #e83e8c;">Portfolio</code> leggermente modificati per effettuare operazioni di trading al minuto sui dati DTN IQFeed. Per creare questi file si può semplicemente copiare tutto il codice di <code style="color: #e83e8c;">portfolio.py</code> e <code style="color: #e83e8c;">data.py</code> rispettivamente nei nuovi file <code style="color: #e83e8c;">hft_portfolio.py</code> e <code style="color: #e83e8c;">hft_data.py</code> e quindi modificare le sezioni necessarie, che illustrato di seguito.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a8a195b elementor-widget elementor-widget-bdt-source-code" data-id="a8a195b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># intraday_mr.py

import datetime
import numpy as np
import pandas as pd
import statsmodels.api as sm

from strategy.strategy import Strategy
from event.event import SignalEvent
from backtest.backtest import Backtest

from data.hft_data import HistoricCSVDataHandlerHFT
from portfolio.hft_portfolio import PortfolioHFT

from execution.execution import SimulatedExecutionHandler</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7ee70e0 elementor-widget elementor-widget-text-editor" data-id="7ee70e0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Con il seguente codice si crea la classe <code style="color: #e83e8c;">IntradayOLSMRStrategy</code>, derivata dalla classe base astratta di <code style="color: #e83e8c;">Strategy</code>. Il metodo <code style="color: #e83e8c;">__init__</code> del costruttore richiede l&#8217;accesso al provider di dati storici, alla coda degli eventi, a una soglia <em>zscore_low</em> e a una soglia <em>zscore_high</em>, utilizzate per determinare quando la serie residua tra le due coppie è di tipo mean-reverting.
Inoltre, si specifica la finestra di ricerca OLS (impostata su 100), che è un parametro soggetto a potenziale ottimizzazione. All&#8217;inizio della simulazione non si è long o short sul mercato, quindi si imposta sia <code style="color: #e83e8c;">self.long_market</code> che <code style="color: #e83e8c;">self.short_market</code> uguale a <code style="color: #e83e8c;">False</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e60446b elementor-widget elementor-widget-bdt-source-code" data-id="e60446b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># intraday_mr.py


class IntradayOLSMRStrategy(Strategy):
    &quot;&quot;&quot;
    Utilizza i minimi quadrati ordinari (OLS) per eseguire una regressione lineare
    continua in modo da determinare il rapporto di hedge tra una coppia di azioni.
    Lo z-score delle serie temporali dei residui viene quindi calcolato in modo
    continuo e se supera un intervallo di soglie (predefinito a [0,5, 3,0]), viene
    generata una coppia di segnali long / short (per la soglia alta) o vengono
    generate coppie di segnali di uscita (per la soglia bassa).
    &quot;&quot;&quot;
    def __init__(self, bars, events, ols_window=100,zscore_low=0.5, zscore_high=3.0):
        &quot;&quot;&quot;
        Initializza la strategia di arbitraggio stastistico.
        Parametri:
        bars - L&#039;oggetto DataHandler che fornisce i dati di mercato
        events - L&#039;oggetto Event Queue.
        &quot;&quot;&quot;
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.ols_window = ols_window
        self.zscore_low = zscore_low
        self.zscore_high = zscore_high
        self.pair = (&#039;AREX&#039;, &#039;WLL&#039;)
        self.datetime = datetime.datetime.utcnow()
        self.long_market = False
        self.short_market = False

</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-610de23 elementor-widget elementor-widget-text-editor" data-id="610de23" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il seguente metodo, <code style="color: #e83e8c;">calculate_xy_signals</code>, prende lo zscore corrente (dal calcolo rolling eseguito di seguito) e determina se è necessario generare nuovi segnali di trading. Questi segnali vengono resi disponibili in output.

Ci sono quattro stati potenziali a cui si può essere interessati:
<ol>
 	<li>Long sul mercato e sotto la più alta soglia negativa dello zscore</li>
 	<li>Long il mercato e all&#8217;interno del valore assoluto della soglia più alta dello zscore</li>
 	<li>Short sul mercato e sopra la maggiore soglia positiva dello z-score</li>
 	<li>Short sul mercato e all&#8217;interno tra il valore assoluto del valore assoluto della soglia inferiore più bassa dello zscore.</li>
</ol>
In tutti i casi è necessario generare due segnali, uno per la prima componente della coppia (AREX) e uno per la seconda componente della coppia (WLL). Se nessuna di queste condizioni viene soddisfatta, si restituisce una coppia di valori <code style="color: #e83e8c;">None</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6fc9495 elementor-widget elementor-widget-bdt-source-code" data-id="6fc9495" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>
# intraday_mr.py

def calculate_xy_signals(self, zscore_last):
    &quot;&quot;&quot;
    Calcola le effettive coppie di segnali x, y da inviare al generatore di segnali.

    Parametri
    zscore_last - Il punteggio dello z-score su cui eseguire il test
    &quot;&quot;&quot;
    y_signal = None
    x_signal = None
    p0 = self.pair[0]
    p1 = self.pair[1]
    dt = self.datetime
    hr = abs(self.hedge_ratio)

    # Se siamo long sul mercato e al di sotto del
    # negativo della soglia alta dello zscore
    if zscore_last &lt;= -self.zscore_high and not self.long_market:
        self.long_market = True
        y_signal = SignalEvent(1, p0, dt, &#039;LONG&#039;, 1.0)
        x_signal = SignalEvent(1, p1, dt, &#039;SHORT&#039;, hr)

    # Se siamo long sul mercato e tra il
    # valore assoluto della soglia bassa dello zscore
    if abs(zscore_last) &lt;= self.zscore_low and self.long_market:
        self.long_market = False
        y_signal = SignalEvent(1, p0, dt, &#039;EXIT&#039;, 1.0)
        x_signal = SignalEvent(1, p1, dt, &#039;EXIT&#039;, 1.0)

    # Se siamo short sul mercato e oltre
    # la soglia alta dello z-score
    if zscore_last &gt;= self.zscore_high and not self.short_market:
        self.short_market = True
        y_signal = SignalEvent(1, p0, dt, &#039;SHORT&#039;, 1.0)
        x_signal = SignalEvent(1, p1, dt, &#039;LONG&#039;, hr)

    # Se siamo short sul mercato e tra il
    # valore assoluto della soglia bassa dello z-score
    if abs(zscore_last) &lt;= self.zscore_low and self.short_market:
        self.short_market = False
        y_signal = SignalEvent(1, p0, dt, &#039;EXIT&#039;, 1.0)
        x_signal = SignalEvent(1, p1, dt, &#039;EXIT&#039;, 1.0)

    return y_signal, x_signal</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-cc2f17a elementor-widget elementor-widget-text-editor" data-id="cc2f17a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il seguente metodo, <code style="color: #e83e8c;">calculate_signals_for_pairs</code> acquisisce l&#8217;ultimo set di barre per ogni componente della coppia (in questo caso 100 barre) e le utilizza per costruire una regressione lineare basata su minimi quadrati ordinari. Ciò consente l&#8217;identificazione del rapporto di copertura, necessario per la costruzione delle serie temporali residue.</p><p>Una volta ricavato il rapporto di copertura, si crea lo <code style="color: #e83e8c;">spread</code> delle serie di residui. Il passo successivo consiste nel calcolare l&#8217;ultimo z-score dalle serie residue sottraendo la loro media e dividendo per la loro deviazione standard nel periodo di ricerca.<br />Infine, <code style="color: #e83e8c;">y_signal</code> e <code style="color: #e83e8c;">x_signal</code> sono calcolati sulla base di questo z-score. Se i segnali non sono entrambi None, le istanze <code style="color: #e83e8c;">SignalEvent</code> vengono inviate alla coda degli eventi:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-09663d7 elementor-widget elementor-widget-bdt-source-code" data-id="09663d7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># intraday_mr.py

def calculate_signals_for_pairs(self):
    &quot;&quot;&quot;
    Genera una nuova serie di segnali basati sulla strategia di
    ritorno verso la media (mean reversion).
    Calcola il rapporto di hedge tra la coppia di ticker.
    Usiamo OLS per questo, anche se dovremmo idealmente usare il CADF.
    &quot;&quot;&quot;

    # Otteniamo l&#039;ultima finestra di valori per ogni
    # componente della coppia di ticker
    y = self.bars.get_latest_bars_values(
        self.pair[0], &quot;close&quot;, N=self.ols_window
    )
    x = self.bars.get_latest_bars_values(
        self.pair[1], &quot;close&quot;, N=self.ols_window
    )

    if y is not None and x is not None:
        # Verificare che tutti i periodi di finestra siano disponibili
        if len(y) &gt;= self.ols_window and len(x) &gt;= self.ols_window:
            # Calcola l&#039;attuale rapporto di hedge utilizzando OLS
            self.hedge_ratio = sm.OLS(y, x).fit().params[0]

            # Calcola l&#039;attuale z-score dei residui
            spread = y - self.hedge_ratio * x
            zscore_last = ((spread - spread.mean()) / spread.std())[-1]

            # Calcula i segnali e il aggiunge alla coda degli eventi
            y_signal, x_signal = self.calculate_xy_signals(zscore_last)
            if y_signal is not None and x_signal is not None:
                self.events.put(y_signal)
                self.events.put(x_signal)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b5d5336 elementor-widget elementor-widget-text-editor" data-id="b5d5336" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il metodo finale, <code style="color: #e83e8c;">calculate_signals</code> è sovrascritto dalla classe base e viene utilizzato per verificare se un evento ricevuto dalla coda è in realtà un <code style="color: #e83e8c;">MarketEvent</code>, nel qual caso viene eseguito il calcolo dei nuovi segnali:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-22facf9 elementor-widget elementor-widget-bdt-source-code" data-id="22facf9" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># intraday_mr.py

def calculate_signals(self, event):
    &quot;&quot;&quot;
    Calcula il SignalEvents basato sui dati di mercato.
    &quot;&quot;&quot;
    if event.type == ’MARKET’:
        self.calculate_signals_for_pairs()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8fd6020 elementor-widget elementor-widget-text-editor" data-id="8fd6020" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				La funzione <code style="color: #e83e8c;">__main__</code> collega insieme i componenti al fine di eseguire il backtesting di una strategia. Si specifica dove sono archiviati i dati al minuto dei ticker, utilizzando il formato dei simboli IQFeed DTN. Necessariamente i file sono stati modificati in modo tale che iniziano e finiscono sullo stesso minuto. Per questa particolare coppia di AREX e WLL, la data comune di inizio è l&#8217;8 novembre 2007 alle 10:41:00.
Infine, si costruisce l&#8217;oggetto backtest e si inizia a simulare il trading:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9309c9c elementor-widget elementor-widget-bdt-source-code" data-id="9309c9c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># intraday_mr.py

if __name__ == &quot;__main__&quot;:
    csv_dir = &#039;/path/to/your/csv/file&#039; # DA MODIFICARE
    symbol_list = [&#039;AREX&#039;, &#039;WLL&#039;]
    initial_capital = 100000.0
    heartbeat = 0.0
    start_date = datetime.datetime(2007, 11, 8, 10, 41, 0)

    backtest = Backtest(
        csv_dir, symbol_list, initial_capital, heartbeat,start_date, 
        HistoricCSVDataHandlerHFT, SimulatedExecutionHandler,
        PortfolioHFT, IntradayOLSMRStrategy
    )
    backtest.simulate_trading()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b39a806 elementor-widget elementor-widget-text-editor" data-id="b39a806" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Tuttavia, prima di poter eseguire questo codice, è necessario apportare alcune modifiche al gestore dati e all&#8217;oggetto portfolio. In particolare, è necessario creare nuovi file <code style="color: #e83e8c;">hft_data.py</code> e <code style="color: #e83e8c;">hft_portfolio.py</code> che sono rispettivamente copie di <code style="color: #e83e8c;">data.py</code> e <code style="color: #e83e8c;">portfolio.py</code>.

In <code style="color: #e83e8c;">hft_data.py</code> si deve rinominare <code style="color: #e83e8c;">HistoricCSVDataHandler</code> in <code style="color: #e83e8c;">HistoricCSVDataHandlerHFT</code> e sostituire l&#8217;elenco dei nomi nel metodo <code style="color: #e83e8c;">_open_convert_csv_files</code>.
Il vecchio codice è:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bb57164 elementor-widget elementor-widget-bdt-source-code" data-id="bb57164" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>names=[
       &#039;datetime&#039;, &#039;open&#039;, &#039;high&#039;,
       &#039;low&#039;, &#039;close&#039;, &#039;adj_close&#039;, &#039;volume&#039;
      ]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8006c3f elementor-widget elementor-widget-text-editor" data-id="8006c3f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Deve essere sostituito con il seguente:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4049e79 elementor-widget elementor-widget-bdt-source-code" data-id="4049e79" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>names=[
       &#039;datetime&#039;, &#039;open&#039;, &#039;high&#039;,
       &#039;low&#039;, &#039;close&#039;, &#039;volume&#039;, &#039;oi&#039;
      ]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-52e63a6 elementor-widget elementor-widget-text-editor" data-id="52e63a6" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				In questo modo si garantisce la compatibilità tra il nuovo formato di DTN IQFeed e il sistema di backtesting.

L&#8217;altro cambiamento consiste nel rinominare <code style="color: #e83e8c;">Portfolio</code> in <code style="color: #e83e8c;">PortfolioHFT</code> all&#8217;interno di <code style="color: #e83e8c;">hft_portfolio.py</code>. Si deve quindi modificare alcune righe per tenere conto della frequenza minima dei dati DTN.
In particolare, all&#8217;interno del metodo <code style="color: #e83e8c;">update_timeindex</code>, è necessario modificare il seguente codice:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-739c457 elementor-widget elementor-widget-bdt-source-code" data-id="739c457" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>for s in self.symbol_list:
    # Approssimazione al valore reale
    market_value = self.current_positions[s] * \
        self.bars.get_latest_bar_value(s, &quot;adj_close&quot;)
    dh[s] = market_value
    dh[’total’] += market_value</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-bb7c81e elementor-widget elementor-widget-text-editor" data-id="bb7c81e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per farlo diventare come segue:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e1a06c5 elementor-widget elementor-widget-bdt-source-code" data-id="e1a06c5" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>for s in self.symbol_list:
    # Approssimazione al valore reale
    market_value = self.current_positions[s] * \
        self.bars.get_latest_bar_value(s, &quot;close&quot;)
    dh[s] = market_value
    dh[’total’] += market_value</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b343470 elementor-widget elementor-widget-text-editor" data-id="b343470" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Questo assicura di considerare il prezzo di chiusura, piuttosto che il prezzo di adj_close. Quest&#8217;ultimo è utilizzato da Yahoo Finance, mentre il primo è di DTN IQFeed.

Si deve inoltre prevedere un aggiustamento simile in <code style="color: #e83e8c;">update_holdings_from_fill</code>. Si deve cambiare il seguente codice:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-419e379 elementor-widget elementor-widget-bdt-source-code" data-id="419e379" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Aggiornamento della lista delle holdings con le nuove quantità
    fill_cost = self.bars.get_latest_bar_value(
        fill.symbol, &quot;adj_close&quot;
    )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-5228fb4 elementor-widget elementor-widget-text-editor" data-id="5228fb4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				come segue:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c9c897c elementor-widget elementor-widget-bdt-source-code" data-id="c9c897c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Aggiornamento della lista delle holdings con le nuove quantità
    fill_cost = self.bars.get_latest_bar_value(
        fill.symbol, &quot;close&quot;
    )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-41d0c55 elementor-widget elementor-widget-text-editor" data-id="41d0c55" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				La modifica finale si effettua nel metodo <code style="color: #e83e8c;">output_summary_stats</code>, nella parte inferiore del file. Si deve modificare il metodo di calcolato del Sharpe Ratio per tenere conto del trading con barre al minuto. La seguente riga:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a82c591 elementor-widget elementor-widget-bdt-source-code" data-id="a82c591" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>sharpe_ratio = create_sharpe_ratio(returns)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-effc437 elementor-widget elementor-widget-text-editor" data-id="effc437" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Viene modificata come:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-794d254 elementor-widget elementor-widget-bdt-source-code" data-id="794d254" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>sharpe_ratio = create_sharpe_ratio(returns, periods=252*6.5*60)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-14da5dd elementor-widget elementor-widget-text-editor" data-id="14da5dd" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Dopo aver mandato in esecuzione il file <code style="color: #e83e8c;">intraday_mr.py</code> si ottiene il seguente output (troncato) dalla simulazione di backtest:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4138339 elementor-widget elementor-widget-bdt-source-code" data-id="4138339" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-coy">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>..
..
375072
375073
Creating summary stats...
Creating equity curve...
                    AREX WLL cash commission total returns \
datetime
2014-03-11 15:53:00 2098 -6802 120604.3 9721.4 115900.3 -0.000052
2014-03-11 15:54:00 2101 -6799 120604.3 9721.4 115906.3 0.000052
2014-03-11 15:55:00 2100 -6802 120604.3 9721.4 115902.3 -0.000035
2014-03-11 15:56:00 2097 -6810 120604.3 9721.4 115891.3 -0.000095
2014-03-11 15:57:00 2098 -6801 120604.3 9721.4 115901.3 0.000086
2014-03-11 15:58:00 2098 -6800 120604.3 9721.4 115902.3 0.000009
2014-03-11 15:59:00 2099 -6800 120604.3 9721.4 115903.3 0.000009
2014-03-11 16:00:00 2100 -6801 120604.3 9721.4 115903.3 0.000000
2014-03-11 16:01:00 2100 -6801 120604.3 9721.4 115903.3 0.000000
2014-03-11 16:01:00 2100 -6801 120604.3 9721.4 115903.3 0.000000

                    equity_curve drawdown
datetime
2014-03-11 15:53:00 1.159003 0.003933
2014-03-11 15:54:00 1.159063 0.003873
2014-03-11 15:55:00 1.159023 0.003913
2014-03-11 15:56:00 1.158913 0.004023
2014-03-11 15:57:00 1.159013 0.003923
2014-03-11 15:58:00 1.159023 0.003913
2014-03-11 15:59:00 1.159033 0.003903
2014-03-11 16:00:00 1.159033 0.003903
2014-03-11 16:01:00 1.159033 0.003903
2014-03-11 16:01:00 1.159033 0.003903

[(’Total Return’, ’15.90%’),
 (’Sharpe Ratio’, ’1.89’),
 (’Max Drawdown’, ’3.03%’),
 (’Drawdown Duration’, ’120718’)]
Signals: 7594
Orders: 7478
Fills: 7478</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7cbfe1c elementor-widget elementor-widget-text-editor" data-id="7cbfe1c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Si nota facilmente che la strategia si comporta bene durante il periodo sotto esame. Ha un rendimento totale di poco inferiore al 16%. Il Sharpe Ratio ragionevole (se confrontato con una tipica strategia giornaliera), ma data la natura ad alta frequenza della strategia ci si dovrebbe aspettare di più. La migliore caratteristica di questa strategia è il basso drawdown massimo(circa il 3%). Questo suggerisce di poter applicare una leva maggiore per ottenere più profitto.</p><p> </p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d46b9da elementor-widget elementor-widget-heading" data-id="d46b9da" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Visualizzazione grafica delle Performance</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-f5bbb27 elementor-widget elementor-widget-text-editor" data-id="f5bbb27" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Si può facilmente visualizzare il grafico dei rendimenti risposto all&#8217;intervallo di ricerca (numero di barre) e tutte le altre misure delle performance usando lo script plot_performance.py. Tale codice può essere utilizzato come base per creare grafici personalizzati delle prestazioni.</p><p>È necessario eseguirlo nella stessa directory del file di output dal backtest, ovvero dove risiede equity.csv. Il codice è il seguente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-14a43e1 elementor-widget elementor-widget-bdt-source-code" data-id="14a43e1" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># plot_performance.py

import os.path
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

if __name__ == &quot;__main__&quot;:
    data = pd.io.parsers.read_csv(
        &quot;equity.csv&quot;, header=0,
        parse_dates=True, index_col=0
    )

    # Visualizza tre grafici: curva di Equity,
    # rendimenti, drawdown
    fig = plt.figure()

    # Imposta il bianco come colore di sfondo
    fig.patch.set_facecolor(&#039;white&#039;)

    # Visualizza la curva di equity
    ax1 = fig.add_subplot(311, ylabel=&#039;Portfolio value, % &#039;)
    data[&#039;equity_curve&#039;].plot(ax=ax1, color=&quot;blue&quot;, lw=2.)
    plt.grid(True)

    # Visualizza i rendimenti
    ax2 = fig.add_subplot(312, ylabel=&#039;Period returns, % &#039;)
    data[&#039;returns&#039;].plot(ax=ax2, color=&quot;black&quot;, lw=2.)
    plt.grid(True)

    # Visualizza i drawdown
    ax3 = fig.add_subplot(313, ylabel=&#039;Drawdowns, % &#039;)
    data[&#039;drawdown&#039;].plot(ax=ax3, color=&quot;red&quot;, lw=2.)
    plt.grid(True)

    # Stampa i grafici
    plt.show()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-8380668 elementor-widget elementor-widget-text-editor" data-id="8380668" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Utilizzando l&#8217;output CSV del backtesting della precedente strategia si ottengono i seguenti grafici:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2291a85 elementor-widget elementor-widget-image" data-id="2291a85" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
									<figure class="wp-caption">
										<img width="768" height="539" src="https://datatrading.info/wp-content/uploads/2017/09/strategia-intraday-pairs-trading-algoritmico-768x539.png" class="attachment-medium_large size-medium_large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2017/09/strategia-intraday-pairs-trading-algoritmico-768x539.png 768w, https://datatrading.info/wp-content/uploads/2017/09/strategia-intraday-pairs-trading-algoritmico.png 800w" sizes="(max-width: 768px) 100vw, 768px" />											<figcaption class="widget-image-caption wp-caption-text">Fig -  Curva di Equity, Ritorni Giornalieri e Drawdown per la strategia mean-reversion intraday.</figcaption>
										</figure>
								</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/strategia-di-mean-reversion-per-il-pairs-trading-intraday/">Strategia di Mean Reversion per il Pairs Trading Intraday</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Implementazione di una Strategia di Forecasting sull&#8217;S&#038;P500</title>
		<link>https://datatrading.info/implementazione-di-una-strategia-di-forecasting-sullsp500/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sat, 19 May 2018 09:43:57 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Strategie]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2233</guid>

					<description><![CDATA[<p>In questo articolo consideriamo una strategia di trading costruita sulla base del motore di predizione descritto nei precedenti articoli sul tema machine learning e forecasting.Proveremo a tradare le predizioni effettuate dal foracaster del mercato azionario. Questo algoritmo si basa per la maggior parte sul software che abbiamo già sviluppato utilizzando il backtesting vettoriale e descritto &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/implementazione-di-una-strategia-di-forecasting-sullsp500/"> <span class="screen-reader-text">Implementazione di una Strategia di Forecasting sull&#8217;S&#038;P500</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/implementazione-di-una-strategia-di-forecasting-sullsp500/">Implementazione di una Strategia di Forecasting sull&#8217;S&#038;P500</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2233" class="elementor elementor-2233">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-72fae8d elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="72fae8d" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-83816ff" data-id="83816ff" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-6117bd2 elementor-widget elementor-widget-text-editor" data-id="6117bd2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo consideriamo una strategia di trading costruita sulla base del motore di predizione descritto nei precedenti articoli sul tema <a href="http://datatrading.info/guida-introduttiva-al-machine-learning-statistico/">machine learning</a> e <a href="http://datatrading.info/introduzione-al-forecasting-delle-serie-temporali-finanziare/">forecasting</a>.<br />Proveremo a tradare le predizioni effettuate dal foracaster del mercato azionario.<br /><br /><br />Questo algoritmo si basa per la maggior parte sul software che abbiamo già sviluppato utilizzando il backtesting vettoriale e descritto in questo <a href="https://datatrading.info/strategia-di-forecasting-sul-sp500-backtesting-con-python-e-pandas/">articolo</a>. Esso viene rivesto ed adattato per essere innestato nel <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">nuovo motore di backtesting</a> basato sugli eventi in modo da avere una maggiore accuratezza nell&#8217;esecuzione delle operazioni e calcolo delle performance.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c4ac504 elementor-widget elementor-widget-heading" data-id="c4ac504" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La Strategia di Forecasting</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-c14de4c elementor-widget elementor-widget-text-editor" data-id="c14de4c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questa strategia si vuol prevedere l&#8217;andamento dello SPY, l&#8217;ETF che replica il valore dell&#8217;S&amp;P 500. In definitiva, vogliamo rispondere alla domanda se un semplice algoritmo di previsione che utilizza dati sui prezzi ritardati e con una leggera performance predittiva, possa offrire vantaggi rispetto a una strategia &#8220;buy &amp; hold&#8221;.</p><p>Le regole per questa strategia sono le seguenti:</p><ol><li>Adattare un modello di previsione a un sottoinsieme di dati dell&#8217;S&amp;P500. In questa strategia utilizziamo l&#8217;<a href="http://en.wikipedia.org/wiki/Quadratic_classifier#Quadratic_discriminant_analysis"> Analisi Discriminante Quadratica</a> , ma si potrebbe utilizzare anche una regressione logistica, una macchina vettoriale di supporto o una foresta casuale.</li><li>Utilizza due ritardi precedenti sui rendimenti dei prezzi di chiusura aggiustati come predittore dei rendimenti di domani. Se i rendimenti sono previsti positivi, allora si va long. Se i rendimenti sono previsti negativi, si esce dalla posizione. Non prenderemo in considerazione la vendita allo scoperto per questa particolare strategia.</li></ol>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8c04b31 elementor-widget elementor-widget-heading" data-id="8c04b31" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Implementazione</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-6eeaae4 elementor-widget elementor-widget-text-editor" data-id="6eeaae4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="color: var( --e-global-color-text ); font-size: 1rem;">Per questa strategia si prevede di creare il </span><code>snp_forecast.py</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> ed importare le seguenti librerie: </span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3cbb2db elementor-widget elementor-widget-bdt-source-code" data-id="3cbb2db" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># snp_forecast.py

import datetime
import pandas as pd
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis as QDA

from strategy.strategy import Strategy
from event.event import SignalEvent
from backtest.backtest import Backtest
from data.data import HistoricCSVDataHandler
from execution.execution import SimulatedExecutionHandler
from portfolio.portfolio import Portfolio
from model.forecast import create_lagged_series</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2a7ae6f elementor-widget elementor-widget-text-editor" data-id="2a7ae6f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Abbiamo importato Pandas e Scikit-Learn per eseguire la procedura di adattamento per il modello di classificazione supervisionato. Abbiamo anche importato le classi necessarie dal motore di backtesting basato su eventi. Infine, abbiamo importato la funzione <code style="color: #e83e8c;">create_lagged_series</code>, che abbiamo utilizzato nell&#8217;articolo di introduzione al forecasting delle serie temporali capitolo Previsione.<br /><br />Il passaggio successivo consiste nel creare <code style="color: #e83e8c;">SPYDailyForecastStrategy</code> come sottoclasse della classe base astratta <code style="color: #e83e8c;">Strategy</code>. Poiché &#8220;codificheremo&#8221; i parametri della strategia direttamente nella classe, per semplicità, gli unici parametri necessari per il costruttore <code style="color: #e83e8c;">__init__</code> sono il gestore dati delle barre e la coda degli eventi.<br /><br />Impostiamo le date di inzio / fine / test del modello di previsione e poi diciamo alla classe che siamo fuori dal mercato (<code style="color: #e83e8c;">self.long_market = False</code>). Infine, impostiamo <code style="color: #e83e8c;">self.model</code> come modello addestrato dalla funzione <code style="color: #e83e8c;">create_symbol_forecast_model</code>, come segue:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6ea618f elementor-widget elementor-widget-bdt-source-code" data-id="6ea618f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># snp_forecast.py

class SPYDailyForecastStrategy(Strategy):
    &quot;&quot;&quot;
    Strategia previsionale dell&#039;S&amp;P500. Usa un Quadratic Discriminant
    Analyser per prevedere i rendimenti per uno determinato sottoperiodo
    e quindi genera segnali long e di uscita basati sulla previsione.
    &quot;&quot;&quot;
    def __init__(self, bars, events):
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.datetime_now = datetime.datetime.utcnow()
        self.model_start_date = datetime.datetime(2001,1,10)
        self.model_end_date = datetime.datetime(2005,12,31)
        self.model_start_test_date = datetime.datetime(2005,1,1)
        self.long_market = False
        self.short_market = False
        self.bar_index = 0
        self.model = self.create_symbol_forecast_model()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-27ab56c elementor-widget elementor-widget-text-editor" data-id="27ab56c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Definiamo quindi <code style="color: #e83e8c;">create_symbol_forecast_model</code>. Essenzialmente si richiama la funzione <code style="color: #e83e8c;">create_lagged_series</code>, che produce un DataFrame pandas con cinque diveri ritardi di rendimenti giornalieri per ogni predittore corrente.

Consideriamo quindi solo i due ritardi più recenti. Questo perché stiamo introducendo una regola di modellazione che consiste nell&#8217;ipotizzare che il potere predittivo dei ritardi precedenti è probabilmente minimo.
<br>
<br>
In questa fase creiamo i dati di addestramento e test, l&#8217;ultimo dei quali può essere utilizzato per testare il nostro modello, se lo si desidera. Si è scelto di non produrre dati di test, poiché abbiamo già addestrato il modello nel precedente articolo. Infine adattiamo i dati di addestramento al <code style="color: #e83e8c;">Quadratic Discriminant Analyzer</code> e quindi restituiamo il modello.

Si noti che possiamo facilmente sostituire il modello con, ad esempio, una foresta casuale, una macchina vettoriale di supporto o una regressione logistica. Tutto quello che dobbiamo fare è importare la libreria corretta da Scikit-Learn e sostituire semplicemente la riga <code style="color: #e83e8c;">model = QDA()</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-64c7fc5 elementor-widget elementor-widget-bdt-source-code" data-id="64c7fc5" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># snp_forecast.py

    def create_symbol_forecast_model(self):
        # Creazione delle serie ritardate dell&#039;indice S&amp;P500 
        # del mercato azionario US
        snpret = create_lagged_series(
            self.symbol_list[0], self.model_start_date,
            self.model_end_date, lags=5
        )
        # Uso i rendimenti dei due giorni precedenti come valore 
        # previsionale, con direzione come risposta
        X = snpret[[&quot;Lag1&quot;, &quot;Lag2&quot;]]
        y = snpret[&quot;Direction&quot;]
        # Creazione dei set di dati per il training e il test
        start_test = self.model_start_test_date
        X_train = X[X.index &lt; start_test]
        X_test = X[X.index &gt;= start_test]
        y_train = y[y.index &lt; start_test]
        y_test = y[y.index &gt;= start_test]

        model = QDA()
        model.fit(X_train, y_train)
        return model</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-76b4e46 elementor-widget elementor-widget-text-editor" data-id="76b4e46" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				A questo punto siamo pronti per sostituire il metodo <code style="color: #e83e8c;">prepare_signals</code> della classe base <code style="color: #e83e8c;">Strategy</code>. Per prima cosa calcoliamo alcuni parametri utilizzati dal nostro oggetto <code style="color: #e83e8c;">SignalEvent</code> e quindi generiamo un set di segnali solo se abbiamo ricevuto un oggetto <code style="color: #e83e8c;">MarketEvent</code> (un controllo base di integrità).
<br>
<br>
Attendiamo che siano trascorse cinque barre (ovvero cinque giorni per questa strategia!) e quindi otteniamo i valori di rendimenti ritardati. Quindi racchiudiamo questi valori in una serie pandas in modo da garantire il corretto funzionamento del metodo di previsione del modello. Quindi calcoliamo una previsione, che si manifesta come un valore +1 o -1.
<br>
<br>
Se la previsione è un +1 e non siamo già long sul mercato, creiamo un <code style="color: #e83e8c;">SignalEvent</code> per andare long e far sapere al sistema che siamo entrati a mercato. Se la previsione è -1 e siamo long sul mercato, allora si esce dal mercato:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-836a712 elementor-widget elementor-widget-bdt-source-code" data-id="836a712" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># snp_forecast.py

    def calculate_signals(self, event):
        &quot;&quot;&quot;
        Calcolo di SignalEvents in base ai dati di mercato.
        &quot;&quot;&quot;
        sym = self.symbol_list[0]
        dt = self.datetime_now
        if event.type == &#039;MARKET&#039;:
            self.bar_index += 1
            if self.bar_index &gt; 5:
                lags = self.bars.get_latest_bars_values(
                    self.symbol_list[0], &quot;returns&quot;, N=3
                )
            pred_series = pd.Series({
                                    &#039;Lag1&#039;: lags[1] * 100.0,
                                    &#039;Lag2&#039;: lags[2] * 100.0
                                    })
            pred = self.model.predict(pred_series)
            if pred &gt; 0 and not self.long_market:
                self.long_market = True
                signal = SignalEvent(1, sym, dt, &#039;LONG&#039;, 1.0)
                self.events.put(signal)
            if pred &lt; 0 and self.long_market:
                self.long_market = False
                signal = SignalEvent(1, sym, dt, &#039;EXIT&#039;, 1.0)
                self.events.put(signal)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-56c44f4 elementor-widget elementor-widget-text-editor" data-id="56c44f4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per eseguire questa strategia si deve scaricare un file CSV da Yahoo Finance con i dati storici di SPY e posizionarlo in una specifica directory (da notare che si dovrà cambiare il percorso nel seguente codice!).

Quindi si incampusa la logica di backtesting tramite la classe <code style="color: #e83e8c;">Backtest</code> ed si esegue il test richiamando il metodo <code style="color: #e83e8c;">simulate_trading</code>:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-669e2ec elementor-widget elementor-widget-bdt-source-code" data-id="669e2ec" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># snp_forecast.py

if __name__ == &quot;__main__&quot;:
    csv_dir = &#039;/path/to/your/csv/file&#039; # CHANGE THIS!
    symbol_list = [&#039;SPY&#039;]
    initial_capital = 100000.0
    heartbeat = 0.0
    start_date = datetime.datetime(2006,1,3)
    backtest = Backtest(
        csv_dir, symbol_list, initial_capital, heartbeat,
        start_date, HistoricCSVDataHandler, SimulatedExecutionHandler,
        Portfolio, SPYDailyForecastStrategy
    )
    backtest.simulate_trading()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-39b1596 elementor-widget elementor-widget-text-editor" data-id="39b1596" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il risultato della strategia è il seguente (al netto dei costi di transazione)
					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7cc5b08 elementor-widget elementor-widget-bdt-source-code" data-id="7cc5b08" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-coy">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>..
..
2209
2210
Creating summary stats...
Creating equity curve...
SPY cash commission total returns equity_curve \
datetime
2014-09-29 19754 90563.3 349.7 110317.3 -0.000326 1.103173
2014-09-30 19702 90563.3 349.7 110265.3 -0.000471 1.102653
2014-10-01 19435 90563.3 349.7 109998.3 -0.002421 1.099983
2014-10-02 19438 90563.3 349.7 110001.3 0.000027 1.100013
2014-10-03 19652 90563.3 349.7 110215.3 0.001945 1.102153
2014-10-06 19629 90563.3 349.7 110192.3 -0.000209 1.101923
2014-10-07 19326 90563.3 349.7 109889.3 -0.002750 1.098893
2014-10-08 19664 90563.3 349.7 110227.3 0.003076 1.102273
2014-10-09 19274 90563.3 349.7 109837.3 -0.003538 1.098373
2014-10-09 0 109836.0 351.0 109836.0 -0.000012 1.098360
drawdown
datetime
2014-09-29 0.003340
2014-09-30 0.003860
2014-10-01 0.006530
2014-10-02 0.006500
2014-10-03 0.004360
2014-10-06 0.004590
2014-10-07 0.007620
2014-10-08 0.004240
2014-10-09 0.008140
2014-10-09 0.008153
[(’Total Return’, ’9.84%’),
(’Sharpe Ratio’, ’0.54’),
(’Max Drawdown’, ’5.99%’),
(’Drawdown Duration’, ’811’)]
Signals: 270
Orders: 270
Fills: 270</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-e3344c8 elementor-widget elementor-widget-text-editor" data-id="e3344c8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				La seguente figura mostra la curva di equity, i rendimenti giornalieri e il drawdown della strategia in funzione del tempo.
Da notare subito come la performance non è eccezionale! Abbiamo uno Sharpe Ratio &lt;1 ma un ragionevole drawdown di poco inferiore al 6%. Si è scoperto che se avessimo semplicemente acquistato e tenuto SPY in questo periodo di tempo avremmo avuto un risultato simile, anche se leggermente peggiore.<br>
<br>
Quindi non abbiamo effettivamente ottenuto un vantaggio da questa strategia predittiva una volta inclusi i costi di transazione. In particolare, ho voluto includere questo esempio perché utilizza un&#8217;implementazione realistica &#8220;end to end&#8221; di tale strategia che tiene conto dei costi di transazione conservativi e realistici. Come si può vedere non è facile fare una previsione predittiva su dati giornalieri che produca buone prestazioni!					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9943753 elementor-widget elementor-widget-image" data-id="9943753" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="600" height="445" src="https://datatrading.info/wp-content/uploads/2017/09/Forecast_SP500_performance_trading_algoritmico.jpg" class="attachment-large size-large" alt="Forecast_SP500_performance_trading_algoritmico" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2017/09/Forecast_SP500_performance_trading_algoritmico.jpg 600w, https://datatrading.info/wp-content/uploads/2017/09/Forecast_SP500_performance_trading_algoritmico-300x223.jpg 300w, https://datatrading.info/wp-content/uploads/2017/09/Forecast_SP500_performance_trading_algoritmico-160x119.jpg 160w" sizes="(max-width: 600px) 100vw, 600px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d15ada6 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="d15ada6" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-679548c elementor-widget elementor-widget-text-editor" data-id="679548c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/implementazione-di-una-strategia-di-forecasting-sullsp500/">Implementazione di una Strategia di Forecasting sull&#8217;S&#038;P500</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Implementazione di una Strategia di Moving Average Crossover</title>
		<link>https://datatrading.info/implementazione-di-una-strategia-di-moving-average-crossover/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Tue, 15 May 2018 08:27:00 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Strategie]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2219</guid>

					<description><![CDATA[<p>In questo articolo vediamo come implementare una semplice strategia di trading utilizzando il motore backtesting basato sugli eventi, descritto negli articoli precedenti. In particolare vediamo come creare le curve equity utilizzando gli iimporti nozionali di portafoglio, simulando così i concetti di margine / leva finanziaria, che è un approccio molto più realistico rispetto all&#8217;approccio vettorizzato / basato &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/implementazione-di-una-strategia-di-moving-average-crossover/"> <span class="screen-reader-text">Implementazione di una Strategia di Moving Average Crossover</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/implementazione-di-una-strategia-di-moving-average-crossover/">Implementazione di una Strategia di Moving Average Crossover</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2219" class="elementor elementor-2219">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-fbeff9a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="fbeff9a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-e1cbf27" data-id="e1cbf27" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-c37d020 elementor-widget elementor-widget-text-editor" data-id="c37d020" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				In questo articolo vediamo come implementare una semplice strategia di trading utilizzando il motore backtesting basato sugli eventi, descritto negli <a href="https://datatrading.info/motore-di-backtesting-con-python-parte-i-struttura-base/">articoli precedenti</a>. In particolare vediamo come creare le curve equity utilizzando gli iimporti nozionali di portafoglio, simulando così i concetti di margine / leva finanziaria, che è un approccio molto più realistico rispetto all&#8217;approccio vettorizzato / basato sui rendimenti.
<br><br>
Questa prima strategia può essere eseguita con dati liberamente disponibili, sia da Yahoo Finance, Google Finance o Quandl. E&#8217; una strategia adatta per trader algoritmici a lungo termine che desiderano studiare solo l&#8217;aspetto della generazione del segnale di trade della strategia ma anche l&#8217;intero sistema end-to-end. Tali strategie spesso possiedono Sharpe Ratio più piccoli, ma sono molto facili da implementare ed eseguire.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-be63337 elementor-widget elementor-widget-heading" data-id="be63337" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La Strategia di Moving Average Crossover</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-f5fb203 elementor-widget elementor-widget-text-editor" data-id="f5fb203" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Sono un grande sostenitore di sistemi di trading basati sull&#8217;incrocio della media mobile perché è la prima strategia non banale estremamente utile per testare una nuova implementazione di un motore di backtesting. Su un arco temporale giornaliero, su un numero di anni, con lunghi periodi di ricerca, vengono generati pochi segnali su un singolo stock ed è quindi facile verificare manualmente che il sistema si stia comportando come ci si aspetterebbe.</p><p>Per generare effettivamente una tale simulazione basata sul codice di backtesting basato sugli eventi dobbiamo creare una sottoclasse dell&#8217;oggetto <code style="color: #e83e8c;">Strategy</code>, come descritto nell&#8217;<a href="https://datatrading.info/motore-di-backtesting-con-python-parte-iv-gestione-della-strategia/">articolo precedente</a>, per creare l&#8217;oggetto <code style="color: #e83e8c;">MovingAverageCrossStrategy</code>, che conterrà la logica di calcolo delle medie mobili semplici e la generazione dei segnali di trading.<br />Inoltre dobbiamo creare la funzione <code style="color: #e83e8c;">__main__</code> che caricherà l&#8217;oggetto <code style="color: #e83e8c;">Backtest</code> e incapsulerà effettivamente l&#8217;esecuzione del programma. Il seguente file, <code style="color: #e83e8c;">mac.py</code>, contiene entrambi questi oggetti.</p><p>Il primo compito, come sempre, è importare correttamente i componenti necessari. Stiamo importando quasi tutti gli oggetti che costituiscono il motore di backtesting event-driven:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-02b7c8d elementor-widget elementor-widget-bdt-source-code" data-id="02b7c8d" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># mac.py

import datetime
import numpy as np
import pandas as pd
import statsmodels.api as sm
import datetime
import numpy as np
import pandas as pd
import statsmodels.api as sm

from strategy.strategy import Strategy
from event.event import SignalEvent
from backtest.backtest import Backtest
from data.data import HistoricCSVDataHandler
from execution.execution import SimulatedExecutionHandler
from portfolio.portfolio import Portfolio</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-34ae112 elementor-widget elementor-widget-text-editor" data-id="34ae112" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Passiamo ora alla creazione della classe  <code style="color: #e83e8c;">MovingAverageCrossStrategy</code>. La strategia richiede le barre generate da <code style="color: #e83e8c;">DataHandler</code>, gli eventi gestiti da Event Queue e i periodi di ricerca per le medie mobili semplici che verranno impiegate all&#8217;interno della strategia. Per questa strategia consideriamo 100 e 400 come periodi di ricerca &#8220;brevi&#8221; e &#8220;lunghi&#8221; per questa strategia.</p><p>L&#8217;attributo finale, <code style="color: #e83e8c;">bought</code>, viene utilizzato per indicare all&#8217;oggetto <code style="color: #e83e8c;">Strategy</code> quando il backtest è effettivamente &#8220;a mercato&#8221;. I segnali di ingresso vengono generati solo se è &#8220;OUT&#8221; e i segnali di uscita vengono generati solo se è &#8220;LONG&#8221; o &#8220;SHORT&#8221;:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-58eb72e elementor-widget elementor-widget-bdt-source-code" data-id="58eb72e" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># mac.py

class MovingAverageCrossStrategy(Strategy):
    &quot;&quot;&quot;
    Esegue una strategia base di Moving Average Crossover tra due
    medie mobile semplici, una breve e una lunga. Le finestre brevi / lunghe
    sono rispettivamente di 100/400 periodi.
    &quot;&quot;&quot;
    def __init__(self, bars, events, short_window=100, long_window=400):
        &quot;&quot;&quot;
        Initializza la strategia di Moving Average Cross.
        
        Parametri:
        bars - L&#039;oggetto DataHandler object che fornisce le barre dei prezzi
        events - L&#039;oggetto Event Queue.
        short_window - Il periodo per la media mobile breve.
        long_window - Il periodo per la media mobile lunga.
        &quot;&quot;&quot;
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events
        self.short_window = short_window
        self.long_window = long_window

        # Impostato a True se la strategia è a mercato
        self.bought = self._calculate_initial_bought()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-6735d55 elementor-widget elementor-widget-text-editor" data-id="6735d55" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Poiché la strategia inizia fuori dal mercato, impostiamo il valore iniziale &#8220;bought&#8221; su &#8220;OUT&#8221;,
per ogni simbolo:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-714954f elementor-widget elementor-widget-bdt-source-code" data-id="714954f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># mac.py

    def _calculate_initial_bought(self):
        &quot;&quot;&quot;
        Aggiunge keys per ogni simbolo al dizionario bought e le
        imposta a &#039;OUT&#039;.
        &quot;&quot;&quot;
        bought = {}
        for s in self.symbol_list:
            bought[s] = &#039;OUT&#039;
            return bought</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-e81c918 elementor-widget elementor-widget-text-editor" data-id="e81c918" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il fulcro della strategia è il metodo <code style="color: #e83e8c;">prepare_signals</code>. Reagisce a un oggetto <code style="color: #e83e8c;">MarketEvent</code> e per ogni simbolo di trading acquisisce gli prezzi di chiusura delle ultime N barre, dove N è uguale al periodo di ricerca più ampio.</p><p>Quindi si calcola le medie mobili semplici di breve e lungo periodo. La regola della strategia è entrare a mercato (andare long su un&#8217;azione) quando il valore della media mobile breve supera il valore della media mobile lunga. Al contrario, se il valore della media mobile lunga supera il valore della media mobile breve, alla strategia viene detto di uscire dal mercato.<br /><br />Questa logica viene gestita posizionando un oggetto <code style="color: #e83e8c;">SignalEvent</code> sulla coda degli eventi degli eventi in ciascuna delle rispettive situazioni e quindi aggiornando l&#8217;attributo &#8220;bought&#8221; (per ogni simbolo) in modo che sia rispettivamente &#8220;LONG&#8221; o &#8220;SHORT&#8221;. Poiché questa è una strategia solo long, non prenderemo in considerazione le posizioni &#8220;SHORT&#8221;:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-66d4643 elementor-widget elementor-widget-bdt-source-code" data-id="66d4643" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># mac.py

    def calculate_signals(self, event):
        &quot;&quot;&quot;
        Genera un nuovo set di segnali basato sull&#039;incrocio della
        SMA di breve periodo con quella a lungo periodo che
        significa un&#039;entrata long e viceversa per un&#039;entrata short.

        Parametri
        event - Un oggetto MarketEvent.
        &quot;&quot;&quot;
        if event.type == &#039;MARKET&#039;:
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars_values(
                    s, &quot;adj_close&quot;, N=self.long_window
                )
                bar_date = self.bars.get_latest_bar_datetime(s)
                if bars is not None and bars != []:
                    short_sma = np.mean(bars[-self.short_window:])
                    long_sma = np.mean(bars[-self.long_window:])
                    symbol = s
                    dt = datetime.datetime.utcnow()
                    sig_dir = &quot;&quot;
                    if short_sma &gt; long_sma and self.bought[s] == &quot;OUT&quot;:
                        print(&quot;LONG: %s&quot; % bar_date)
                        sig_dir = &#039;LONG&#039;

                        signal = SignalEvent(1, symbol, dt, sig_dir, 1.0)
                        self.events.put(signal)
                        self.bought[s] = &#039;LONG&#039;
                    elif short_sma &lt; long_sma and self.bought[s] == &quot;LONG&quot;:
                        print(&quot;SHORT: %s&quot; % bar_date)
                        sig_dir = &#039;EXIT&#039;
                        signal = SignalEvent(1, symbol, dt, sig_dir, 1.0)
                        self.events.put(signal)
                        self.bought[s] = &#039;OUT&#039;</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-aadc989 elementor-widget elementor-widget-text-editor" data-id="aadc989" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Questo conclude l&#8217;implementazione dell&#8217;oggetto <code style="color: #e83e8c;">MovingAverageCrossStrategy</code>. Il compito finale dell&#8217;intero sistema di backtest è implementare un metodo <code style="color: #e83e8c;">__main__</code> in mac.py per eseguire effettivamente il backtest.<br><br>

Innanzitutto, bisogna assicursi di modificare il valore di csv_dir con percorso assoluto della directory dove si trovano i file CSV per i dati finanziari. Si dovrà anche scaricare il file CSV del titolo AAPL (da Yahoo Finance), che è fornito dal seguente link (dal 1 ° gennaio 1990 al 1 ° gennaio 2002), dato che questo è il titolo su cui testeremo la strategia:<br>
https://query1.finance.yahoo.com/v7/finance/download/AAPL?period1=631152000&amp;period2=1009843200&amp;interval=1d&amp;events=history&amp;includeAdjustedClose=true<br>
<br>
E&#8217; quindi necessario inserire questo file nel percorso indicato dalla funzione principale in csv_dir.
La funzione <code style="color: #e83e8c;">__main__</code> crea semplicemente un&#8217;istanza di un nuovo oggetto di backtest e quindi chiama il metodo <code style="color: #e83e8c;">simulate_trading</code> per eseguire il backtest:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bc596ad elementor-widget elementor-widget-bdt-source-code" data-id="bc596ad" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># mac.py

if __name__ == &quot;__main__&quot;:
    csv_dir = &#039;/path/to/your/csv/file&#039; # DA MODIFICARE
    symbol_list = [&#039;AAPL&#039;]
    initial_capital = 100000.0
    heartbeat = 0.0
    start_date = datetime.datetime(1990, 1, 1, 0, 0, 0)
    backtest = Backtest(csv_dir, symbol_list, initial_capital, heartbeat, start_date, 
                        HistoricCSVDataHandler, SimulatedExecutionHandler, Portfolio, 
                        MovingAverageCrossStrategy)
    backtest.simulate_trading()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-64978c9 elementor-widget elementor-widget-text-editor" data-id="64978c9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per eseguire il codice, bisogna avere aver già configurato un ambiente Python (come descritto nei <a href="https://datatrading.info/installazione-di-un-ambiente-desktop-per-il-trading-algoritmico-utilizzando-ubuntu-linux-e-python/">precedenti articoli</a>) e poi navigare nella directory in cui è memorizzato il codice.<br />Si dovrà semplicemente lanciare il seguente comando:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3a20cfc elementor-widget elementor-widget-bdt-source-code" data-id="3a20cfc" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>python mac.py</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-174d964 elementor-widget elementor-widget-text-editor" data-id="174d964" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Lo script restituisce il seguente
elenco (troncato a causa della stampa del conteggio delle barre!)					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-187ad16 elementor-widget elementor-widget-bdt-source-code" data-id="187ad16" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-coy">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>..
..
3029
3030
Creating summary stats...
Creating equity curve...
AAPL cash commission total returns equity_curve drawdown
datetime
2001-12-18 0 99211 13 99211 0 0.99211 0.025383
2001-12-19 0 99211 13 99211 0 0.99211 0.025383
2001-12-20 0 99211 13 99211 0 0.99211 0.025383
2001-12-21 0 99211 13 99211 0 0.99211 0.025383
2001-12-24 0 99211 13 99211 0 0.99211 0.025383
2001-12-26 0 99211 13 99211 0 0.99211 0.025383
2001-12-27 0 99211 13 99211 0 0.99211 0.025383
2001-12-28 0 99211 13 99211 0 0.99211 0.025383
2001-12-31 0 99211 13 99211 0 0.99211 0.025383
2001-12-31 0 99211 13 99211 0 0.99211 0.025383
[(’Total Return’, ’-0.79%’),
(’Sharpe Ratio’, ’-0.09’),
(’Max Drawdown’, ’2.56%’),
(’Drawdown Duration’, ’2312’)]
Signals: 10
Orders: 10
Fills: 10</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-55f6a98 elementor-widget elementor-widget-text-editor" data-id="55f6a98" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>La performance di questa strategia è visualizzata nella seguente figura:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-226a0be elementor-widget elementor-widget-image" data-id="226a0be" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="600" height="388" src="https://datatrading.info/wp-content/uploads/2020/10/SMA_performance_trading_algoritmico.jpg" class="attachment-large size-large" alt="SMA_performance_trading_algoritmico" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2020/10/SMA_performance_trading_algoritmico.jpg 600w, https://datatrading.info/wp-content/uploads/2020/10/SMA_performance_trading_algoritmico-300x194.jpg 300w, https://datatrading.info/wp-content/uploads/2020/10/SMA_performance_trading_algoritmico-160x103.jpg 160w" sizes="(max-width: 600px) 100vw, 600px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-528f932 elementor-widget elementor-widget-text-editor" data-id="528f932" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				E&#8217; evidente che i rendimenti e lo Sharpe Ratio non sono stellari per le azioni AAPL su questo particolare set di indicatori tecnici! <br>
Chiaramente abbiamo molto lavoro da fare nella prossima serie di strategie per trovare un sistema in grado di generare performance positive.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0353adf elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="0353adf" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-fc16b84 elementor-widget elementor-widget-text-editor" data-id="fc16b84" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven DataBacktest si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DataBacktest">https://github.com/datatrading-info/DataBacktest</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/implementazione-di-una-strategia-di-moving-average-crossover/">Implementazione di una Strategia di Moving Average Crossover</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DTForex #7 &#8211; Nuova Interfaccia di Backtesting</title>
		<link>https://datatrading.info/dtforex-7-nuova-interfaccia-di-backtesting/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Thu, 29 Jun 2017 14:28:00 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Forex]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2503</guid>

					<description><![CDATA[<p>In questo articolo descriviamo come semplificare l&#8217;interfaccia per costruire un nuovo backtest, incapsulando molto del codice &#8220;boilerplate&#8221; in una nuova classe Backtest. Inoltre vediamo come modificare il sistema per poter gestire più coppie di valute. Infine vediamo come testare la nuova interfaccia tramite la solita strategia di esempio di Moving Average Crossover, sia su GBP/USD &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/dtforex-7-nuova-interfaccia-di-backtesting/"> <span class="screen-reader-text">DTForex #7 &#8211; Nuova Interfaccia di Backtesting</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/dtforex-7-nuova-interfaccia-di-backtesting/">DTForex #7 &#8211; Nuova Interfaccia di Backtesting</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2503" class="elementor elementor-2503">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-97836be elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="97836be" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-28f02f4" data-id="28f02f4" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-38f96c1 elementor-widget elementor-widget-text-editor" data-id="38f96c1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo descriviamo come semplificare l&#8217;interfaccia per costruire un nuovo backtest, incapsulando molto del codice &#8220;boilerplate&#8221; in una nuova classe <code>Backtest</code>. Inoltre vediamo come modificare il sistema per poter gestire più coppie di valute.</p><p>Infine vediamo come testare la nuova interfaccia tramite la solita strategia di esempio di Moving Average Crossover, sia su GBP/USD che su EUR/USD.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-92fb14f elementor-widget elementor-widget-heading" data-id="92fb14f" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Nuova Interfaccia di Backtest</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-d511772 elementor-widget elementor-widget-text-editor" data-id="d511772" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Abbiamo modificato l&#8217;interfaccia di backtest in modo tale da creare </span>semplicemente un&#8217;istanza di <code>Backtest</code>e popolarla con i componenti di trading, <span>invece di dover creare un file  </span><code>backtest.py</code> <span>file personalizzato come in precedenza.</span></p><p><span>Il modo migliore per iniziare con il nuovo approccio è dare un&#8217;occhiata alla directory  </span><code>examples/</code><span> e aprire </span><code>mac.py</code><span>:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0e46c79 elementor-widget elementor-widget-bdt-source-code" data-id="0e46c79" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>from backtest import Backtest
from execution import SimulatedExecution
from portfolio import Portfolio
from settings import settings
from strategy import MovingAverageCrossStrategy
from data.price import HistoricCSVPriceHandler

if __name__ == &quot;__main__&quot;:
    # Trading su GBP/USD e EUR/USD
    pairs = [&quot;GBPUSD&quot;, &quot;EURUSD&quot;]

    # Crea i parametri della strategia per MovingAverageCrossStrategy
    strategy_params = {
        &quot;short_window&quot;: 500,
        &quot;long_window&quot;: 2000
    }

    # Crea ed esegue il backtest
    backtest = Backtest(
        pairs, HistoricCSVPriceHandler,
        MovingAverageCrossStrategy, strategy_params,
        Portfolio, SimulatedExecution,
        equity=settings.EQUITY
    )
    backtest.simulate_trading()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-e7230ce elementor-widget elementor-widget-text-editor" data-id="e7230ce" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il codice è relativamente semplice. In primo luogo il codice importa i componenti necessari, ovvero il </span><code>Backtest</code><span>, </span><code>SimulatedExecution</code><span>, </span><code>Portfolio</code><span>, </span><code>MovingAverageCrossStrategy</code> <span>e </span><code>HistoricCSVPriceHandler</code><span>.</span></p><p><span>In secondo luogo, definiamo le coppie di valute da negoziare e quindi creiamo un dizionario noto come </span><code>strategy_params</code><span>. Questo contiene essenzialmente qualsiasi argomento delle key words che potremmo voler passare alla strategia. Nel caso di un Moving Average Crossover dobbiamo impostare le lunghezze dei periodi delle medie mobili. Questi valori sono in termini di &#8220;tick&#8221;.</span></p><p><span>Infine creiamo un&#8217;istanza </span><code>Backtest</code><span> e passiamo tutti gli oggetti come parametri. Quindi, eseguiamo il backtest stesso.</span></p><p><span>All&#8217;interno del nuovo </span><code>backtest.py</code> <span>chiamiamo questo metodo:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5a5b7d6 elementor-widget elementor-widget-bdt-source-code" data-id="5a5b7d6" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># backtest.py
..
..
    def simulate_trading(self):
        &quot;&quot;&quot;
        Simula il backtest e calcola le performance del portfolio
        &quot;&quot;&quot;
        self._run_backtest()
        self._output_performance()
        print(&quot;Backtest complete.&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-23bb0c2 elementor-widget elementor-widget-text-editor" data-id="23bb0c2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Esegue il calcolo del backtest (ovvero l&#8217;aggiornamento del portafoglio all&#8217;arrivo dei tick), nonché il calcolo e l&#8217;output delle prestazioni in </span><code>equity.csv</code><span>.</span></p><p><span>Come descritto negli articoli precedenti, possiamo ancora produrre un grafico dell&#8217;output con lo script </span><code>backtest/output.py</code><span>. Useremo questo script di seguito quando discuteremo dell&#8217;implementazione di più coppie di valute.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-856dacc elementor-widget elementor-widget-heading" data-id="856dacc" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Gestione di più Coppie di Valute</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-98160a8 elementor-widget elementor-widget-text-editor" data-id="98160a8" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Siamo finalmente in grado di  testare la prima strategia di trading (non banale) su dati di tick ad alta frequenza per più coppie di valute!</span></p><p><span>A tale scopo è necessario modificare le modalità di gestione all&#8217;interno di </span><code>MovingAverageCrossStrategy</code><span>.</span></p><p><span>Di seguito il codice completo:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8530ce3 elementor-widget elementor-widget-bdt-source-code" data-id="8530ce3" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class MovingAverageCrossStrategy(object):
    &quot;&quot;&quot;
    Una strategia base di Moving Average Crossover che genera
    due medie mobili semplici (SMA), con finestre predefinite
    di 500 tick per la SMA  breve e 2.000 tick per la SMA
    lunga.

    La strategia è &quot;solo long&quot; nel senso che aprirà solo una
    posizione long una volta che la SMA breve supera la SMA
    lunga. Chiuderà la posizione (prendendo un corrispondente
    ordine di vendita) quando la SMA lunga incrocia nuovamente
    la SMA breve.

    La strategia utilizza un calcolo SMA a rotazione per
    aumentare l&#039;efficienza eliminando la necessità di chiamare due
    calcoli della media mobile completa su ogni tick.
    &quot;&quot;&quot;
    def __init__(
            self, pairs, events,
            short_window=500, long_window=2000
    ):
        self.pairs = pairs
        self.pairs_dict = self.create_pairs_dict()
        self.events = events
        self.short_window = short_window
        self.long_window = long_window

    def create_pairs_dict(self):
        attr_dict = {
            &quot;ticks&quot;: 0,
            &quot;invested&quot;: False,
            &quot;short_sma&quot;: None,
            &quot;long_sma&quot;: None
        }
        pairs_dict = {}
        for p in self.pairs:
            pairs_dict[p] = copy.deepcopy(attr_dict)
        return pairs_dict

    def calc_rolling_sma(self, sma_m_1, window, price):
        return ((sma_m_1 * (window - 1)) + price) / window

    def calculate_signals(self, event):
        if event.type == &#039;TICK&#039;:
            pair = event.instrument
            price = event.bid
            pd = self.pairs_dict[pair]
            if pd[&quot;ticks&quot;] == 0:
                pd[&quot;short_sma&quot;] = price
                pd[&quot;long_sma&quot;] = price
            else:
                pd[&quot;short_sma&quot;] = self.calc_rolling_sma(
                    pd[&quot;short_sma&quot;], self.short_window, price
                )
                pd[&quot;long_sma&quot;] = self.calc_rolling_sma(
                    pd[&quot;long_sma&quot;], self.long_window, price
                )
            # Si avvia la strategia solamente dopo aver creato una 
            # accurata finestra di breve periodo
            if pd[&quot;ticks&quot;] &gt; self.short_window:
                if pd[&quot;short_sma&quot;] &gt; pd[&quot;long_sma&quot;] and not pd[&quot;invested&quot;]:
                    signal = SignalEvent(pair, &quot;market&quot;, &quot;buy&quot;, event.time)
                    self.events.put(signal)
                    pd[&quot;invested&quot;] = True
                if pd[&quot;short_sma&quot;] &lt; pd[&quot;long_sma&quot;] and pd[&quot;invested&quot;]:
                    signal = SignalEvent(pair, &quot;market&quot;, &quot;sell&quot;, event.time)
                    self.events.put(signal)
                    pd[&quot;invested&quot;] = False
            pd[&quot;ticks&quot;] += 1
                </code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-1727d9a elementor-widget elementor-widget-text-editor" data-id="1727d9a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Essenzialmente creiamo un dizionario degli attributi </span><code>attr_dict</code> <span>che memorizza il numero di tick trascorsi e se la strategia è &#8220;a mercato&#8221; per quella particolare coppia.</span></p><p><span>In </span><code>calculate_signals</code> <span>aspettiamo di ricevere un </span><code>TickEvent</code><span> e quindi calcoliamo le medie mobili semplici per il breve e lungo periodo. Una volta che la SMA breve incrocia al rialzo la SMA lunga per una particolare coppia, la strategia va long ed esce nel modo visto nei precedenti articoli, sebbene lo faccia separatamente per ciascuna coppia.</span></p><p><span>Abbiamo utilizzato 2 mesi di dati sia per GBP/USD che per EUR/USD e il backtest richiede un po &#8216;di tempo per essere eseguito. </span><span>Tuttavia, una volta completato il backtest, siamo in grado di utilizzare </span><code>backtest/output.py</code> <span>per produrre il seguente grafico delle prestazioni:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-77dc0e4 elementor-widget elementor-widget-image" data-id="77dc0e4" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="1551" height="1061" src="https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results.png" class="attachment-large size-large" alt="trading-algoritmico-forex-7-mac-results" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results.png 1551w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results-300x205.png 300w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results-160x109.png 160w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results-768x525.png 768w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-7-mac-results-1536x1051.png 1536w" sizes="(max-width: 1551px) 100vw, 1551px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-95c974f elementor-widget elementor-widget-text-editor" data-id="95c974f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Chiaramente le prestazioni non sono eccezionali in quanto la strategia rimane quasi interamente &#8220;sott&#8217;acqua&#8221; col passare del tempo. Detto questo, non dovremmo aspettarci molto da una strategia di base sui dati tick ad alta frequenza. In futuro esamineremo approcci molto più sofisticati al trading su questa scala temporale.</span></p><p><span>Si spera che questo sistema possa fornire un utile punto di partenza per lo sviluppo di strategie più sofisticate. Non vedo l&#8217;ora di scoprire cosa inventeranno gli altri nel prossimo futuro!</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-947704d elementor-widget elementor-widget-heading" data-id="947704d" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Conclusioni</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-2506ec3 elementor-widget elementor-widget-text-editor" data-id="2506ec3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questa serie di articoli abbiamo visto le basi di un sistema di trading automatico sul mercato del Forex , implementato in Python. Nonostante il sistema sia completo di funzionalità per il backtest e il paper/live trading, ci sono ancora molti aspetti su cui lavorare.</p><p>In particolare si può rendere il sistema molto più veloce, in modo da permettere di effettuare ricerche di parametri in tempi ragionevoli. Sebbene Python sia un ottimo strumento, uno svantaggio è che è relativamente lento rispetto a C / C ++. Quindi si può lavorare sul cercare di migliorare la velocità di esecuzione sia del backtest che dei calcoli delle prestazioni.</p><p>Inoltre, un altro aspetto che merita di essere implementato è la gestione di altri tipi di ordine rispetto al semplice ordine di mercato. Per attuare adeguate strategie HFT sul broker OANDA dovremo utilizzare gli ordini limite. Ciò richiederà probabilmente una rielaborazione del modo in cui il sistema esegue attualmente le operazioni, ma consentirà di realizzare un universo molto più ampio di strategie di trading.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-60896d6 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="60896d6" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-1141505 elementor-widget elementor-widget-text-editor" data-id="1141505" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven per il forex (DTForex) si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DTForex">https://github.com/datatrading-info/DTForex</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/dtforex-7-nuova-interfaccia-di-backtesting/">DTForex #7 &#8211; Nuova Interfaccia di Backtesting</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>DTForex #6 &#8211; Backtesting su più giorni e Visualizzazione dei Risultati</title>
		<link>https://datatrading.info/dtforex-6-backtesting-su-piu-giorni-e-visualizzazione-dei-risultati/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sun, 25 Jun 2017 12:02:00 +0000</pubDate>
				<category><![CDATA[Tutorial Strategie Sistematiche]]></category>
		<category><![CDATA[Tutorial Forex]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=2492</guid>

					<description><![CDATA[<p>In questo articolo descriviamo le ultime modifiche che abbiamo inserito nel sistema di trading sul mercato forex. In particolare abbiamo aggiunto alcune nuove funzionalità tra cui: Documentazione : ora ho creato una sezione DTForex sul sito, che include tutti gli articoli della serie sul  trading algoritmo per il Forex e la documentazione per DTForex. In particolare, include &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/dtforex-6-backtesting-su-piu-giorni-e-visualizzazione-dei-risultati/"> <span class="screen-reader-text">DTForex #6 &#8211; Backtesting su più giorni e Visualizzazione dei Risultati</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/dtforex-6-backtesting-su-piu-giorni-e-visualizzazione-dei-risultati/">DTForex #6 &#8211; Backtesting su più giorni e Visualizzazione dei Risultati</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="2492" class="elementor elementor-2492">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-e35f6ee elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="e35f6ee" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-dc0b0c5" data-id="dc0b0c5" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-4744d51 elementor-widget elementor-widget-text-editor" data-id="4744d51" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo articolo descriviamo le ultime modifiche che abbiamo inserito nel sistema di trading sul mercato forex. In particolare abbiamo aggiunto alcune nuove funzionalità tra cui:</p><ul><li><strong>Documentazione</strong> : ora ho creato una <a href="http://datatrading.info/DTForex">sezione DTForex</a> sul sito, che include tutti gli articoli della serie sul  trading algoritmo per il Forex e la documentazione per DTForex. In particolare, include istruzioni dettagliate per l&#8217;installazione e una guida all&#8217;uso sia per il backtesting che per il trading dal vivo.</li><li><strong>Generazione di dati tick simulati</strong> &#8211; Dal momento che è difficile scaricare in blocco molti dati tick sul forex (o almeno per alcuni dei data provider che uso!) ho deciso che sarebbe stato più semplice generare semplicemente alcuni dati tick casuali per testare il sistema.</li><li><strong>Backtest di più giorni</strong> &#8211; Una funzionalità essenziale per il sistema DTForex è la capacità di eseguire il backtest su più giorni di dati tick. L&#8217;ultima versione di DTForex supporta sia il backtesting di più giorni che quello di più coppie di valute, rendendolo sostanzialmente più utile.</li><li><strong>Tracciare i risultati del backtesting</strong> &#8211; Sebbene l&#8217;output della console sia utile, niente batte la possibilità di visualizzare una curva di equity e un drawdown storico. Ho utilizzato la <a href="http://seaborn.pydata.org/">libreria Seaborn</a> per tracciare i vari grafici delle prestazioni.</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-84064ea elementor-widget elementor-widget-heading" data-id="84064ea" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Script per Simulare i Dati di Tick</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-61bd786 elementor-widget elementor-widget-text-editor" data-id="61bd786" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Una caratteristica estremamente importante per un sistema di trading è la capacità di eseguire un backtest su dati di tick storici che coprono un periodo di tempo di più giorni . In precedenza il sistema prevedeva solo il backtest tramite un singolo file. Questa non era una soluzione scalabile in quanto tale file deve essere caricato in memoria e poi strutturato in <a href="https://pandas.pydata.org/pandas-docs/dev/reference/api/pandas.DataFrame.html">DataFrame di pandas</a> . Sebbene i file di dati dei tick prodotti non siano enormi (circa 3,5 MB ciascuno), si sommano rapidamente se consideriamo più coppie di valute per periodi di mesi o anche più.</p><p>Per iniziare a creare una funzionalità per più giorni / più file, si inizia a scaricare più file dal <a href="https://www.dukascopy.com/swiss/english/marketwatch/historical/">feed tick storico di DukasCopy</a> . Purtroppo ho avuto qualche problema e non sono riuscito a scaricare i file necessari per testare il sistema.</p><p>Dal momento che non è essenziale avere serie temporali storiche per testare il sistema, può essere più semplice scrivere uno script per generare automaticamente dei dati di tick simulati. Questo script è stato inserito nel file <code>scripts/generate_simulated_pair.py</code>. Il codice può essere visionato <a href="https://github.com/datatrading-info/DTForex/blob/main/scripts/generate_simulated_pair.py">qui</a> .</p><p>L&#8217;idea di base dello script è generare un elenco di timestamp distribuiti in modo casuale, ognuno dei quali possiede sia valori bid/ask che valori di volume. Lo spread tra l&#8217;offerta e la domanda è costante, mentre i valori bid / ask stessi sono generati come un random walk.</p><p>Dal momento che non si testerà mai alcuna strategia <em>reale</em> con questi dati, non c&#8217;è bisogno di preoccuparsi  delle sue proprietà statistiche o dei suoi valori assoluti in relazione alle coppie di valute forex reali. Finché si garantisce il corretto formato e una lunghezza approssimativa, si può usare  per testare il sistema di backtesting di più giorni.</p><p>Lo script è attualmente codificato per generare dati forex per l&#8217;intero mese di gennaio 2017. Utilizza la libreria <a href="https://docs.python.org/3/library/calendar.html">Calendar</a> di Python per considerare i giorni lavorativi (anche se non abbiamo ancora escluso le festività) e quindi genera una serie di file nel formato <code>BBBQQQ_YYYYMMDD.csv</code>, dove <code>BBBQQQ</code>sarà una specifica coppia di valute specificata (es. <code>EURUSD</code>) ed <code>YYYYMMDD</code> è la data specificata (es <code>20170112</code>.).</p><p>Questi file vengono inseriti nella directory  <code>CSV_DATA_DIR</code>, che è specificata file  <code>settings.py</code>  dell&#8217;applicazione.</p><p>Per generare i dati è necessario eseguire il seguente comando, dove <code>BBBQQQ</code>deve essere sostituito con lo specifico della valuta di interesse, es <code>EURUSD</code>:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-026eba4 elementor-widget elementor-widget-bdt-source-code" data-id="026eba4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>python scripts/generate_simulated_pair.py BBBQQQ</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-5fefb3f elementor-widget elementor-widget-text-editor" data-id="5fefb3f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Il file richiederà una modifica per generare dati per più mesi o anni. Ogni file di tick giornalieri ha una dimensione dell&#8217;ordine di 3,2 MB.</span></p><p><span>In futuro si modificherà questo script per generare dati per un periodo di più mesi o anni in base a uno specifico elenco di coppie di valute, anziché i valori codificati. Tuttavia, per il momento questo è sufficiente per iniziare.</span></p><p><span>Si tenga presente che il formato corrisponde esattamente a quello dei dati storici dei tick forniti da DukasCopy, che è il set di dati che stiamo attualmente utilizzando.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5bf68ce elementor-widget elementor-widget-heading" data-id="5bf68ce" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Implementazione di un Backtesting per più giorni</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-0b76504 elementor-widget elementor-widget-text-editor" data-id="0b76504" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Successivamente alla generazione di dati tick simulati, si passa all&#8217;implementazione del backtesting per più giorni. <span style="color: var( --e-global-color-text ); font-size: 1rem;">Sebbene il piano a lungo termine prevede di utilizzare un sistema di archiviazione di dati storico più robusto come </span><a style="background-color: #ffffff; font-size: 1rem;" href="https://web.archive.org/web/20151018170507/http://www.pytables.org/">PyTables</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> con </span><a style="background-color: #ffffff; font-size: 1rem;" href="https://web.archive.org/web/20151018170507/https://www.hdfgroup.org/HDF5/">HDF5</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> , per il momento si utilizza un set di file CSV, un file per ogni giorno per ogni coppia di valute.</span></p><p>Questa è una soluzione scalabile all&#8217;aumentare del numero di giorni. La natura event-driven del sistema richiede che siano presenti solo \(N\) file in memoria contemporaneamente, dove \(N\) è il numero di coppie di valute scambiate in un particolare giorno.</p><p>L&#8217;idea di base del sistema prevede che la classe <code>HistoricCSVPriceHandler</code> continui a utilizzare il metodo <code>stream_next_tick</code>, ma con una modifica per tenere conto di dati per più giorni caricando ogni giorno di dati in modo sequenziale.</p><p>L&#8217;implementazione prevede di terminare il backtest quando si riceve l&#8217;eccezione <code>StopIteration </code>generata dal metodo <code>next(..) </code>per <code>self.all_pairs </code>come mostrato in questo frammento di pseudocodice:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1a86fae elementor-widget elementor-widget-bdt-source-code" data-id="1a86fae" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># price.py

..
..

def stream_next_tick(self):
	  ..
	  ..
    try:
        index, row = next(self.all_pairs)
    except StopIteration:
        return
    else:
    	..
    	..
      # Aggiungere un tick alla coda</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-6541380 elementor-widget elementor-widget-text-editor" data-id="6541380" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Nella nuova implementazione, questo snippet viene modificato come segue:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ae10737 elementor-widget elementor-widget-bdt-source-code" data-id="ae10737" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># price.py

..
..

def stream_next_tick(self):
    ..
    ..
    try:
        index, row = next(self.cur_date_pairs)
    except StopIteration:
        # Fine dei dati per l&#039;attuale giorno
        if self._update_csv_for_day():
            index, row = next(self.cur_date_pairs)
        else: # Fine dei dati
            self.continue_backtest = False
            return

    ..
    ..

    # Aggiunta del tick nella coda</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-dd2f84b elementor-widget elementor-widget-text-editor" data-id="dd2f84b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>In questo frammento, quando viene generato un  </span><code>StopIteration</code><span>, il codice verifica il risultato di </span><code>self._update_csv_for_day()</code><span>. Se il risultato è </span><code>True</code> <span>il backtest continua (il </span><code>self.cur_date_pairs</code><span>, che potrebbe essere stato modificato nei dati dei giorni successivi). Se il risultato è </span><code>False</code><span>, il backtest termina.</span></p><p><span>Questo approccio è molto efficiente in termini di memoria poiché solo un limitato numero di giorni di dati è caricato in un punto qualsiasi. Significa che possiamo potenzialmente eseguire mesi di backtesting e siamo limitati solo dalla velocità di elaborazione della CPU e dalla quantità di dati che possiamo generare o acquisire.</span></p><p><span>Abbiamo quindi aggiornato la </span><span>documentazione</span><span> per riflettere il fatto che il sistema ora si aspetta più giorni di dati in un formato particolare, in una directory particolare che deve essere specificata.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-712b155 elementor-widget elementor-widget-heading" data-id="712b155" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Rappresentazione Grafica dei Risultati del Backtest tramite la libreria Seaborn</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-5d79ea3 elementor-widget elementor-widget-text-editor" data-id="5d79ea3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Un backtest è relativamente inutile se non siamo in grado di visualizzare le prestazioni della strategia nel tempo. Sebbene il sistema sia stato per lo più basato su console fino ad oggi, in questo articolo iniziamo ad introdurre le basi per un&#8217;interfaccia utente grafica (GUI).</p><p>In particolare, iniziamo con creare i soliti &#8220;tre pannelli&#8221; di grafici che spesso accompagnano le metriche di performance per i sistemi di trading quantitativo, vale a dire la curva equity, il profilo dei rendimenti e la curva dei drawdown. Tutti e tre vengono calcolati per ogni tick e vengono emessi in un file chiamato <code>equity.csv</code> nella directory specificata in  <code>OUTPUT_RESULTS_DIR</code> presente in <code>settings.py</code>.</p><p>Per visualizzare i dati utilizziamo una libreria chiamata <a href="http://seaborn.pydata.org/">Seaborn</a> , che produce grafica di qualità elevata che ha un aspetto sostanzialmente migliore rispetto ai grafici predefiniti prodotti da Matplotlib. <span style="color: var( --e-global-color-text ); font-size: 1rem;">La grafica è molto simile a quella prodotta dal pacchetto </span><a style="background-color: #ffffff; font-size: 1rem;" href="https://ggplot2.tidyverse.org/">ggplot2</a><span style="color: var( --e-global-color-text ); font-size: 1rem;"> di R. Inoltre Seaborn si basa effettivamente  su Matplotlib, quindi si puo ancora utilizzare l&#8217;API Matplotlib.</span></p><p>Per consentire la visualizzazione dei risultati abbiamo creato lo script <code>output.py</code> che risiede nella directory <code>backtest/</code>. Il codice dello script è il seguente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-68fc696 elementor-widget elementor-widget-bdt-source-code" data-id="68fc696" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># output.py

import os, os.path

import pandas as pd
import matplotlib
try:
    matplotlib.use(&#039;TkAgg&#039;)
except:
    pass
import matplotlib.pyplot as plt
import seaborn as sns

from qsforex.settings import OUTPUT_RESULTS_DIR


if __name__ == &quot;__main__&quot;:
    &quot;&quot;&quot;
    A simple script to plot the balance of the portfolio, or
    &quot;equity curve&quot;, as a function of time.

    It requires OUTPUT_RESULTS_DIR to be set in the project
    settings.
    &quot;&quot;&quot;
    sns.set_palette(&quot;deep&quot;, desat=.6)
    sns.set_context(rc={&quot;figure.figsize&quot;: (8, 4)})

    equity_file = os.path.join(OUTPUT_RESULTS_DIR, &quot;equity.csv&quot;)
    equity = pd.io.parsers.read_csv(
        equity_file, parse_dates=True, header=0, index_col=0
    )

    # Plot three charts: Equity curve, period returns, drawdowns
    fig = plt.figure()
    fig.patch.set_facecolor(&#039;white&#039;)     # Set the outer colour to white
    
    # Plot the equity curve
    ax1 = fig.add_subplot(311, ylabel=&#039;Portfolio value&#039;)
    equity[&quot;Equity&quot;].plot(ax=ax1, color=sns.color_palette()[0])

    # Plot the returns
    ax2 = fig.add_subplot(312, ylabel=&#039;Period returns&#039;)
    equity[&#039;Returns&#039;].plot(ax=ax2, color=sns.color_palette()[1])

    # Plot the returns
    ax3 = fig.add_subplot(313, ylabel=&#039;Drawdowns&#039;)
    equity[&#039;Drawdown&#039;].plot(ax=ax3, color=sns.color_palette()[2])

    # Plot the figure
    plt.show()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-45407e0 elementor-widget elementor-widget-text-editor" data-id="45407e0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come puoi vedere, lo script importa Seaborn e apre il file <code>equity.csv</code> in un DataFrame pandas, quindi crea semplicemente tre grafici, rispettivamente per la curva di equity, i rendimenti e il drawdown.</p><p>Nota che il grafico di drawdown stesso è effettivamente calcolato da una funzione di supporto che risiede <code>performance/performance.py</code>, che viene chiamata dalla classe <code>Portfolio</code> alla fine di un backtest.</p><p>Un esempio dell&#8217;output per la strategia <code>MovingAverageCrossStrategy</code>, per un set di dati di EURUSD generato casualmente per il mese di gennaio 2017, è il seguente: </p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d9538fd elementor-widget elementor-widget-image" data-id="d9538fd" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="1433" height="1023" src="https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-6-output.png" class="attachment-large size-large" alt="trading-algoritmico-forex-6-output" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-6-output.png 1433w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-6-output-300x214.png 300w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-6-output-160x114.png 160w, https://datatrading.info/wp-content/uploads/2017/11/trading-algoritmico-forex-6-output-768x548.png 768w" sizes="(max-width: 1433px) 100vw, 1433px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e8e2806 elementor-widget elementor-widget-text-editor" data-id="e8e2806" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>In particolare, è possibile vedere le sezioni piatte della curva azionaria nei fine settimana in cui non sono presenti dati (almeno, per questo set di dati simulato). Inoltre, la strategia perde denaro in modo piuttosto prevedibile </span><em><span>su questo set di dati simulato in modo casuale</span></em><span>.</span></p><p><span>Questo è un buon test del sistema. Stiamo semplicemente tentando di seguire una tendenza su una serie temporale generata casualmente. Le perdite si verificano a causa dello spread fisso introdotto nel processo di simulazione.</span></p><p><span>Ciò rende palese che se vogliamo realizzare un profitto consistente nel trading forex con frequenze più alte avremo bisogno di uno </span><em><span>specifico vantaggio quantificabile</span></em><span> che generi rendimenti positivi oltre i costi di transazione come spread e slippage.</span></p><p><span>Avremo molto altro da dire su questo punto estremamente importante nei prossimi articoli di questa serie sul trading algoritmico del Forex.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-00cc261 elementor-widget elementor-widget-heading" data-id="00cc261" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Prossimi Passi</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-47e7f30 elementor-widget elementor-widget-heading" data-id="47e7f30" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h5 class="elementor-heading-title elementor-size-default">Calcoli della posizione di fissaggio</h5>		</div>
				</div>
				<div class="elementor-element elementor-element-3af9f3e elementor-widget elementor-widget-text-editor" data-id="3af9f3e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="color: var( --e-global-color-text ); font-size: 1rem;">Abbiamo notato che i calcoli effettuati dalla classe </span><code>Position</code><span style="color: var( --e-global-color-text ); font-size: 1rem;"> non rispecchiano esattamente il modo in cui OANDA (il broker utilizzato per il sistema </span><code>trading.py</code><span style="color: var( --e-global-color-text ); font-size: 1rem;">) calcola i trade di cross valutari.</span></p><p>Quindi, uno dei passaggi successivi più importanti è eseguire e testare effettivamente le nuove modifiche al file <code>position.py </code>e aggiornare anche gli unit test implementati in <code>position_test.py</code>. Questo avrà un effetto a catena sui file <code>portfolio.py </code>e <code>portfolio_test.py</code>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-89b8e28 elementor-widget elementor-widget-heading" data-id="89b8e28" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h5 class="elementor-heading-title elementor-size-default">Valutazione della prestazione</h5>		</div>
				</div>
				<div class="elementor-element elementor-element-51cd70a elementor-widget elementor-widget-text-editor" data-id="51cd70a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span>Sebbene ora disponiamo di un set di base di grafici delle prestazioni tramite la curva di equity, il profilo dei rendimenti e le serie dei drawdown, abbiamo bisogno di misure di performance più quantificate.</span></p><p><span>In particolare, avremo bisogno di metriche a livello di strategia, inclusi i comuni rapporti di rischio/rendimento come lo Sharpe Ratio, Information Ratio e Sortino Ratio. Avremo anche bisogno di statistiche sul drawdown inclusa la distribuzione dei drawdown, oltre a statistiche descrittive come il massimo drawdown. Altre metriche utili includono il tasso di crescita annuale composto (CAGR) e il rendimento totale.</span></p><p><span>A livello di trade/posizione vogliamo vedere metriche come il profitto/perdita medio, il profitto/perdita massimo, rapporto di profitto e rapporto di vincita / perdita. Dal momento che abbiamo costruito fin dall&#8217;inizio la classe </span><code>Position </code><span>come parte fondamentale del software, non dovrebbe essere troppo problematico generare queste metriche tramite alcuni metodi aggiuntivi.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-cc35742 elementor-widget-divider--view-line elementor-widget elementor-widget-divider" data-id="cc35742" data-element_type="widget" data-widget_type="divider.default">
				<div class="elementor-widget-container">
					<div class="elementor-divider">
			<span class="elementor-divider-separator">
						</span>
		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-e9a082f elementor-widget elementor-widget-text-editor" data-id="e9a082f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p> </p><p>Per il codice completo riportato in questo articolo, utilizzando il modulo di backtesting event-driven per il forex (DTForex) si può consultare il seguente repository di github:<br /><a href="https://github.com/datatrading-info/DTForex">https://github.com/datatrading-info/DTForex</a></p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/dtforex-6-backtesting-su-piu-giorni-e-visualizzazione-dei-risultati/">DTForex #6 &#8211; Backtesting su più giorni e Visualizzazione dei Risultati</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
