<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ToolBox BackTrader Archivi - Data Trading</title>
	<atom:link href="https://datatrading.info/category/toolbox-backtrader/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Tecnologie Digitali applicate al Trading</description>
	<lastBuildDate>Sat, 23 Jul 2022 10:42:33 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	

<image>
	<url>https://datatrading.info/wp-content/uploads/2019/04/favico.-300x300.jpg</url>
	<title>ToolBox BackTrader Archivi - Data Trading</title>
	<link></link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>Indicatore di Trendline per BackTrader</title>
		<link>https://datatrading.info/indicatore-di-trendline-per-backtrader/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Sat, 02 Feb 2019 09:41:34 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1294</guid>

					<description><![CDATA[<p>Questo è un frammento di codice per un indicatore di Trendline. Come suggerisce il nome, calcola il valore del prezzo in diversi punti di una trendline e, di conseguenza, genera segnali di acquisto e vendita. In alcuni casi mi piace poter adottare un approccio semi-automatico al trading algoritmico. Si potrebbe individuare una bella trendline su &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/indicatore-di-trendline-per-backtrader/"> <span class="screen-reader-text">Indicatore di Trendline per BackTrader</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/indicatore-di-trendline-per-backtrader/">Indicatore di Trendline per BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1294" class="elementor elementor-1294">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-dd2789e elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="dd2789e" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-1cb2853" data-id="1cb2853" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-b2fb84e elementor-widget elementor-widget-text-editor" data-id="b2fb84e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Questo è un frammento di codice per un indicatore di Trendline. Come suggerisce il nome, calcola il valore del prezzo in diversi punti di una trendline e, di conseguenza, genera segnali di acquisto e vendita. In alcuni casi mi piace poter adottare un approccio semi-automatico al trading algoritmico. Si potrebbe individuare una bella trendline su Tradingview ma si vuole eseguire operazioni in un ambiente di forward testing, utilizzando Backtrader, quando il prezzo raggiunge la trendline. In quanto tale, considero questo un indicatore a breve termine che può essere utilizzato fino a quando la trendline non viene rotta.

L&#8217;indicatore di trendline descritto in questo articolo  è destinato a essere utilizzato nel framework di Backtrader, ma i calcoli utilizzati per calcolare la trendline possono essere facilmente trasferiti su altri framework.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-865ee56 elementor-widget elementor-widget-heading" data-id="865ee56" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Background Matematico</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-e6164f3 elementor-widget elementor-widget-text-editor" data-id="e6164f3" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Se come me, non sei un mago della matematica, potrebbe essere necessario un po&#8217; di teoria per capire le equazioni contenute nel codice. E&#8217; necessario quindi introdurre quelle che nel mondo della matematica sono conosciute come &#8220;<strong>equazioni lineari</strong>&#8220;, al fine di poter sviluppare questo indicatore.</p><p>Un tutorial ben scritto e molto utile, anche se in inglese, è il seguente:<br /><a href="https://www.mathplanet.com/education/algebra-1/formulating-linear-equations/writing-linear-equations-using-the-slope-intercept-form">mathplanet.com/education/algebra-1/formulating-linear-equations/writing-linear-equations-using-the-slope-intercept-form</a></p><p>Il concetto principale è che per poter calcolare il prezzo della trendline in qualsiasi momento, è necessario calcolare la velocità con cui cambia la pendenza tra due punti temporali. Questi punti temporali sono i due prezzi inseriti come input per l&#8217;indicatore. Come identificare questi due punti dipende da te. Come accennato in precedenza, identifico e traccio in modo discrezionale la trendline su Tradingview e quindi prendo nota del punto iniziale e del punto finale da utilizzare con questo indicatore.</p><p>L&#8217;equazione a cui dobbiamo arrivare è:</p><p style="text-align: center;">\(<br />\begin{eqnarray}<br />y = mx + b<br />\end{eqnarray}<br />\)</p><p>Dove:</p><p>y = prezzo</p><p>m = pendenza</p><p>x = data / ora</p><p>b = intersezione con l&#8217;asse y</p><p>A questo punto, una cosa che ho trovato difficile da spiegare è come la maggior parte dei tutorial presume che tu possa vedere visivamente l&#8217;intersezione con l&#8217;asse y, cioè il valore di y quando attraversa l&#8217;asse y per x=0. In questo modo:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-32a4847 elementor-widget elementor-widget-image" data-id="32a4847" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="287" height="290" src="https://datatrading.info/wp-content/uploads/2018/02/Nonproportional_relationship_graph.jpg" class="attachment-medium size-medium" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ad8fb06 elementor-widget elementor-widget-text-editor" data-id="ad8fb06" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Come sappiamo, i grafici dei prezzi sono leggermente diversi perchè difficilmente si può tornare indietro nel tempo (dove si potrebbe attraversare l&#8217;asse y). Non possiamo vedere dove è l&#8217;intersezione dell&#8217;asse y ma è possibile calcolarla! Per fare questo è necessario capovolgere un po&#8217; l&#8217;equazione.
<p style="text-align: center;">\(
\begin{eqnarray}
y = mx + b
\end{eqnarray}
\)
<br>diventa<br>\(
\begin{eqnarray}
b = y – m*x
\end{eqnarray}
\)
</p>
Dopo aver risolto l&#8217;equazione, si può  utilizzare i valori di x e y del punto iniziale e finale della trendline che hai indiviuato. Vedrai come l&#8217;ho implementato nel codice seguente.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c40efa4 elementor-widget elementor-widget-heading" data-id="c40efa4" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Le Regole dell'Indicatore</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-fa90872 elementor-widget elementor-widget-text-editor" data-id="fa90872" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				L&#8217;indicatore della trendline genera un segnale di acquisto se il prezzo attraversa la trendline verso l&#8217;alto, mentre genera un segnale di vendita se il prezzo la attraversa dal basso. Poiché la trendline funge da supporto o resistenza, sarà sempre inferiore al prezzo quando si cercano segnali di acquisto mentre sarà superiore al prezzo quando si cercano segnali di vendita.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-700bc31 elementor-widget elementor-widget-heading" data-id="700bc31" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il Codice</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-1e4bf6c elementor-widget elementor-widget-bdt-source-code" data-id="1e4bf6c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class TrendLine(bt.Indicator):
 
    lines = (&#039;signal&#039;,&#039;trend&#039;)
    params = (
        (&#039;x1&#039;, None),
        (&#039;y1&#039;, None),
        (&#039;x2&#039;, None),
        (&#039;y2&#039;, None)
    )
 
    def __init__(self):
        self.p.x1 = datetime.datetime.strptime(self.p.x1, &quot;%Y-%m-%d %H:%M:%S&quot;)
        self.p.x2 = datetime.datetime.strptime(self.p.x2, &quot;%Y-%m-%d %H:%M:%S&quot;)
        x1_time_stamp = time.mktime(self.p.x1.timetuple())
        x2_time_stamp = time.mktime(self.p.x2.timetuple())
        self.m = self.get_slope(x1_time_stamp,x2_time_stamp,self.p.y1,self.p.y2)
        self.B = self.get_y_intercept(self.m, x1_time_stamp, self.p.y1)
        self.plotlines.trend._plotskip = True
 
    def next(self):
        date = self.data0.datetime.datetime()
        date_timestamp = time.mktime(date.timetuple())
        Y = self.get_y(date_timestamp)
        self.lines.trend[0] = Y
 
        #Check if price has crossed up / down into it.
        if self.data0.high[-1] &lt; Y and self.data0.high[0] &gt; Y:
            self.lines.signal[0] = -1
            return
 
        #Check for cross downs (Into support)
        elif self.data0.low[-1] &gt; Y and self.data0.low[0] &lt; Y:
            self.lines.signal[0] = 1
            return
 
        else:
            self.lines.signal[0] = 0
 
    def get_slope(self, x1,x2,y1,y2):
        m = (y2-y1)/(x2-x1)
        return m
 
    def get_y_intercept(self, m, x1, y1):
        b=y1-m*x1
        return b
 
    def get_y(self,ts):
        Y = self.m * ts + self.B
        return Y</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2fe7e61 elementor-widget elementor-widget-heading" data-id="2fe7e61" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>Spiegazione del codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-e96aa05 elementor-widget elementor-widget-text-editor" data-id="e96aa05" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Si generano due <em>lines</em> per questo indicatore. Una line è la trendline e l&#8217;altra line è il segnale. Da notare che la trendline non viene tracciata nel grafico perché in backtrader non è possibile tracciare una line sul grafico principale e un&#8217;altra sul grafico secondario. Si deve scegliere l&#8217;uno o l&#8217;altro. Tecnicamente si potrebbe tracciare entrambi sul grafico secondario, ma risulterebbe un po&#8217; strano poiché la trendline può essere qualsiasi numero (dato che il valore dipende dal prezzo dello strumento) mentre il segnale oscilla solamente tra -1 e 1. Una soluzione alternativa è presentata nella sezione dei risultati.

Un&#8217;altra cosa da notare sono le date, che devono essere convertite in un timestamp in modo che i calcoli possano essere fatti su un numero e non su un oggetto data.

Infine, ci si potrebbe domandare perché si sta costruendo la trendline e richiamando <code style="color: #e83e8c;">get_y()</code> nel metodo <code style="color: #e83e8c;">next()</code> invece che nel metodo <code style="color: #e83e8c;">__init__()</code>? Questo perché backtrader genera un <code style="color: #e83e8c;">IndexError</code> se si prova ad ottenere le informazioni sulla data all&#8217;interno di __init__(). Se qualcuno sa come risolvere il problema, lasciatemi un commento! Probabilmente ho trascurato qualcosa all&#8217;interno della documentazione.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-15f5479 elementor-widget elementor-widget-heading" data-id="15f5479" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">I metodi chiave</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-14b4530 elementor-widget elementor-widget-text-editor" data-id="14b4530" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Se si desidera implementare questo codice in un altro framewoek, i tre metodi fondamentali da implementare sono i seguenti:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4f226ae elementor-widget elementor-widget-text-editor" data-id="4f226ae" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
									</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-272854b elementor-widget elementor-widget-bdt-source-code" data-id="272854b" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def get_slope(self, x1,x2,y1,y2):
        m = (y2-y1)/(x2-x1)
        return m
 
    def get_y_intercept(self, m, x1, y1):
        b=y1-m*x1
        return b
 
    def get_y(self,ts):
        Y = self.m * ts + self.B
        return Y</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-be7a269 elementor-widget elementor-widget-text-editor" data-id="be7a269" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come in precedenza, è necessario utilizzare i <em>timestamp</em> per i parametri <strong>x</strong> e richiamare le funzioni nel seguente ordine:</p><ol><li>get_slope()</li><li>get_y_intercept(), perché ha bisogno del valore di m, risultato di get_slope()</li><li>get_y, per ottenere il prezzo finale per qualsiasi data e ora.</li></ol>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-083d360 elementor-widget elementor-widget-heading" data-id="083d360" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Risultati</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-18193b5 elementor-widget elementor-widget-text-editor" data-id="18193b5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Come accennato in precedenza, se si esegue questo codice così com&#8217;è, l&#8217;indicatore non traccia automaticamente nessuna trendline sul grafico di output. Poiché l&#8217;indicatore è progettato per produrre segnali di acquisto e vendita, la priorità è data alla stampa della <em>line</em> del segnale.</p><p>Come soluzione alternativa, per creare una certa verifica visiva del corretto funzionamento dell&#8217;indicatore, è possibile inizializzare un secondo indicatore all&#8217;interno della strategia che traccia una media mobile semplice della trendline, con un periodo pari a 1.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ea2b314 elementor-widget elementor-widget-bdt-source-code" data-id="ea2b314" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>self.sma = bt.indicators.MovingAverageSimple(self.ind1.lines.trend, 
                                             period = 1,
                                             plotmaster = self.data0
                                            )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-10a6056 elementor-widget elementor-widget-text-editor" data-id="10a6056" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Da notare che, nel codice precedenete, è necessario inserire la riga all&#8217;interno del metodo __init__() della strategia, supponendo di aver già inizializzato l&#8217;indicatore con il nome ind1 (self.ind1.lines.trend).					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5360c4a elementor-widget elementor-widget-image" data-id="5360c4a" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="800" height="698" src="https://datatrading.info/wp-content/uploads/2019/08/trendline-indicator-with-sma-backtrader-trading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2019/08/trendline-indicator-with-sma-backtrader-trading-algoritmico.jpg 800w, https://datatrading.info/wp-content/uploads/2019/08/trendline-indicator-with-sma-backtrader-trading-algoritmico-768x670.jpg 768w" sizes="(max-width: 800px) 100vw, 800px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-41324e7 elementor-widget elementor-widget-text-editor" data-id="41324e7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Come si può vedere, si ha una trendline che attraversa il grafico e i segnali vengono generati secondo le regole implementate nel codice, come rappresentato nel grafico secondario.					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/indicatore-di-trendline-per-backtrader/">Indicatore di Trendline per BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Gestire il Position Sizing con BackTrader &#8211; Parte I</title>
		<link>https://datatrading.info/gestire-il-position-sizing-con-backtrader-parte-i/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Mon, 28 Jan 2019 09:53:37 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1284</guid>

					<description><![CDATA[<p>Con questo articolo si introduce un argomento fondamentale nel mondo del trading automatico: il dimensionamento delle posizioni. Inizialmente, pensavo di scrivere un solo articolo, ma mentre mi immergevo sempre più in profondità nell&#8217;argomento mi sono reso conto che ci sarebbero stati troppi contenuti per un solo articolo di ragionevole durata. In quanto tale, questo primo &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/gestire-il-position-sizing-con-backtrader-parte-i/"> <span class="screen-reader-text">Gestire il Position Sizing con BackTrader &#8211; Parte I</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/gestire-il-position-sizing-con-backtrader-parte-i/">Gestire il Position Sizing con BackTrader &#8211; Parte I</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1284" class="elementor elementor-1284">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-0f0df30 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="0f0df30" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-006f388" data-id="006f388" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-fed7ffe elementor-widget elementor-widget-text-editor" data-id="fed7ffe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Con questo articolo si introduce un argomento fondamentale nel mondo del trading automatico: il dimensionamento delle posizioni. Inizialmente, pensavo di scrivere un solo articolo, ma mentre mi immergevo sempre più in profondità nell&#8217;argomento mi sono reso conto che ci sarebbero stati troppi contenuti per un solo articolo di ragionevole durata. In quanto tale, questo primo articolo si concentra sui concetti fondamenti per lo sviluppo dei sizer e fornisce un paio di semplici esempi. Il secondo articolo approfondisce alcuni aspetti, ed i particolare a <strong>comminfo</strong>. Dato che comminfo è una classe,si ha numerosi metodi che possono essere utilizzati per far sì che i tuoi algoritmi di dimensionamento tengano conto delle commissioni, degli interessi e delle posizioni aperte.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-158b675 elementor-widget elementor-widget-heading" data-id="158b675" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La classe Sizer</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-b0d8f85 elementor-widget elementor-widget-text-editor" data-id="b0d8f85" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				I Sizer sono classi che possono essere caricate in cerebro e utilizzate per decidere quante azioni, quote, contratti, ecc, acquistare o vendere ogni volta che viene chiamato <code style="color: #e83e8c;">self.buy()</code> o <code style="color: #e83e8c;">self.sell()</code>. I sizers sono utilizzati per un calcolo della posizione solo quando non viene fornita alcuna dimensione. In altre parole, se il tuo script contiene una chiamata di acquisto come <em>self.buy(size=100)</em>, il Sizer non verrà chiamato. Tuttavia, se si chiama solo tramite <em>self.buy()</em>, cerebro chiederà al sizer la dimensione da acquistare.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-140c9be elementor-widget elementor-widget-heading" data-id="140c9be" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Perchè abbiammo bisogno dei Sizer?</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-acaf68a elementor-widget elementor-widget-text-editor" data-id="acaf68a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Alcuni trader possono preferire di dichiarare esplicitamente la dimensione, invece di implementare un qualsiasi tipo di logica di dimensionamento all&#8217;interno del codice della loro strategia. Se preferisci questo approccio non c&#8217;è niente di male, dopotutto ci sono molti modi per risolvere lo stesso problema! Tuttavia, dal mio punto di vista, usare i Sizer permette alcuni vantaggi. Se ti piace avere un codice ben strutturato e suddiviso, allora i Sizer fanno al tuo caso. Inoltre i Sizer consentono di apportare alcune modifiche, piccole o anche più consistenti, alla logica di una strategia senza dover toccare il codice della classe Strategia. La documentazione di Backtrader ha un buon esempio su come un sizer viene utilizzato per trasformare una strategia &#8220;long/short&#8221; in una strategia &#8220;solo long&#8221;, semplicemente usando un diverso sizer. Facendo un ulteriore passo avanti, è facile immaginare di poter implementare una libreria di Sizer che ti consenta di implementare la stessa strategia in mercati diversi con schemi commissionali e condizioni commerciali diverse senza dover modificare il codice di strategia principale.</p><p>Documentazione: <a style="background-color: #ffffff;" href="https://www.backtrader.com/docu/sizers/sizers.html#practical-sizer-applicability" target="_blank" rel="noopener">backtrader.com/docu/sizers/sizers.html#practical-sizer-applicability</a></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-eea2fb3 elementor-widget elementor-widget-heading" data-id="eea2fb3" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La Struttura di un Sizer</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-58bfe16 elementor-widget elementor-widget-text-editor" data-id="58bfe16" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Un sizer è una sottoclasse di <code style="color: #e83e8c;">backtrader.Sizer</code>. La sottoclasse ci consente di costruire un oggetto utilizzando la classe principale come base di partenza. L&#8217;oggetto eredita quindi tutte le caratteristiche e le funzionalità della classe principale senza dover copiare e incollare il codice nella nuova classe. E&#8217; quindi possibile modificare solo le parti del codice, riscrivendo un metodo (una funzione di classe), un attributo (una variabile di classe) o aggiungendo qualcosa di nuovo. Tutte le parti rimaste intatte continueranno a funzionare nello stesso modo in cui erano state scritte nella classe genitore. Nel codice qui sotto è presente backtrader.Sizer scritto come bt.Sizer poiché generalmente utilizzo questo istruzione <code style="color: #e83e8c;">import backtrader as bt</code>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8611d78 elementor-widget elementor-widget-bdt-source-code" data-id="8611d78" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class exampleSizer(bt.Sizer):
    params = ((&#039;size&#039;,1),)
    def _getsizing(self, comminfo, cash, data, isbuy):
        return self.p.size</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-842f3ba elementor-widget elementor-widget-text-editor" data-id="842f3ba" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il codice precedente contiene un esempio di ridimensionamento nella sua forma più semplice. Questo ci permetterà di suddividere ed analizzare le componenti chiave di un sizer.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-05fc31e elementor-widget elementor-widget-heading" data-id="05fc31e" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">La tupla "params"</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-68e5848 elementor-widget elementor-widget-text-editor" data-id="68e5848" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				I Sizer, proprio come le strategie e gli indicatori possono contenere una tupla di parametri. Avere un set di parametri può offrire una certa flessibilità durante il caricamento del sizer in cerebro e fornire i dati al sizer, che altrimenti non sarebbero disponibili.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0d7ab6c elementor-widget elementor-widget-heading" data-id="0d7ab6c" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">_getsizing()</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-553df28 elementor-widget elementor-widget-text-editor" data-id="553df28" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Successivamente abbiamo il metodo <code style="color: #e83e8c;">_getsizing ()</code>. Questo metodo viene chiamato ogni volta che una strategia effettua una chiamata <em>self.buy()</em> o <em>self.sell()</em> senza indicare la dimensione dell&#8217;ordine. Il metodo <em>_getsizing()</em> prevede una serie di parametri, provenienti dal framework Backtrader. Questi sono:
<ul>
 	<li><strong>comminfo</strong>: fornisce l&#8217;accesso a vari metodi che permettono di conoscere i dati del iano commissionale previsto dal broker. Ciò consente di valutare tutte le commissioni relative al singolo trade prima di decidere la dimensione. Nella seconda parte di questo tutorial si descrive comminfo in modo più dettagliato.</li>
 	<li><strong>cash</strong>: fornisce la quantità di denaro disponibile sul conto.</li>
 	<li><strong>data</strong>: fornisce l&#8217;accesso al feed dei dati. Ad esempio, tramite questo parametro possiamo accedere all&#8217;ultimo prezzo di chiusura.</li>
 	<li><strong>isbuy</strong>: è un valore booleano (Vero / Falso) che identifica se l&#8217;ordine è un ordine di acquisto. Se è falso, allora l&#8217;ordine è un ordine di vendita.</li>
</ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a96b1f6 elementor-widget elementor-widget-heading" data-id="a96b1f6" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Strategy e Broker</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-06ddbfe elementor-widget elementor-widget-text-editor" data-id="06ddbfe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Ci sono inoltre le due classi accessibili, ma non visibili nel codice precedente, <code style="color: #e83e8c;">self.strategy</code> e <code style="color: #e83e8c;">self.broker</code>. Con questi due oggetti si ha praticamente accesso a tutto il necessario per creare complessi algoritmi di dimensionamento. Da sottolineare però, nel caso si eseguono calcoli basati su attributi di strategia, è nessario assicurarsi che siano attributi / variabili standard nel framework. In altre parole, attributi disponibili per tutte le strategie (anziché attributi personalizzati, aggiunti al codice per proprio conto). In caso contrario si rinuncia alla portabilità del sizer poiché questo funzionerà solo con la strategia dove  codificato quello specifico attributo.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-12e600f elementor-widget elementor-widget-heading" data-id="12e600f" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Non dimenticarti di restituire qualcosa</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-c4874ba elementor-widget elementor-widget-text-editor" data-id="c4874ba" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Infine, è necessario ricordarsi di restituire un valore alla fine del calcolo. Se lo si dimentica, la strategia non effettuerà alcun ordine.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-dafe883 elementor-widget elementor-widget-heading" data-id="dafe883" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il Codice</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-7eb998c elementor-widget elementor-widget-text-editor" data-id="7eb998c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il seguente codice contiene tre esempi di Sizer. Il primo prevede dimensioni fisse, analogo a quanto mostrato nel blocco precedente. Il secondo è un esempio di sizer che stampa tutti i parametri del metodo _getsizing () ad eccezione di comminfo (che vedremo più dettagliatamente in seguito). L&#8217;esempio finale fornisce l&#8217;implementazione di un pratico ridimensionamento per limitare le dimensioni di un trade a una percentuale della liquidità totale del conto. Questo è un comune algoritmo di <strong>position sizing</strong> che molte strategie utilizzano per limitare il rischio.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-fea74c7 elementor-widget elementor-widget-bdt-source-code" data-id="fea74c7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
from datetime import datetime
import math


class exampleSizer(bt.Sizer):
    params = ((&#039;size&#039;,1),)
    def _getsizing(self, comminfo, cash, data, isbuy):
        return self.p.size

class printSizingParams(bt.Sizer):
    &#039;&#039;&#039;
    Prints the sizing parameters and values returned from class methods.
    &#039;&#039;&#039;
    def _getsizing(self, comminfo, cash, data, isbuy):
        #Strategy Method example
        pos = self.strategy.getposition(data)
        #Broker Methods example
        acc_value = self.broker.getvalue()

        #Print results
        print(&#039;----------- SIZING INFO START -----------&#039;)
        print(&#039;--- Strategy method example&#039;)
        print(pos)
        print(&#039;--- Broker method example&#039;)
        print(&#039;Account Value: {}&#039;.format(acc_value))
        print(&#039;--- Param Values&#039;)
        print(&#039;Cash: {}&#039;.format(cash))
        print(&#039;isbuy??: {}&#039;.format(isbuy))
        print(&#039;data[0]: {}&#039;.format(data[0]))
        print(&#039;------------ SIZING INFO END------------&#039;)

        return 0

class maxRiskSizer(bt.Sizer):
    &#039;&#039;&#039;
    Returns the number of shares rounded down that can be purchased for the
    max rish tolerance
    &#039;&#039;&#039;
    params = ((&#039;risk&#039;, 0.03),)

    def __init__(self):
        if self.p.risk &gt; 1 or self.p.risk &lt; 0:
            raise ValueError(&#039;The risk parameter is a percentage which must be&#039;
                &#039;entered as a float. e.g. 0.5&#039;)

    def _getsizing(self, comminfo, cash, data, isbuy):
        if isbuy == True:
            size = math.floor((cash * self.p.risk) / data[0])
        else:
            size = math.floor((cash * self.p.risk) / data[0]) * -1
        return size



class firstStrategy(bt.Strategy):

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=21)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: self.buy() else: if self.rsi &gt; 70:
                self.close()

    def notify_trade(self, trade):
        if trade.justopened:
            print(&#039;----TRADE OPENED----&#039;)
            print(&#039;Size: {}&#039;.format(trade.size))
        elif trade.isclosed:
            print(&#039;----TRADE CLOSED----&#039;)
            print(&#039;Profit, Gross {}, Net {}&#039;.format(
                                                round(trade.pnl,2),
                                                round(trade.pnlcomm,2)))
        else:
            return


#Variable for our starting cash
startcash = 10000

#Create an instance of cerebro
cerebro = bt.Cerebro()

#Add our strategy
cerebro.addstrategy(firstStrategy)

#Get Apple data from Yahoo Finance.
data = bt.feeds.YahooFinanceData(
    dataname=&#039;AAPL&#039;,
    fromdate = datetime(2016,1,1),
    todate = datetime(2017,1,1),
    buffered= True
    )

#Add the data to Cerebro
cerebro.adddata(data)

# Set our desired cash start
cerebro.broker.setcash(startcash)

#add the sizer
cerebro.addsizer(printSizingParams)

# Run over everything
cerebro.run()

#Get final portfolio Value
portvalue = cerebro.broker.getvalue()
pnl = portvalue - startcash

#Print out the final result
print(&#039;----SUMMARY----&#039;)
print(&#039;Final Portfolio Value: ${}&#039;.format(portvalue))
print(&#039;P/L: ${}&#039;.format(pnl))

#Finally plot the end results
cerebro.plot(style=&#039;candlestick&#039;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-0658111 elementor-widget elementor-widget-heading" data-id="0658111" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Spiegazione del codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-cecb919 elementor-widget elementor-widget-text-editor" data-id="cecb919" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Prima di tutto, dato che abbiamo più esempi, vale la pena notare come passare da uno all&#8217;altro. Per cambiare il sizer in uso, è sufficiente modificare questa riga:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9fb4a73 elementor-widget elementor-widget-bdt-source-code" data-id="9fb4a73" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#add the sizer
cerebro.addsizer(exampleSizer, size=50)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-790164b elementor-widget elementor-widget-text-editor" data-id="790164b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				In questa:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e0a26b4 elementor-widget elementor-widget-bdt-source-code" data-id="e0a26b4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#add the sizer
cerebro.addsizer(printSizingParams)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-dd0b51d elementor-widget elementor-widget-text-editor" data-id="dd0b51d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				O in questa:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-35bd360 elementor-widget elementor-widget-bdt-source-code" data-id="35bd360" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#add the sizer
cerebro.addsizer(maxRiskSizer, risk=0.2)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-fffa74e elementor-widget elementor-widget-text-editor" data-id="fffa74e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><strong>Import math</strong></p><p>In questo codice ho incluso un modulo Python aggiuntivo. Il modulo math fornisce <code style="color: #e83e8c;">math.floor()</code> che semplifica l&#8217;arrotondamento per difetto al numero più vicino. Con un algoritmo di rischio massimo, non si può mai arrotondare per eccesso perché può portarci potenzialmente oltre al nostro limite di rischio. L&#8217;arrotondamento per diffetto non potrà mai farlo. La documentazione ufficiale di Python per il modulo <code style="color: #e83e8c;">math</code> è disponibile al seguente link: <strong><a href="http://docs.python.org/3/library/math.html">docs.python.org/3/library/math.html</a></strong></p><p><strong>exampleSizer ()</strong><br />Il sizer di esempio è stato incluso solo per discutere l&#8217;anatomia di un sizer. Tuttavia, fornisce anche un esempio di un sizer che utilizza una dimensione fissa. Una versione quasi identica appare nella documentazione ufficiale di Backtrader: <a href="https://www.backtrader.com/docu/sizers/sizers.html#sizer-development">www.backtrader.com/docu/sizers/sizers.html#sizer-development</a></p><p><strong>printSizingParams ()</strong><br />Per verificare il codice ho incluso un semplice sizer che stampa il contenuto dei parametri del calibratore. Di solito vedere esattamente cosa viene restituito mi aiuta a capire esattamente cosa sta facendo il parametro e come posso usarlo. È doppiamente utile quando si ha problemi a leggere la documentazione. L&#8217;esecuzione del codice fornisce il seguente output:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d68b858 elementor-widget elementor-widget-image" data-id="d68b858" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="672" height="636" src="https://datatrading.info/wp-content/uploads/2018/01/print-sizers-backtrader-itrading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-42c76c5 elementor-widget elementor-widget-text-editor" data-id="42c76c5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il primo parametro stampato dal codice è un esempio dei dati che possono essere consultati tramite la classe di strategia, usando <code style="color: #e83e8c;">self.strategy.getposition()</code>. Si può subito notare che &#8220;<code style="color: #e83e8c;">pos</code>&#8221; è un oggetto <em>posizione</em> anziché un semplice valore come &#8220;<code style="color: #e83e8c;">cash</code>&#8220;. Allo stesso modo la variabile <code style="color: #e83e8c;">account value</code> fornisce un esempio dei dati a cui è possibile accedere facilmente tramite <code style="color: #e83e8c;">self.broker()</code>. Nota nel caso live trading, è indispensabile assicurarsi quali metodi live del broker prescelto sono supportari nella documentazione di Backtrader. Ho dovuto implementare alcune soluzioni alternative perchè alcuni metodi non erano disponibili in Backtrader durante il trading live con Oanda.</p><p><strong>maxRiskSizer</strong><br /><code style="color: #e83e8c;">maxRiskSizer()</code> calcola semplicemente la posizione della dimensione massima che puoi assumere senza superare una determinata percentuale del capitale disponibile nel tuo account. La percentuale viene impostata tramite il parametro &#8220;<code style="color: #e83e8c;">risk</code>&#8221; presente nella tupla dei parametri. La percentuale viene immessa come float tra 0 e 1 e il valore default è pari a 3%, ma può essere impostato su qualsiasi valore quando viene caricato in cerebro. Per quelli come voi che non sono maghi matematici, il simbolo <strong>*-1</strong> nella seguente riga di codice modifica il valore della dimensione da positiva a negativa. Si ha bisogno di una dimensione negativa nel caso di un ordine di vendita.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1d6a9f9 elementor-widget elementor-widget-bdt-source-code" data-id="1d6a9f9" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>size = math.floor ((cash * self.p.risk) / data [0]) * -1</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b553d3c elementor-widget elementor-widget-text-editor" data-id="b553d3c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><strong>​Attenzione a maxRiskSizer buy.sell()</strong><br />Se hai l&#8217;abitudine di chiudere una posizione con una dimensione fissa utilizzando buy.sell(), devi essere consapevole che l&#8217;uso di maxRiskSizer può far sì che le posizioni non vengano chiuse e causi entrate indesiderate. Questo perché i livelli di liquidità sono dinamiche, cioè si modificano quando i trade sono aperti e chiusi, quindi la precentuale x% di apertura è ora l&#8217;x% di un totale diverso. In altre parole, il valore dello strumento sta cambiando in modo tale che x% comporti una diversa quantità di azioni / contratti acquistati. La semplice soluzione è chiudere le posizioni con la fuzione <code style="color: #e83e8c;">​self.close()</code>. Questo calcolerà la dimensione corretta necessaria per chiudere completamente una posizione.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/gestire-il-position-sizing-con-backtrader-parte-i/">Gestire il Position Sizing con BackTrader &#8211; Parte I</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Ottimizzare le Strategie con BackTrader</title>
		<link>https://datatrading.info/ottimizzare-le-strategie-con-backtrader/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Tue, 22 Jan 2019 11:25:00 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1243</guid>

					<description><![CDATA[<p>Dopo aver creato una strategia di base ed averla analizzata, il prossimo passo consiste nell&#8217;ottimizzare questa strategia. L&#8217;ottimizzazione è un processo di verifica che assegna valori diversi per ogni parametro della strategia al fine di individuare quale set di valori (o configurazione) fornisce i migliori risultati, in termini di profitto. Da notare che non tutti &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/ottimizzare-le-strategie-con-backtrader/"> <span class="screen-reader-text">Ottimizzare le Strategie con BackTrader</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/ottimizzare-le-strategie-con-backtrader/">Ottimizzare le Strategie con BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1243" class="elementor elementor-1243">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-963601e elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="963601e" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-e5b4582" data-id="e5b4582" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-133c92c elementor-widget elementor-widget-text-editor" data-id="133c92c" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dopo aver creato una <a href="http://datatrading.info/backtrader-primo-script/">strategia di base</a> ed <a href="http://datatrading.info/utilizzare-lanalyzers-di-backtrader/">averla analizzata</a>, il prossimo passo consiste nell&#8217;ottimizzare questa strategia. L&#8217;ottimizzazione è un processo di verifica che assegna valori diversi per ogni parametro della strategia al fine di individuare quale set di valori (o configurazione) fornisce i migliori risultati, in termini di profitto. Da notare che non tutti i trader algoritmici concordano sul fatto che questo processo può portare a risultati migliori. Infatti è molto facile cadere nella trappola del sovradimensionamento dei dati (meglio noto come <strong>overfitting</strong>).</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bc2fd93 elementor-widget elementor-widget-heading" data-id="bc2fd93" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Perchè Ottimizzare?</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-4516787 elementor-widget elementor-widget-text-editor" data-id="4516787" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				La motivazione è che i mercati sono in continua evoluzione. Abbiamo mercati rialzisti, mercati ribassisti, periodi di inflazione, periodi di deflazione, tempi instabili e momenti di serenità. Se ciò non bastasse, strumenti diversi hanno ritmi diversi e mercati diversi hanno nature e comportamenti diversi. Ciò significa che i parametri per uno strumento in un mercato potrebbero non essere ottimali per un altro strumento in un altro mercato.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4588da5 elementor-widget elementor-widget-heading" data-id="4588da5" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">...ma attenzione all'OverFitting</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-448ab18 elementor-widget elementor-widget-text-editor" data-id="448ab18" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Quando si ottimizzano le strategie, è necessario prestare la massima attenzione a non creare parametri che funzionino solo per in un determinato &#8220;momento nel tempo&#8221;. Può essere allettante ottenere i migliori risultati dall&#8217;ottimizzazione e quindi prevedere l&#8217;esecuzione live della strategia con tali parametri. Tuttavia, se il set di dati è limitato ad un breve periodo di tempo o copre solamente una determinata condizione di mercato, è possibile che i parametri siano ottimizzati solo quel specifico momento nel passato, quindi del tutto inutilizzabili nel futuro.
Nella statistica o nel machine learning, infatti, un modello statistico o un algoritmo viene applicato ai dati di addestramento (training) in modo che possa essere utilizzato per fare previsioni nel futuro. L&#8217;overfitting si verifica quando il modello o l&#8217;algoritmo è troppo complesso per il set di dati preso in considerazione. In questo contesto, complesso significa che l&#8217;algoritmo è ottimizzato a tal punto da adattarsi (fit) solo a quei dati. L&#8217;overfitting provoca reazioni eccessive se applicato all&#8217;esterno dei dati di training. Nel nostro ambiente di backtesting si possono considerare i nostri dati storici di backtest come i dati di training e la nostra strategia come l&#8217;algoritmo.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c8fc79b elementor-widget elementor-widget-heading" data-id="c8fc79b" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Requisiti</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-28db7df elementor-widget elementor-widget-text-editor" data-id="28db7df" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il codice in questo articolo fa seguito al codice sviluppato nel precedente articolo <a href="http://datatrading.info/backtrader-primo-script/">Backtrader: Primo Script</a> e fa parte della serie introduttiva a BackTrader. Se è la prima volta che senti parlare di Backtrader e / o Python, ti suggerisco di iniziare dall&#8217;articolo <a href="http://datatrading.info/setup-di-base-per-python-e-backtrader/">Setup di base per Python e BackTrader</a></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c0714d4 elementor-widget elementor-widget-heading" data-id="c0714d4" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il Codice</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-62da09f elementor-widget elementor-widget-text-editor" data-id="62da09f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il codice di questo tutorial è costruito su tre esempi. Ogni esempio sarà accompagnato da specifici commenti e output.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-51de5ee elementor-widget elementor-widget-heading" data-id="51de5ee" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Parte 1° - Aggiungere i Parametri</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-c1975d5 elementor-widget elementor-widget-text-editor" data-id="c1975d5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Prima di poter ottimizzare il codice dobbiamo fornire alla strategia qualcosa da ottimizzare, cioè alcuni parametri modificabili. Se si osserva il codice del <a href="http://datatrading.info/backtrader-primo-script/">precedente articolo</a>, si può notare come abbiamo impostato a 21 il parametro relativo al periodo del RSI. Questa è una codifica rigida cioè il parametro è valorizzato all&#8217;interno del codice e non può essere successivamente modificato. Per effettuare l&#8217;ottimizzazione è necessario rendere questo parametro configurabile quando si carica la strategia all&#8217;interno del motore <code style="color: #e83e8c;">cerebro</code>.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f422c1c elementor-widget elementor-widget-bdt-source-code" data-id="f422c1c" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
from datetime import datetime

class rsiStrategy(bt.Strategy):
    params = (
        (&#039;period&#039;,21),
        )

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=self.params.period)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: self.buy(size=100) else: if self.rsi &gt; 70:
                self.sell(size=100)


#Variable for our starting cash
startcash = 10000

#Create an instance of cerebro
cerebro = bt.Cerebro()

#Add our strategy
cerebro.addstrategy(rsiStrategy, period=14)

#Get Apple data from Yahoo Finance.
data = bt.feeds.YahooFinanceData(
    dataname=&#039;AAPL&#039;,
    fromdate = datetime(2016,1,1),
    todate = datetime(2017,1,1),
    buffered= True
    )

#Add the data to Cerebro
cerebro.adddata(data)

# Set our desired cash start
cerebro.broker.setcash(startcash)

# Run over everything
cerebro.run()

#Get final portfolio Value
portvalue = cerebro.broker.getvalue()
pnl = portvalue - startcash

#Print out the final result
print(&#039;Final Portfolio Value: ${}&#039;.format(portvalue))
print(&#039;P/L: ${}&#039;.format(pnl))

#Finally plot the end results
cerebro.plot(style=&#039;candlestick&#039;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c59e3b1 elementor-widget elementor-widget-heading" data-id="c59e3b1" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Spiegazione del codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-2927d9b elementor-widget elementor-widget-text-editor" data-id="2927d9b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Prima di tutto, facciamo riferimento al codice nel nostro primo script. Questo permette facilmente di notare alcune modifiche. Di seguito sono riportati uno snippet del codice per dichiarare la classe e il metodo <code style="color: #e83e8c;">__init__()</code> del primo script					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-cb58cb4 elementor-widget elementor-widget-bdt-source-code" data-id="cb58cb4" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class rsiStrategy(bt.Strategy):

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=21)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-dfafc7b elementor-widget elementor-widget-text-editor" data-id="dfafc7b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Mentre in questo esempio, il codice è diventato:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0282c94 elementor-widget elementor-widget-bdt-source-code" data-id="0282c94" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class rsiStrategy(bt.Strategy):
    params = (
        (&#039;period&#039;,21),
        )

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=self.params.period)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-f8a7e9d elementor-widget elementor-widget-text-editor" data-id="f8a7e9d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo caso è stata aggiunta la tupla &#8220;<code style="color: #e83e8c;">params</code>&#8220;, essa contiene altre tuple che sono utilizzate per dichiarare i parametri della strategia. Che cos&#8217;è una tupla? Una tupla è un elenco di elementi fissi che non possono essere cambiati o modificati. Nei linguaggi di programmazione è abitudine differenziare ciò che è <strong>immutabile</strong> (non modificabile), come le costanti, e ciò che è <strong>mutabile</strong> (che può essere modificato), come le variabili. All&#8217;interno della tupla dei parametri, si ha un parametro (<code style="color: #e83e8c;">"period", 21</code>). Il primo elemento è una stringa che identifica il nome / riferimento per il parametro. Il secondo elemento è il valore predefinito per quel determinato parametro.</p><p>Avere un valore predefinito significa che non è necessario specificare un parametro ogni volta che si esegue la strategia. Se non viene specificato nulla, la strategia verrà eseguita con il valore di default. Puoi inserire tutti i parametri che desideri nella tupla dei parametri. Assicurati solo di aggiungerli come tupla all&#8217;interno della tupla principale (nota come tupla <strong>nidificata</strong>). I parametri della strategia sono accessibili ovunque nella classe. sono infatti gestiti come qualsiasi altro attributo di classe (variabile). Nel metodo <strong>__init__()</strong> si accede a <code style="color: #e83e8c;">self.params.period</code> e viene assegnato alla keyword <code style="color: #e83e8c;">period</code> quando si aggiunge l&#8217;indicatore RSI.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-53a6fd6 elementor-widget elementor-widget-heading" data-id="53a6fd6" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><strong>Chiamata alla Strategia</strong><br></h4>		</div>
				</div>
				<div class="elementor-element elementor-element-1ad3892 elementor-widget elementor-widget-bdt-source-code" data-id="1ad3892" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>cerebro.addstrategy(firstStrategy, period=14)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-ab210bc elementor-widget elementor-widget-text-editor" data-id="ab210bc" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Il codice relativo all&#8217;aggiunta della strategia all&#8217;interno di cerebro è stato modificato in modo da poter specificare la keyword per il parametro. Come accennato in precedenza, questo è facoltativo. Richiamare la strategia in questo modo ci permetterà di ottimizzarla in un secondo momento.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4dcf0a7 elementor-widget elementor-widget-heading" data-id="4dcf0a7" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">NOTE:</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-d8b6e69 elementor-widget elementor-widget-text-editor" data-id="d8b6e69" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ci sono un paio di cose a cui prestare attenzione quando si aggiungono parametri. Il primo è che ogni tupla nell&#8217;elenco delle tuple necessita di una virgola alla fine . Se sei abituato a scrivere codice in Python, saprai che per gli oggetti <em>list</em> e <em>dict</em>, l&#8217;ultimo valore non dovrebbe avere la virgola finale.</p><p>Se si digita: (errato)</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-06176c5 elementor-widget elementor-widget-bdt-source-code" data-id="06176c5" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>params = (
        (&#039;period&#039;,21)
    )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-24f1705 elementor-widget elementor-widget-text-editor" data-id="24f1705" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Invece di (corretto):					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5634dd8 elementor-widget elementor-widget-bdt-source-code" data-id="5634dd8" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>params = (
        (&#039;period&#039;,21),
    )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-bf38544 elementor-widget elementor-widget-text-editor" data-id="bf38544" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Si ottiene un ValueError:</p><p><em>ValueError: too many values to unpack (expected 2)</em></p><p>Inoltre, fai attenzione quando aggiungi i tuoi indicatori nel metodo <strong>__init__()</strong>. Se dimentichi di usare una keyword, puoi ottenere un TypeError.<br />Se si digita: (errato)</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-9a6a87a elementor-widget elementor-widget-bdt-source-code" data-id="9a6a87a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, self.params.period)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-12205dc elementor-widget elementor-widget-text-editor" data-id="12205dc" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Invece di: (corretto)					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-71d6ed7 elementor-widget elementor-widget-bdt-source-code" data-id="71d6ed7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=self.params.period)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-085b01b elementor-widget elementor-widget-text-editor" data-id="085b01b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Si ottiene il seguente errore:</p><p><em>TypeError: __init__() takes 1 positional argument but 2 were given</em></p><p> <br />Questo errore può creare molta confusione. Infatti abbiamo aggiunto l&#8217;indicatore nel metodo __init__() della strategia, ma in realtà l&#8217;errore si riferisce al metodo __init __ () dell&#8217;indicatore (classe <em>indicators</em>)! Si potrebbe perdere molto tempo ad eseguire il debug della cosa sbagliata.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-b5f753e elementor-widget elementor-widget-heading" data-id="b5f753e" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h3 class="elementor-heading-title elementor-size-default">Parte 2° - Ottimizzazione</h3>		</div>
				</div>
				<div class="elementor-element elementor-element-c8d6aef elementor-widget elementor-widget-text-editor" data-id="c8d6aef" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ora che siamo in grado di inizializzare la strategia con parametri differenti, ottimizzare il codice è piuttosto semplice. Tecnicamente dobbiamo solamente sostituire la linea <code style="color: #e83e8c;">cerebro.addstrategy()</code> con:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c6d7bb9 elementor-widget elementor-widget-bdt-source-code" data-id="c6d7bb9" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#Add our strategy
cerebro.optstrategy(firstStrategy, period=range(14,21))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b669f47 elementor-widget elementor-widget-text-editor" data-id="b669f47" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Quindi <em>cerebro</em> eseguirà la strategia per ogni periodo nell&#8217;intervallo indicato. Tuttavia, l&#8217;output non sarebbe utile. Se vogliamo essere in grado di vedere quale parametro ha le migliori prestazioni si dovrà aggiungere un nuovo metodo alla nostra strategia. Il codice completo è il seguente:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d7ebeb7 elementor-widget elementor-widget-bdt-source-code" data-id="d7ebeb7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
from datetime import datetime

class rsiStrategy(bt.Strategy):
    params = (
        (&#039;period&#039;,21),
        )

    def __init__(self):
        self.startcash = self.broker.getvalue()
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=self.params.period)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: self.buy(size=100) else: if self.rsi &gt; 70:
                self.sell(size=100)

    def stop(self):
        pnl = round(self.broker.getvalue() - self.startcash,2)
        print(&#039;RSI Period: {} Final PnL: {}&#039;.format(
            self.params.period, pnl))

if __name__ == &#039;__main__&#039;:
    #Variable for our starting cash
    startcash = 10000

    #Create an instance of cerebro
    cerebro = bt.Cerebro()

    #Add our strategy
    cerebro.optstrategy(rsiStrategy, period=range(14,21))

    #Get Apple data from Yahoo Finance.
    data = bt.feeds.YahooFinanceData(
        dataname=&#039;AAPL&#039;,
        fromdate = datetime(2016,1,1),
        todate = datetime(2017,1,1),
        buffered= True
        )

    #Add the data to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(startcash)

    # Run over everything
    strats = cerebro.run()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-0d144e7 elementor-widget elementor-widget-heading" data-id="0d144e7" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>Spiegazione del codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-98af6fc elementor-widget elementor-widget-text-editor" data-id="98af6fc" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>I lettori attenti avranno sicuramente notato che ci state alcune cancellazioni, oltre al nuovo metodo (funzione) aggiunto alla strategia. Innanzitutto diamo un&#8217;occhiata al nuovo metodo:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5ec2cf8 elementor-widget elementor-widget-bdt-source-code" data-id="5ec2cf8" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>    def stop(self):
        pnl = round(self.broker.getvalue() - self.startcash,2)
        print(&#039;RSI Period: {} Final PnL: {}&#039;.format(
            self.params.period, pnl))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b0129ff elementor-widget elementor-widget-text-editor" data-id="b0129ff" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Backtrader eseguirà diversi cicli di backtesting, uno per ogni diverso valore dei parametri, prima di arrivare al termine dello script. Nell&#8217;esempio precedente, si ha come output il valore del portafoglio e il PnL (profitti e perdite) alla fine dello script. Questo significa che non si ha visibilità dei risultati dei singoli vedrai i risultati dei singoli backtest se lasciamo l&#8217;istruzione <code style="color: #e83e8c;">print()</code> dopo la fine dell&#8217;esecuzione di cerebro. Di conseguenza, un metodo <code style="color: #e83e8c;">stop()</code> viene aggiunto allo script. Questo metodo fa parte della classe base <code style="color: #e83e8c;">bt.Strategy</code> e si sta semplicemente sovrascrivendo la logica al suo interno, dato che si eredita la bt.Strategy durante la creazione della classe della nostra strategia. Come suggerisce il nome, si richiama questo metodo quando la strategia si interrompe. Questo è l&#8217;ideale per restituire i profitti o le perdite finali al termine del test.</p><p><strong>Plotting</strong></p><p>Oltre a rimuovere l&#8217;istruzioni <em>print()</em> alla fine dello script, è stata rimossa anche la funzione di stampa dei grafici. Quando si effettua l&#8217;ottimizzazione, ti consiglio di non graficare l&#8217;output perchè, al momento della stesura di questo articolo, il framework prevede la creazione di un grafico alla fine di ogni ciclo della strategia. E&#8217; quindi necessario chiudere manualmente il grafico prima dell&#8217;inizio del ciclio successivo. Se si ha molti parametri, questo può richiedere molto tempo e diventare fastidioso.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-4ac373a elementor-widget elementor-widget-heading" data-id="4ac373a" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Risultati della 2° Parte</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-237596d elementor-widget elementor-widget-image" data-id="237596d" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="863" height="510" src="https://datatrading.info/wp-content/uploads/2019/08/backtrader-optimize-strategies-trading-algoritmico.png" class="attachment-large size-large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2019/08/backtrader-optimize-strategies-trading-algoritmico.png 863w, https://datatrading.info/wp-content/uploads/2019/08/backtrader-optimize-strategies-trading-algoritmico-768x454.png 768w" sizes="(max-width: 863px) 100vw, 863px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-48ef4ba elementor-widget elementor-widget-text-editor" data-id="48ef4ba" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Quindi sembra che un periodo pari a 17 sia il valore ottimale per questo set di dati. È interessante notare come se il valore fosse diverso di sole 2 unità (un periodo di 19), i risultati sarebbero drasticamente diversi!					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0e6268f elementor-widget elementor-widget-heading" data-id="0e6268f" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h3 class="elementor-heading-title elementor-size-default">Parte 3 - Fare un ulteriore passo avanti</h3>		</div>
				</div>
				<div class="elementor-element elementor-element-aa6e531 elementor-widget elementor-widget-text-editor" data-id="aa6e531" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				L&#8217;esempio precedente è funzionalmente corretto ma secondo me c&#8217;è un problema. I risultati sopra riportati non sono ordinati e si potrebbe aver esigenza di qualcosa di più della sola stampa dei risultati. Immagina di avere 3 parametri che possono produrre oltre a 100 combinazioni. Sarebbe piuttosto laborioso e soggetto a errori se si dovesse leggere le righe una per una. In questa parte, vedremo come accedere ai risultati dopo che cerebro avrà terminato la sua elaborazione.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-bef47f2 elementor-widget elementor-widget-bdt-source-code" data-id="bef47f2" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
from datetime import datetime

class rsiStrategy(bt.Strategy):
    params = (
        (&#039;period&#039;,21),
        )

    def __init__(self):
        self.startcash = self.broker.getvalue()
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=self.params.period)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: 
                self.buy(size=100) 
            elif self.rsi &gt; 70:
                self.sell(size=100)

if __name__ == &#039;__main__&#039;:
    #Variable for our starting cash
    startcash = 10000

    #Create an instance of cerebro
    cerebro = bt.Cerebro(optreturn=False)

    #Add our strategy
    cerebro.optstrategy(rsiStrategy, period=range(14,21))

    #Get Apple data from Yahoo Finance.
    data = bt.feeds.YahooFinanceData(
        dataname=&#039;AAPL&#039;,
        fromdate = datetime(2016,1,1),
        todate = datetime(2017,1,1),
        buffered= True
        )

    #Add the data to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(startcash)

    # Run over everything
    opt_runs = cerebro.run()

    # Generate results list
    final_results_list = []
    for run in opt_runs:
        for strategy in run:
            value = round(strategy.broker.get_value(),2)
            PnL = round(value - startcash,2)
            period = strategy.params.period
            final_results_list.append([period,PnL])

    #Sort Results List
    by_period = sorted(final_results_list, key=lambda x: x[0])
    by_PnL = sorted(final_results_list, key=lambda x: x[1], reverse=True)

    #Print results
    print(&#039;Results: Ordered by period:&#039;)
    for result in by_period:
        print(&#039;Period: {}, PnL: {}&#039;.format(result[0], result[1]))
    print(&#039;Results: Ordered by Profit:&#039;)
    for result in by_PnL:
        print(&#039;Period: {}, PnL: {}&#039;.format(result[0], result[1]))</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4e90b81 elementor-widget elementor-widget-heading" data-id="4e90b81" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Spiegazione del codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-e48da40 elementor-widget elementor-widget-text-editor" data-id="e48da40" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				In questo esempio, ci sono alcune modifiche al codice. Innanzitutto abbiamo rimosso il metodo <code style="color: #e83e8c;">stop()</code> nell&#8217;ultimo esempio. Avremo accesso a tutti i valori di cui abbiamo bisogno solo dopo che lo script avrà terminato l&#8217;esecuzione. Un altro cambiamento che potrebbe essere poco visibile se si sta semplicemente copiando e incollando il codice è:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d86155f elementor-widget elementor-widget-bdt-source-code" data-id="d86155f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>cerebro = bt.Cerebro(optreturn=False)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-7c07c55 elementor-widget elementor-widget-text-editor" data-id="7c07c55" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo caso abbiamo aggiunto un nuovo parametro all&#8217;inizializzazione di cerebro. Questo parametro modifica ciò che viene restituito da <code style="color: #e83e8c;">cerebro.run()</code> alla fine dello script. In un normale script cerebro.run() restituisce oggetti completi della classe strategia. Questi oggetti sono creati a partite dal modello della classe <code style="color: #e83e8c;">rsiStrategy</code> che abbiamo scritto nel codice. Gli oggetti <em>Strategia</em> permettono di accedere a tutti disponibili per cerebro durante il test (indicatori, dati, analizzatori, osservatori, ecc.) anche dopo il termine dell&#8217;esecuzione di cerebro. In questo modo si ha accesso a tutti i dati e i risultati. Tuttavia, durante l&#8217;ottimizzazione, cerebro.run() restituisce gli oggetti <code style="color: #e83e8c;">OptReturn</code> come impostazione di default predefinita. Questi sono oggetti limitati dato che contengono solo i parametri e gli analizzatori, al fine di migliorare la velocità di ottimizzazione.</p><p>Si presume che le metriche importanti necessarie per decidere quali parametri siano i migliori possano essere dedotte solo dagli analizzatori e dai parametri. Tuttavia, poiché gli esempi riportati in questo articolo hanno restituito il profitto finale, è opportuno mantenere questa convenzione anche nell&#8217;esempio finale. Per questo motivo, il parametro <strong>optreturn</strong> deve essere impostato su false poiché le informazioni del broker (per i profitti / perdite) non fanno parte di un analizzatore. Abbiamo bisogno di Cerebro per ricavare oggetti Strategia completi. Il resto del codice di interesse per questo esempio si verifica al termine dell&#8217;esecuzione di cerebro.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-690a3f5 elementor-widget elementor-widget-heading" data-id="690a3f5" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Ricavare i dati da un oggetto Strategia<br></h4>		</div>
				</div>
				<div class="elementor-element elementor-element-4ba46ca elementor-widget elementor-widget-bdt-source-code" data-id="4ba46ca" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Run over everything
opt_runs = cerebro.run()

# Generate results list
final_results_list = []
for run in opt_runs:
    for strategy in run:
        value = round(strategy.broker.get_value(),2)
        PnL = round(value - startcash,2)
        period = strategy.params.period
        final_results_list.append([period,PnL])</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c5f3982 elementor-widget elementor-widget-text-editor" data-id="c5f3982" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Cerebro restituisce un elenco di oggetti Strategia per ciascun ciclo tramite la lista dei parametri. In questo esempio, esiste solo una strategia. Tuttavia, poiché viene restituito una lista nidificata (lista di liste), è necessario iterare l&#8217;oggetto restituito per due volte per ottenere le informazioni necessarie. Dopo aver ricavato i valori desiderati, questi possono essere aggiunti alla lista <code style="color: #e83e8c;">final_results_list</code>. Questa lista può essere quindi ordinata come si desidera.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a243442 elementor-widget elementor-widget-bdt-source-code" data-id="a243442" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#Sort Results List
by_period = sorted(final_results_list, key=lambda x: x[0])
by_PnL = sorted(final_results_list, key=lambda x: x[1], reverse=True)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-f01a3d4 elementor-widget elementor-widget-text-editor" data-id="f01a3d4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Se non conosci Python, questa parte potrebbe sembrare un po&#8217; complessa. Anche <code style="color: #e83e8c;">final_results_list</code> è una lista nidificata. Per ordinarla correttamente, dobbiamo fornire una chiave di ordinamento. È quindi necessario passare una funzione all&#8217;argomento della keyword <code style="color: #e83e8c;">key</code>. Un <code style="color: #e83e8c;">lambda</code> è una piccola funzione formata da una riga che ci consente di utilizzare la chiave di ordinamento. Per ulteriori informazioni, ho aggiunto alcuni link di riferimento per letture di approffondimento alla fine di questo articolo.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a0d7e13 elementor-widget elementor-widget-heading" data-id="a0d7e13" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Risultati della 3° parte</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-44b544c elementor-widget elementor-widget-image" data-id="44b544c" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="832" height="486" src="https://datatrading.info/wp-content/uploads/2019/08/optimize-strategies-backtrader-trading-algoritmico-part3.png" class="attachment-large size-large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2019/08/optimize-strategies-backtrader-trading-algoritmico-part3.png 832w, https://datatrading.info/wp-content/uploads/2019/08/optimize-strategies-backtrader-trading-algoritmico-part3-768x449.png 768w" sizes="(max-width: 832px) 100vw, 832px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2f4c981 elementor-widget elementor-widget-text-editor" data-id="2f4c981" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Eccoci. Questo articolo è diventato molto più lungo di quanto mi aspettassi quando ho iniziato a scriverlo. Se sei riuscito a farcela fino a qui senza saltare, spero che il contenuto abbia fornito qualche consiglio e spunto operativo.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-86bf3cf elementor-widget elementor-widget-heading" data-id="86bf3cf" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Letture di Approfondimento</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-fe71963 elementor-widget elementor-widget-text-editor" data-id="fe71963" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<ol><li>Documentazione di Backtrader su l&#8217;ottimizzazione: <a href="https://www.backtrader.com/docu/quickstart/quickstart.html?highlight=optimize#let-s-optimize">https://www.backtrader.com/docu/quickstart/quickstart.html?highlight=optimize#let-s-optimize</a></li><li>Documentazione di Backtrader su Cerebro: <a href="https://www.backtrader.com/docu/cerebro.html">https://www.backtrader.com/docu/cerebro.html</a></li><li>Tutorial sul sorting di Python: <a href="https://docs.python.org/3/howto/sorting.html">https://docs.python.org/3/howto/sorting.html</a></li><li>Documentazione di Python su lambda: <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions">https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions</a></li></ol>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/ottimizzare-le-strategie-con-backtrader/">Ottimizzare le Strategie con BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Utilizzare gli Analyzers di Backtrader</title>
		<link>https://datatrading.info/utilizzare-lanalyzers-di-backtrader/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Wed, 16 Jan 2019 12:41:25 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1230</guid>

					<description><![CDATA[<p>Una volta compreso come scrivere una strategia di base, il passo successivo consiste nel quantificare la qualità di questa strategia. Backtrader ha una ricca libreria di strumenti di analisi in grado di fornire molte metriche, dal semplice rapporto vincite / perdite ai più complessi Sharpe Ratio e analisi del drawdown. Cosa sono gli Analyzer di &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/utilizzare-lanalyzers-di-backtrader/"> <span class="screen-reader-text">Utilizzare gli Analyzers di Backtrader</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/utilizzare-lanalyzers-di-backtrader/">Utilizzare gli Analyzers di Backtrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1230" class="elementor elementor-1230">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-4edf82a elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="4edf82a" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-fe3319c" data-id="fe3319c" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-895d107 elementor-widget elementor-widget-text-editor" data-id="895d107" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Una volta compreso come scrivere una strategia di base, il passo successivo consiste nel quantificare la qualità di questa strategia. Backtrader ha una ricca libreria di strumenti di analisi in grado di fornire molte metriche, dal semplice rapporto vincite / perdite ai più complessi Sharpe Ratio e analisi del drawdown.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2ead8fc elementor-widget elementor-widget-heading" data-id="2ead8fc" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Cosa sono gli Analyzer di Backtrader</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-6854771 elementor-widget elementor-widget-text-editor" data-id="6854771" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In poche parole, sono oggetti che possono essere caricati <em>cerebro</em> (il motore di Backtrader) e sono in grado di monitorare la tua strategia mentre questa viene eseguita. Quando cerebro ha terminato l&#8217;esecuzione del backtesting, è possibile accedere agli analizzatori tramite oggetti di strategia che sono restituiti da cerebro a termine dell&#8217;esecuzione. Gli stessi oggetti dell&#8217;analizzatore hanno un metodo (funzione) speciale che restituisce un dizionario di tutte le statistiche che l&#8217;analizzatore sta monitorando. A volte si tratta di molte informazioni e altre volte solo una o due statistiche. Non ti preoccupare se in questo momento ti sembra complesso, diventerà tutto più chiaro quando vedrai il codice. Esiste un&#8217;intera libreria dei diversi analizzatori che possono essere utilizzati in Backtrader (e se ne possono creare di nuovi in ogni momento). Dopo aver lavorato con questo script, dai un&#8217;occhiata alla <a href="https://www.backtrader.com/docu/analyzers/analyzers.html">documentazione</a> per vedere quali analizzatori ti interessano e modifica il codice per includerli nel tuo backtesting.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3281e8c elementor-widget elementor-widget-heading" data-id="3281e8c" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Obiettivo</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-7cbee4f elementor-widget elementor-widget-text-editor" data-id="7cbee4f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questo articolo ha lo scopo di mostrare come inizializzare, analizzare e restituire i risultati di un backtesting. E&#8217; il continuo del precedente articolo &#8220;<a href="http://datatrading.info/backtrader-primo-script/">Backtrader: Primo Script</a>&#8221; e fa parte della serie introduttiva di Backtrader. Per vedere le regole della strategia e la spiegazione del codice, dai un&#8217;occhiata al precedente articolo.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-84c1d1f elementor-widget elementor-widget-heading" data-id="84c1d1f" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Background</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-f48d0a7 elementor-widget elementor-widget-text-editor" data-id="f48d0a7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Esistono un paio di metriche di backtest / trading che rientrano in questo post. Ecco un glossario:</p>
<ul>
<li><strong>Strike Rate</strong>: questa è una percentuale che rappresenta il numero di volte di trade vincenti rispetto al numero totale di scambi che sono stati effettuati (tasso di vittoria / trade totali). Può aiutare a identificare se esiste un vantaggio nel mercato. Alcuni trader mirano a ottenere il strike rate più alto possibile, che corrisponde a tante piccole vincite. Altri sono felici con strike rate più bassi, ma puntano a grandi vincite e piccole perdite.</li>
<li><strong>SQN</strong>: <strong>S</strong>ystem <strong>Q</strong>uality <strong>N</strong>umber (numero di qualità del sistema), questo è stato definito dal dott. Van Tharp dell&#8217;istituto Van Tharp. In pratica dà un punteggio alla tua strategia. Una spiegazione più accademica del SQN, presente nel sito web di Van Tharp, è la seguente:&nbsp;</li>
</ul>
<blockquote>
<p><em>l&#8217;SQN misura la relazione tra la media (stimata) e la deviazione standard della distribuzione &#8220;R-multipla&#8221; generata da un sistema di trading. Apporta inoltre un adeguamento rispetto al numero di operazioni coinvolte.</em></p>
</blockquote>
<p>Nota: la documentazione di Backtrader fornisce un utile sistema di classificazione per SQN:</p>
<ul>
<li>1.6 &#8211; 1.9 Sotto la media</li>
<li>2,0 &#8211; 2,4 Media</li>
<li>2,5 &#8211; 2,9 Buono</li>
<li>3,0 &#8211; 5,0 Eccellente</li>
<li>5,1 &#8211; 6,9 Superbo</li>
<li>7.0 &#8211; Santo Graal?</li>
</ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8e43b94 elementor-widget elementor-widget-heading" data-id="8e43b94" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il Codice<br></h2>		</div>
				</div>
				<div class="elementor-element elementor-element-c7344eb elementor-widget elementor-widget-bdt-source-code" data-id="c7344eb" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
from datetime import datetime
from collections import OrderedDict

class RsiStrategy(bt.Strategy):

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=21)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: self.buy(size=100) else: if self.rsi &gt; 70:
                self.sell(size=100)


def tradeAnalysis(analyzer):
    &#039;&#039;&#039;
    Function to print the Technical Analysis results in a nice format.
    &#039;&#039;&#039;
    #Get the results we are interested in
    total_open = analyzer.total.open
    total_closed = analyzer.total.closed
    total_won = analyzer.won.total
    total_lost = analyzer.lost.total
    win_streak = analyzer.streak.won.longest
    lose_streak = analyzer.streak.lost.longest
    pnl_net = round(analyzer.pnl.net.total,2)
    strike_rate = (total_won / total_closed) * 100
    #Designate the rows
    h1 = [&#039;Total Open&#039;, &#039;Total Closed&#039;, &#039;Total Won&#039;, &#039;Total Lost&#039;]
    h2 = [&#039;Strike Rate&#039;,&#039;Win Streak&#039;, &#039;Losing Streak&#039;, &#039;PnL Net&#039;]
    r1 = [total_open, total_closed,total_won,total_lost]
    r2 = [strike_rate, win_streak, lose_streak, pnl_net]
    #Check which set of headers is the longest.
    if len(h1) &gt; len(h2):
        header_length = len(h1)
    else:
        header_length = len(h2)
    #Print the rows
    print_list = [h1,r1,h2,r2]
    row_format =&quot;{:&lt;15}&quot; * (header_length + 1)
    print(&quot;Trade Analysis Results:&quot;)
    for row in print_list:
        print(row_format.format(&#039;&#039;,*row))

def SQN(analyzer):
    sqn = round(analyzer.sqn,2)
    print(&#039;SQN: {}&#039;.format(sqn))

#Variable for our starting cash
startcash = 100000

#Create an instance of cerebro
cerebro = bt.Cerebro()

#Add our strategy
cerebro.addstrategy(RsiStrategy)

#Get Apple data from Yahoo Finance.
data = bt.feeds.YahooFinanceData(
    dataname=&#039;AAPL&#039;,
    fromdate = datetime(2009,1,1),
    todate = datetime(2017,1,1),
    buffered= True
    )

#Add the data to Cerebro
cerebro.adddata(data)

# Set our desired cash start
cerebro.broker.setcash(startcash)

# Add the analyzers we are interested in
cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name=&quot;ta&quot;)
cerebro.addanalyzer(bt.analyzers.SQN, _name=&quot;sqn&quot;)

# Run over everything
strategies = cerebro.run()
rsiStrat = strategies[0]

# print the analyzers
tradeAnalysis(rsiStrat.analyzers.ta.get_analysis())
SQN(rsiStrat.analyzers.sqn.get_analysis())

#Get final portfolio Value
portvalue = cerebro.broker.getvalue()

#Print out the final result
print(&#039;Final Portfolio Value: ${}&#039;.format(portvalue))

#Finally plot the end results
cerebro.plot(style=&#039;candlestick&#039;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-eaba9de elementor-widget elementor-widget-heading" data-id="eaba9de" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>Spiegazione del Codice</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-b10e12f elementor-widget elementor-widget-text-editor" data-id="b10e12f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Vediamo innanzitutto come aggiungere un Analyzer alla strategia consiste semplicemente nel richiamare la funzione <code style="color: #e83e8c;">addanaylzer()</code>. In particolare, si sta aggiungendo il TradeAnalyzer e assegnandogli un nome. Il nome rende molto più semplice accedere  questo oggetto in qualsiasi momento					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-da45df9 elementor-widget elementor-widget-bdt-source-code" data-id="da45df9" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name=&quot;ta&quot;)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-984803d elementor-widget elementor-widget-text-editor" data-id="984803d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Al termine dell&#8217;esecuzione di cerebro, viene restituito un elenco di oggetti strategia. In questo esempio abbiamo caricato in cerebro una sola strategia. Anche in questo caso, l&#8217;unica strategia viene comunque restituita all&#8217;interno di un array. Pertanto è necessario estrarre la nostra strategia  utilizzando un indice della posizione all&#8217;interno dell&#8217;array ([0]). Una volta che abbiamo quello, abbiamo la nostra strategia.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f5bc96f elementor-widget elementor-widget-bdt-source-code" data-id="f5bc96f" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Run over everything
strategies = cerebro.run()
firstStrat = strategies[0]</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b551c2a elementor-widget elementor-widget-text-editor" data-id="b551c2a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				A questo punto dobbiamo accedere ai nostri dati &#8230;. È possibile accedere agli Analyzers dall&#8217;interno dell&#8217;oggetto strategia ed utilizzare un metodo (funzione) nativo per restituire un dizionario (<code style="color: #e83e8c;">dict</code>) contenente tutti i risultati. Di seguito si evidenzia come lo script accede all&#8217;analyzer &#8220;ta&#8221; (che è il nome che gli abbiamo dato durante il caricamento dell&#8217;analyzer in cerebro) dall&#8217;oggetto strategia <code style="color: #e83e8c;">rsiStrat</code> e si richiama il metodo <code style="color: #e83e8c;">get_analysis()</code>.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-795e943 elementor-widget elementor-widget-bdt-source-code" data-id="795e943" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>bt.analyzers.TradeAnalyzer, _name=&quot;ta&quot;</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-4077c89 elementor-widget elementor-widget-text-editor" data-id="4077c89" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dopo aver ottenuto il dizionario dei dati, è necessario estrarre i dati che ci interessano ed elaborarli a seconda dei nostri scopi. In questo caso, si considerano solo alcune metriche e vengono stampate sul terminale. Tuttavia, è possibile espandere questa soluzione ed esportare i risultati in un CSV. In questo esempio si esaminano:</p><ul><li>Totale operazioni ancora aperte</li><li>Totale operazioni chiuse</li><li>Totale operazioni vincenti</li><li>Totale operazioni perdenti</li><li>Strike rate (che si calcola sulla base dei dati forniti)</li><li>Migliore serie vincente</li><li>Peggior serie perdente</li><li>Profitti o perdite.</li><li>SQN della strategia</li></ul><p>Per fare ciò ho creato due funzioni di stampa speciali. E&#8217; quindi possibile riutilizzare questo codice (copia e incolla) per gli script futuri.</p><p>La funzione di stampa che merita di essere commentata più avanti è:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3d90035 elementor-widget elementor-widget-bdt-source-code" data-id="3d90035" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>tradeAnalysis(analyzer):</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-97bc854 elementor-widget elementor-widget-text-editor" data-id="97bc854" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Temo che questa funzione possa essere eccessivamente complessa per questo articolo introduttivo e destinato ai principianti a causa della linea mostrata di seguito. 
Mi piace solo l&#8217;output pulito che produce nel terminale. Contiene alcune tecniche avanzate di Python per la formattazione del testo. Sto parlando della linea che assomiglia a questa:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-2ce5be6 elementor-widget elementor-widget-bdt-source-code" data-id="2ce5be6" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>row_format =&quot;{:&lt;15}&quot; * (header_length + 1)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-879f876 elementor-widget elementor-widget-text-editor" data-id="879f876" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questa riga mi consente di stampare l&#8217;output distribuito uniformemente senza dover installare un altro modulo di Python, come TextTable. Per ulteriori informazioni sulla formattazione dei dati in Python, consultare i documenti qui: <a href="https://docs.python.org/3/library/string.html#formatspec">https://docs.python.org/3/library/string.html</a></p><p>Un&#8217;alternativa (e un&#8217;opzione molto più semplice) consiste nell&#8217;utilizzare il metodo print() integrato nativamente nella classe dell&#8217;analyzer. Questo metodo stampa ogni valore all&#8217;interno dell&#8217;analizzatore su una riga separata. Se vuoi farlo o no è solo questione di gusti personali. Ad esempio, se si desidera disporre di una formattazione alternativa, selezionare determinate statistiche di interesse o elaborare ulteriormente i dati. Di seguito è riportato un esempio di come gestire questa alternativa:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3758470 elementor-widget elementor-widget-bdt-source-code" data-id="3758470" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code># Run over everything
strategies = cerebro.run()
firstStrat = strategies[0]

for x in firstStrat.analyzers:
    x.print()</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-550e353 elementor-widget elementor-widget-heading" data-id="550e353" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">I Risultati</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-5e25ea0 elementor-widget elementor-widget-text-editor" data-id="5e25ea0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Eseguendo lo script si dovrebbe otterene qualcosa del genere al seguente output:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-08517ce elementor-widget elementor-widget-image" data-id="08517ce" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="1023" height="468" src="https://datatrading.info/wp-content/uploads/2018/01/output-analyzer-backtrader-trading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2018/01/output-analyzer-backtrader-trading-algoritmico.jpg 1023w, https://datatrading.info/wp-content/uploads/2018/01/output-analyzer-backtrader-trading-algoritmico-768x351.jpg 768w" sizes="(max-width: 1023px) 100vw, 1023px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5f1c34a elementor-widget elementor-widget-text-editor" data-id="5f1c34a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Non è un ottimo risultato di trading! Sembra che la nostra strategia super semplice abbia bisogno di qualche raffinamento.</p><p>Chi l&#8217;avrebbe mai detto?!?</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/utilizzare-lanalyzers-di-backtrader/">Utilizzare gli Analyzers di Backtrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>BackTrader: Primo Script</title>
		<link>https://datatrading.info/backtrader-primo-script/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Thu, 10 Jan 2019 11:38:25 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1216</guid>

					<description><![CDATA[<p>Dopo aver creato il nostro ambiente di sviluppo, come descritto in questo articolo, è il tempo di scrivere il nostro primo script. Obiettivo Questo articolo ha lo scopo di creare una semplice strategia basata sugli indicatori, mantenendo il codice il più semplice possibile. Cercherò di evitare alcuni concetti più avanzati presenti nella documentazione e in &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/backtrader-primo-script/"> <span class="screen-reader-text">BackTrader: Primo Script</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/backtrader-primo-script/">BackTrader: Primo Script</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1216" class="elementor elementor-1216">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-1548549 elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="1548549" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-c749d00" data-id="c749d00" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-c4a7be2 elementor-widget elementor-widget-text-editor" data-id="c4a7be2" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dopo aver creato il nostro ambiente di sviluppo, come descritto in <a href="http://datatrading.info/setup-di-base-per-python-e-backtrader/">questo articolo</a>, è il tempo di scrivere il nostro primo script.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-3691bdb elementor-widget elementor-widget-heading" data-id="3691bdb" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Obiettivo</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-bd20757 elementor-widget elementor-widget-text-editor" data-id="bd20757" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Questo articolo ha lo scopo di creare una semplice strategia basata sugli indicatori, mantenendo il codice il più semplice possibile. Cercherò di evitare alcuni concetti più avanzati presenti nella documentazione e in Python in generale. Ad esempio le linee come:					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a5d07db elementor-widget elementor-widget-bdt-source-code" data-id="a5d07db" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>if __name__ == &#039;__main__&#039;: </code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-d6e00b9 elementor-widget elementor-widget-text-editor" data-id="d6e00b9" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>non saranno inclusi poiché ritengo che per imparare è necessario che i principianti dovrebbero cercare di reperire le informazioni su internet ed inoltre non voglio distrarre il lettore dalle funzionalità strettamente legate alla strategia che si vuole implementare (anche se alcuni programmatori professionisti potrebbero deridere la qualità del codice).</p><p><strong>Ambito di backtesting</strong>: Per motivi di semplicità, il tutorial non include le commissioni, lo spread o altre considerazioni di backtesting più avanzate come benchmarking, l&#8217;ottimizzazione e l&#8217;analisi dei trade. Ho anche scelto di escludere la stampa / log per mantenere il codice il più semplicepossibile. (Anche se penso che la stampa / log sia importante per il debug quando aumenta la complessità del codice!)</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-8d1f664 elementor-widget elementor-widget-heading" data-id="8d1f664" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">La Strategia</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-a3c4d4f elementor-widget elementor-widget-text-editor" data-id="a3c4d4f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Al momento della stesura di questo articolo siamo in presenza di un lungo mercato rialzista. Quando si negoziano azioni in un tale mercato, è ragionevolmente pensare di andare long. La ragione di ciò è che si trovano sul lato giusto del momentum long alla base della dinamica ascendente.</p><p>Con questo in mente, divertiamoci un po &#8216;a implementare una strategia &#8220;solo long&#8221; che andrà long quando un semplice indicatore RSI giornaliero è ipervenduto e si mantiene la posizione fino a quando l&#8217;RSI non raggiungerà il livello di ipercomprato.</p><p><strong>Entry</strong></p><ul><li>Quando RSI &lt;30</li></ul><p><strong>Exit</strong></p><ul><li>Quando RSI&gt; 70</li></ul><p><strong>Gestione del trade e dimensionamento delle posizioni</strong></p><ul><li>Non si implementa nessuna gestione del trade. Non è previsto nessun ridimensionamento in / out. Solo semplici acquisti e vendite con un&#8217;unica posizione aperta alla volta.</li><li>Per quanto riguarda le dimensioni della posizione, si semplifica le cose comprando / vendendo 100 azioni alla volta senza fare calcoli per vedere se abbiamo abbastanza liquidità per le dimensioni della posizione (se non abbiamo abbastanza liquidità, backtrader è abbastanza intelligente da rifiutare l&#8217;ordine)</li></ul><p><strong>Settaggio dell&#8217;indicatore</strong></p><ul><li>Periodo = 21<br />Consente di utilizzare una finestra mobile più lunga rispetto ai 14 periodo standard. In teoria ciò dovrebbe tradursi nell&#8217;avere meno falsi segnali falsi e il prezzo dovrebbe scendere / aumentare di più prima di essere considerato ipercomprato / ipervenduto.</li></ul><div> </div>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e39c37b elementor-widget elementor-widget-heading" data-id="e39c37b" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Requisiti</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-8823c5a elementor-widget elementor-widget-text-editor" data-id="8823c5a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Questo script estrae i dati online da Yahoo. Penso che questo semplifichi le cose per un primo script in quanto non sarà scaricare ed utilizzare i propri dati. Tuttavia, per questo motivo, lo script richiede laa versione backtrader 1.9.49.116 o successiva a causa delle recenti modifiche nell&#8217;API di Yahoo.<br />Per verificare la versione di backtrader che stai utilizzando hai alcune opzioni. Per prima cosa puoi controllare il pip semplicemente digitando:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0f82aee elementor-widget elementor-widget-bdt-source-code" data-id="0f82aee" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>pip3 list</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-1b8fffe elementor-widget elementor-widget-text-editor" data-id="1b8fffe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>(Nota per gli utenti di Windows: invece di &#8220;pip3&#8221; potrebbe essere &#8220;pip&#8221; se è installata solo una versione di python)</p><p> </p><p>Quindi basta cercare la voce &#8220;backtrader&#8221; nell&#8217;output del precedente comando. <span style="letter-spacing: 0px;">Gli utenti Linux e Mac possono rendere questo processo un po &#8216;più veloce eseguendo il piping dell&#8217;output su grep.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6abbb47 elementor-widget elementor-widget-bdt-source-code" data-id="6abbb47" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>pip3 list | grep backtrader</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-14764b0 elementor-widget elementor-widget-text-editor" data-id="14764b0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="letter-spacing: 0px;">Ho notato che su una delle mie macchine Linux, pip3 riportava una versione inferiore rispetto a quella effettivamente installata (non ho ancora capito perché). Quindi, se la versione segnalata non sembra corretta, puoi anche controllarla aprendo una shell python, importando backtrader e stampare la versione.</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5254e7a elementor-widget elementor-widget-bdt-source-code" data-id="5254e7a" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader as bt
print(bt.__version__)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-1cd4f98 elementor-widget elementor-widget-text-editor" data-id="1cd4f98" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><span style="letter-spacing: 0px;">Se non si utilizza la versione più recente, avviare un terminale (o il prompt dei comandi) e digitare i seguenti comandi:</span></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-210d605 elementor-widget elementor-widget-bdt-source-code" data-id="210d605" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>pip3 install --upgrade backtrader</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-2c377ef elementor-widget elementor-widget-heading" data-id="2c377ef" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>I risultati</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-a731ffc elementor-widget elementor-widget-text-editor" data-id="a731ffc" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Per vedere i risultati del test in un grafico bidimensionale, si può usare la libreria Python (esterna all&#8217;installazione standard) chiamata &#8220;Matplotlib&#8221;. Questo modulo è la libreria grafica defacto per molti scienziati, analisti e ricercatori che usano Python.</p><p>Assicurati di averlo installato aprendo un terminale o un prompt dei comandi e digitando:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ee280da elementor-widget elementor-widget-bdt-source-code" data-id="ee280da" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>pip3 install matplotlib</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-f425ce8 elementor-widget elementor-widget-heading" data-id="f425ce8" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default"><br>Il Codice</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-9d09bb1 elementor-widget elementor-widget-text-editor" data-id="9d09bb1" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Lo script è composto da due parti principali. La prima parte si crea una nuova classe dove implementare tutta la logica della strategia. Nella seconda parte si configura l&#8217;ambiente di esecuzione dello script (come aggiungere il framework, prevedere una fonte dati per i test, ecc.).

<strong>Nota importante</strong>: in questo esempio si utilizza i dati disponibili con l&#8217;API di Quandl. Con questa API sei limitato al numero di chiamate che puoi effettuare al giorno. Per avere accesso illimitato ai loro dati è sufficiente registrarsi gratuitamente nel loro sito e richiedere una API key ed aggiungi la keyword <code style="color: #e83e8c;">apikey</code> alla chiamata ai dati di quandl in questo modo (<a href="https://www.quandl.com/?modal=register">www.quandl.com</a>):					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ec093a7 elementor-widget elementor-widget-bdt-source-code" data-id="ec093a7" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>​data = bt.feeds.Quandl(
    dataname=&#039;F&#039;,
    fromdate = datetime(2016,1,1),
    todate = datetime(2017,1,1),
    buffered= True,
    apikey=&quot;INSERT YOUR API KEY&quot;
    )</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-40e5a35 elementor-widget elementor-widget-heading" data-id="40e5a35" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default"><br>Imports<br></h4>		</div>
				</div>
				<div class="elementor-element elementor-element-61cb328 elementor-widget elementor-widget-bdt-source-code" data-id="61cb328" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>​import backtrader as bt
from datetime import datetime</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-c75b84f elementor-widget elementor-widget-text-editor" data-id="c75b84f" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Il primo import dovrebbe essere abbastanza ovvia. Stiamo importando il framework backtrader. Inoltre, si importa il modulo datetime dalla libreria standard di Python. Questo è usato per impostare le date di inizio e fine del periodo di backtesting. Backtrader prevede di ricevere oggetti datetime durante la creazione di feed di dati. Per ulteriori informazioni sul modulo datetime, consultare la documentazione disponibile su:</p><p><a href="https://docs.python.org/3/library/datetime.html">docs.python.org/3/library/datetime.html</a></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-1bc10c1 elementor-widget elementor-widget-heading" data-id="1bc10c1" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">La strategia<br></h4>		</div>
				</div>
				<div class="elementor-element elementor-element-a9f3a78 elementor-widget elementor-widget-bdt-source-code" data-id="a9f3a78" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>class firstStrategy(bt.Strategy):

    def __init__(self):
        self.rsi = bt.indicators.RSI_SMA(self.data.close, period=21)

    def next(self):
        if not self.position:
            if self.rsi &lt; 30: self.buy(size=100) else: if self.rsi &gt; 70:
                self.sell(size=100)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-fc0a485 elementor-widget elementor-widget-text-editor" data-id="fc0a485" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>​Quando si crea una strategia in backtrader, si eredita molti metodi e attributi dalla classe base `bt.Strategy`. In parole più semplici, si sta fondamentalmente prendendo il template di una strategia che è stata scritta nel framework di backtest e aggiungendo la nostra logica sopra ad essa. Quando nella programmazione si usa l&#8217;ereditarietà, possiamo usare tutto il codice che è stato scritto nella strategia di base e sovrascrivere le parti che vogliamo cambiare. Ciò significa che non è necessario preoccuparsi di tutto il codice, dietro le quinte, che consente di interagire con i dati, gestire gli ordini, le notifiche dei broker e così via. E&#8217; Il framework BackTrader che se ne occupa! La nuova classe della strategia può essere breve, pulita e di facile lettura. Tuttavia, se lo desideri, puoi scavare più a fondo e modificare il contenuto del nucleo della classe base.</p><p>La nostra classe si chiama <code style="color: #e83e8c;">firstStrategy</code> (piuttosto originale) e contiene il codice per l&#8217;inizializzazione della strategia e il metodo &#8220;next&#8221;.</p><p>L&#8217;inizializzazione è solo una riga, vogliamo solo inizializzare un indicatore RSI dalla libreria di backtrader. Per fare ciò si aggiunge l&#8217;indicatore durante l&#8217;inizializzazione della strategia (<code style="color: #e83e8c;">__init__</code>). Una volta impostato, backtrader si occupa di tenere traccia dei dati, calcolare i risultati e aggiungerli al grafico finale.</p><p>Se non conosci la programmazione, è importante notare che puoi chiamare il tuo indicatore RSI come preferisci, ma devi prefissarlo con &#8220;self&#8221;. Ciò ti consentirà di accedervi da altri metodi (chiamati anche &#8220;funzioni&#8221; quando non stiamo parlando di una classe). In questo caso, abbiamo semplificato la lettura del codice e inizializzato l&#8217;indicatore come &#8220;self.rsi&#8221;.</p><p>Il metodo <code style="color: #e83e8c;">next</code> (funzione) viene chiamato ad ogni nuova barra o, in altre parole, ogni volta che viene ricevuta una nuova candela. È in questo metodo che si deve scrivere la logica &#8220;<em>if this then that</em>&#8220;. In questo esempio si controlla se siamo in posizione, dato che come prerequisito si prevede di effettuare un solo trade alla volta. Se non siamo in una posizione, allora si verifica il livello dell&#8217;indicatore RSI. Se è inferiore a 30, si acquista 100 azioni. Se è superiore non si fa nulla (Perché non abbiamo scritto alcun codice per ciò che accade quando l&#8217;RSI è sopra i 30 e non siamo in una posizione). Il secondo step della logica prevede le azioni da fare quando SIAMO già in una posizione. In questo caso si cerca un&#8217;opportunità di vendita. Se l&#8217;RSI supera i 70, si vende tutte le 100 azioni. Altrimenti, di nuovo non si fa nulla. Questo si ripete ogni volta che arriva una nuova candela (ogni giorno) fino a quando tutti i dati sono stati controllati.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-67f8cc7 elementor-widget elementor-widget-heading" data-id="67f8cc7" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Il Setup<br></h4>		</div>
				</div>
				<div class="elementor-element elementor-element-9c095fd elementor-widget elementor-widget-bdt-source-code" data-id="9c095fd" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>#Variable for starting cash
startcash = 10000

#Create instance of cerebro
cerebro = bt.Cerebro()

#Add strategy
cerebro.addstrategy(firstStrategy)

#Get Apple data from Yahoo Finance.
data = bt.feeds.Quandl(
    dataname=&#039;AAPL&#039;,
    fromdate = datetime(2016,1,1),
    todate = datetime(2017,1,1),
    buffered= True
    )

#Add the data to Cerebro
cerebro.adddata(data)

# Set desired cash start
cerebro.broker.setcash(startcash)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-b8e6683 elementor-widget elementor-widget-text-editor" data-id="b8e6683" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dopo aver scritto la strategia, è necessario implementare il setup e all&#8217;esecuzione. Questo in sostanza si riduce a:</p><ul><li>Chiamare il motore backtrader (cerebro)</li><li>Ottenere i dati storici e caricarli nel motore.</li><li>Impostazione della quantità di denaro che dobbiamo negoziare (startcash)</li><li>Caricare la strategia nel motore</li><li>Esecuzione del test</li><li>Monitorare i risultati</li></ul><p>Alcune cose da sottolineare:</p><ul><li>Durante la stampa, si utilizza l&#8217;argomento con keyword <code style="color: #e83e8c;">style = candlestick</code>, se non lo si utilizza si ottiene un grafico a linee del prezzo di chiusura.</li><li>Durante l&#8217;inizializzazione del feed dei dati si richiama il modulo <code style="color: #e83e8c;">datetime</code>, come sottolineato in precedenza. Stiamo passando un oggetto datetime agli argomenti della keyword <code style="color: #e83e8c;">fromdate</code> e <code style="color: #e83e8c;">todate</code>. Infine la keyword <code style="color: #e83e8c;">buffer</code> indica che backtrader eseguirà il buffer di tutti i dati richiesti prima dell&#8217;inizio dell&#8217;analisi.</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-064d745 elementor-widget elementor-widget-heading" data-id="064d745" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Eseguire lo script</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-2c16583 elementor-widget elementor-widget-text-editor" data-id="2c16583" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Presumo che tu abbia svolto le lezioni di base su Python, come menzionato nel mio <a href="http://datatrading.info/setup-di-base-per-python-e-backtrader/">precedente post</a>. Quindi copia il codice, aggiungi le parti basi del linguaggio, avvia lo script e controlla i risultati.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-5c663f2 elementor-widget elementor-widget-heading" data-id="5c663f2" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">I Risultati</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-dd37e0d elementor-widget elementor-widget-image" data-id="dd37e0d" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="700" height="610" src="https://datatrading.info/wp-content/uploads/2018/01/Primo-Script-backtrader-trading-algoritmico.png" class="attachment-large size-large" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-efc1b5d elementor-widget elementor-widget-text-editor" data-id="efc1b5d" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>2 operazioni in profitto. Tasso di vincita del 100%. Saremo ricchi!</p><p> </p><p>Tornando ad un tono più serio, prendi questi risultati con le pinze. Non abbiamo confrontato i risultati con un benchmark o una semplice strategia di &#8220;buy &amp; hold&#8221;. Non abbiamo aggiunto commissioni e slippage, non disponiamo di dati di test a lungo termine sufficienti per convalidare la strategia. Un test per un titolo azionario in solo anno non dovrebbe riempirci di fiducia, ma almeno abbiamo creato una base per fare ricerche ulteriori.</p>					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/backtrader-primo-script/">BackTrader: Primo Script</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Setup di base per Python e BackTrader</title>
		<link>https://datatrading.info/setup-di-base-per-python-e-backtrader/</link>
		
		<dc:creator><![CDATA[Gianluca]]></dc:creator>
		<pubDate>Fri, 04 Jan 2019 09:28:06 +0000</pubDate>
				<category><![CDATA[ToolBox BackTrader]]></category>
		<category><![CDATA[Toolbox Backtrader]]></category>
		<guid isPermaLink="false">https://datatrading.info/?p=1180</guid>

					<description><![CDATA[<p>In questo post, diamo un&#8217;occhiata a come scaricare Python, dove recuperare i migliori tutorial introduttivi su Python, installare il framework BackTrader e infine verificare che sei in grado di accedere al framework all&#8217;interno di Python. Se sei ancora indeciso quale framework di backtesting o linguaggio di programmazione usare, puoi consultare l&#8217;articolo sui linguaggi di programmazione &#8230;</p>
<p class="read-more"> <a class="" href="https://datatrading.info/setup-di-base-per-python-e-backtrader/"> <span class="screen-reader-text">Setup di base per Python e BackTrader</span> Leggi tutto »</a></p>
<p>L'articolo <a rel="nofollow" href="https://datatrading.info/setup-di-base-per-python-e-backtrader/">Setup di base per Python e BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></description>
										<content:encoded><![CDATA[		<div data-elementor-type="wp-post" data-elementor-id="1180" class="elementor elementor-1180">
						<div class="elementor-inner">
				<div class="elementor-section-wrap">
									<section class="elementor-section elementor-top-section elementor-element elementor-element-92c185f elementor-section-boxed elementor-section-height-default elementor-section-height-default" data-id="92c185f" data-element_type="section">
						<div class="elementor-container elementor-column-gap-default">
							<div class="elementor-row">
					<div class="elementor-column elementor-col-100 elementor-top-column elementor-element elementor-element-47945c7" data-id="47945c7" data-element_type="column">
			<div class="elementor-column-wrap elementor-element-populated">
							<div class="elementor-widget-wrap">
						<div class="elementor-element elementor-element-e0ad4a4 elementor-widget elementor-widget-text-editor" data-id="e0ad4a4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>In questo post, diamo un&#8217;occhiata a come scaricare Python, dove recuperare i migliori tutorial introduttivi su Python, installare il framework BackTrader e infine verificare che sei in grado di accedere al framework all&#8217;interno di Python. Se sei ancora indeciso quale framework di backtesting o linguaggio di programmazione usare, puoi consultare l&#8217;articolo sui linguaggi di programmazione e gli ambienti di backtesting.</p><p><em>Nota: Questo post non va oltre il semplice settaggio di un ambiente di sviluppo per Python. Puoi quindi saltare questo articolo se hai già esperienza nell&#8217;uso di Python e pip</em>.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c90adea elementor-widget elementor-widget-heading" data-id="c90adea" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Installare Python</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-db8af00 elementor-widget elementor-widget-heading" data-id="db8af00" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Linux:</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-c38d53a elementor-widget elementor-widget-text-editor" data-id="c38d53a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Se sei un utente Linux, sei molto fortunato. Molto probabilmente Python è già installato. In effetti, potrei scrivere cose superflue poiché non conosco nessun utente Linux che non sia già a conoscenza e / o abbia già armeggiato con Python in passato.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7c586f9 elementor-widget elementor-widget-heading" data-id="7c586f9" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Mac OS:</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-b8b4fbe elementor-widget elementor-widget-text-editor" data-id="b8b4fbe" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Ce l&#8217;hai, ma non lo usi&#8230; La versione di Python installata con il sistema operativo è destinata esclusivamente al sistema. Alcune persone lo chiamano &#8220;system python&#8221;. Perché non dovresti usarlo? Da sottolineare che questa versione di Python è la vecchia versione python 2 mentre la maggior parte dei tutorial su questo sito è codificato con python 3. Un altro problema è che l&#8217;aggiornamento di Mac OS può potenziale per interrompere alcuni degli aggiornamenti installati sulla versione di sistema di python. Inoltre, alcuni pacchetti sono difficili da aggiornare a causa delle modifiche apportate da Apple nella versione python del sistema. Infine, il sistem python è disponibile solo tramite il terminale. Non c&#8217;è alcuna voce nella cartella delle applicazioni e nessun programma di avvio su cui fare clic.</p><p>Quindi, come puoi immaginare, ti consiglio di scaricare e installare una nuova versione di Python. Dopo aver scaricato e installato Python, avrai una cartella Python 3.x nella cartella delle applicazioni.<br />Questa ha un IDE (un ambiente di sviluppo) per scrivere ed eseguire il codice Python. Inoltre viene anche installato un launcher python che essenzialmente consente di avviare (eseguire) script Python facendo doppio clic su di essi.</p><p>Quindi iniziamo:</p><p>Per prima cosa vai alla pagina dei download sul sito Web python.org facendo<a href="https://www.python.org/downloads/mac-osx/"> clic qui</a>.</p><p>Quindi scegli di installare l&#8217;ultima versione di Python 3. (secondo link dall&#8217;alto)</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d009f51 elementor-widget elementor-widget-image" data-id="d009f51" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="300" height="204" src="https://datatrading.info/wp-content/uploads/2018/01/python-mac-os-trading-algoritmico.jpg" class="attachment-medium size-medium" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-420f3c0 elementor-widget elementor-widget-text-editor" data-id="420f3c0" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dove aver scarico l&#8217;installer, è sufficiente seguire i classici steps per l&#8217;installazione di un software sul MAC.</p><p>Per verificare se Python è stato installato correttamente è sufficiente:</p><ol><li>Aprire un Terminale (se non sai dove si trova l&#8217;applicazione Terminale, puoi aprire una finistra di ricerca e digitare &#8220;terminal”)</li><li>Digitare <code>python3</code> nel termnale e premere Enter.</li></ol><p>Si dovrà ottenere un risultato simile al seguente:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-cdae4e2 elementor-widget elementor-widget-image" data-id="cdae4e2" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="400" height="280" src="https://datatrading.info/wp-content/uploads/2018/01/Python-terminal-output-trading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d5547e7 elementor-widget elementor-widget-text-editor" data-id="d5547e7" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per uscire dalla shell di python è necessario digitare <code style="color: #e83e8c;">quit()</code> e premere Enter. (Questa è una funzione &#8220;built-in&#8221; per uscire dalla shell.)					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-7111624 elementor-widget elementor-widget-heading" data-id="7111624" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Windows:</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-eae66c5 elementor-widget elementor-widget-text-editor" data-id="eae66c5" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Windows non prevede nessuna versione di Python installata per default. Rispetto al Mac, questo rende le cose più semplici perchè non ci si deve preoccupare di un &#8220;python di sistema&#8221;. Come sopra, si inizia dalla pagina dei download di Python, facendo <a href="https://www.python.org/downloads/windows/">clic qui</a>.</p><p>Una volta caricata la pagina, si seleziona di nuovo il secondo collegamento dall&#8217;alto, l&#8217;ultima versione di Python 3. Sembra identico allo precedente screenshot per Mac OS tranne che la scritta &#8220;Mac OS X&#8221; è sostituita con &#8220;Windows&#8221; (come ci si aspetterebbe!).</p><p>Dopo aver scaricato il programma di installazione, seguire i soliti passaggi per l&#8217;installazione per i software in ambiente Windows. Nella prima schermata di installazione è necessario assicurasi di selezionare:</p><ol><li>Installa per tutti gli utenti</li><li>Aggiungi Python 3.x al PATH.</li></ol>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a52728a elementor-widget elementor-widget-image" data-id="a52728a" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="300" height="185" src="https://datatrading.info/wp-content/uploads/2018/01/python-windows-trading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-a707d25 elementor-widget elementor-widget-text-editor" data-id="a707d25" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per verificare che python sia stato installato correttamente, è sufficiente aprire un prompt dei comandi e digitare python. Da notare che non è necessario specificare &#8216;python3&#8217; poiché su Windows non è possibile installate contemporaneamente diverse versioni di Python. L&#8217;output che si dovrebbe ottenere è lo stesso di quello per il Mac OS.					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-99f3e5a elementor-widget elementor-widget-image" data-id="99f3e5a" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="768" height="402" src="https://datatrading.info/wp-content/uploads/2018/01/python-win-install-trading-algoritmico-768x402.png" class="attachment-medium_large size-medium_large" alt="" loading="lazy" srcset="https://datatrading.info/wp-content/uploads/2018/01/python-win-install-trading-algoritmico-768x402.png 768w, https://datatrading.info/wp-content/uploads/2018/01/python-win-install-trading-algoritmico.png 979w" sizes="(max-width: 768px) 100vw, 768px" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e0d0d11 elementor-widget elementor-widget-text-editor" data-id="e0d0d11" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per uscire dalla shell di python si deve digitare <code style="color: #e83e8c;">quit()</code> e premere Enter. Questa è la funzione &#8220;built-in&#8221; per uscire dalla shell&#8230;					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c7ce900 elementor-widget elementor-widget-heading" data-id="c7ce900" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Primi passi con Python</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-0d1e93b elementor-widget elementor-widget-text-editor" data-id="0d1e93b" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Una volta installato Python 3, ti consiglio di imparare alcune nozioni di base in modo da comprendere completamente la logica alla base di BackTrader. Sia che tu preferisca imparare con un libro, sul Web o sporcarti le mani nei documenti ufficiali, hai  moltissime opzioni per apprendere tutte le funzionalità di questo linguaggio. Ho verificato la bontà dei contenuti che consiglio di seguito.</p><p>Gran parte di ciò che faremo nel trading si riduce al construtto &#8220;<em>If this happens then do that</em>&#8220;. Almeno all&#8217;inizio lLe competenze di base dovrebbero essere sufficienti, quindi non pensare di dover trascorrere mesi a studiare. Credo fortemente che il modo migliore per imparare le cose sia studiarle man mano che si va avanti con la sperimentazione e implementazione. Se passi troppo tempo a fare tutorial su progetti che non ti interessano, è facile annoiarsi e sentirsi frustrati quindi si rimarrà inevitabilmente bloccati.</p><p>Alcune concetti basi da imparare sono:</p><ul><li>Assegnare variabili</li><li>Operazioni di base</li><li>Dichiarazioni If / Else</li><li>I cicli loop</li><li>Scrivere funzioni</li><li>Le basi delle Classi</li></ul>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-93b7e0d elementor-widget elementor-widget-heading" data-id="93b7e0d" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Sul Web – Python Programming</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-0f8d73a elementor-widget elementor-widget-text-editor" data-id="0f8d73a" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><a href="https://pythonprogramming.net/introduction-to-python-programming/">https://pythonprogramming.net/introduction-to-python-programming/</a></p><p>​Questo sito offre una serie di eccellenti tuturial su una vasta gamma di argomenti. Meglio ancora, Harrison (l&#8217;autore) fornisce video e commenti ad ogni lezione della serie. Probabilmente il miglior sito sulla rete relativo alla programmazione in Python.</p><p>Purtroppo non ho trovato nulla di paragonabile (in termini di quantità e qualità) in italiano.</p><p>Ecco una copia del video di Harrison relativo all&#8217;introduzione della programmazione in Python:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-e7145f1 elementor-aspect-ratio-169 elementor-widget elementor-widget-video" data-id="e7145f1" data-element_type="widget" data-settings="{&quot;youtube_url&quot;:&quot;https:\/\/youtu.be\/UsCQXe1OHZk?list=PLQVvvaa0QuDe8XSftW-RAxdo6OmaeL85M&quot;,&quot;video_type&quot;:&quot;youtube&quot;,&quot;controls&quot;:&quot;yes&quot;,&quot;aspect_ratio&quot;:&quot;169&quot;}" data-widget_type="video.default">
				<div class="elementor-widget-container">
					<div class="elementor-wrapper elementor-fit-aspect-ratio elementor-open-inline">
			<div class="elementor-video"></div>		</div>
				</div>
				</div>
				<div class="elementor-element elementor-element-ea8e8ed elementor-widget elementor-widget-text-editor" data-id="ea8e8ed" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut elit tellus, luctus nec ullamcorper mattis, pulvinar dapibus leo.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-0febac4 elementor-widget elementor-widget-heading" data-id="0febac4" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Libri – Automatizzare le cose noiose con Python</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-86b943a elementor-widget elementor-widget-image" data-id="86b943a" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
													<a href="https://amzn.to/2SYzCb6">
							<img width="142" height="200" src="https://datatrading.info/wp-content/uploads/2018/01/python-libro-trading-algoritmico.jpg" class="attachment-medium size-medium" alt="" loading="lazy" />								</a>
														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-f5bf858 elementor-widget elementor-widget-text-editor" data-id="f5bf858" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p><a href="https://amzn.to/2SYzCb6">Automatizzare le cose noiose con Python. Programmazione pratica per principianti assoluti</a> fornisce progetti di automazione rivolti al principiante. L&#8217;aspetto interessante è che tali progetti hanno impatto nella nostra vita quotidiana. Si lavora con la gestione dei file, i fogli Excel, le ricerche sul web ecc. Trovo che non ci sia nulla di più soddisfacente che ottenere un uso pratico e regolare da qualcosa che hai codificato.</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-6785114 elementor-widget elementor-widget-heading" data-id="6785114" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h4 class="elementor-heading-title elementor-size-default">Sporcarsi le mani -  I docs ufficiali</h4>		</div>
				</div>
				<div class="elementor-element elementor-element-9e209aa elementor-widget elementor-widget-text-editor" data-id="9e209aa" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Python fornisce un&#8217;ottima documentazione sul proprio sito ufficiale. All&#8217;inizio alcuni potrebbero trovare la documentazione un po &#8216;intimidatoria (specialmente quelli senza background informatico) ma è necessario attenersi ad essa. Una volta che ci si è abituati, questo diventa una preziosa risorsa.</p><p><a href="https://docs.python.org/3/">https://docs.python.org/3/</a></p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-71885eb elementor-widget elementor-widget-heading" data-id="71885eb" data-element_type="widget" data-widget_type="heading.default">
				<div class="elementor-widget-container">
			<h2 class="elementor-heading-title elementor-size-default">Il framework BackTrader</h2>		</div>
				</div>
				<div class="elementor-element elementor-element-c866f44 elementor-widget elementor-widget-text-editor" data-id="c866f44" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Per installare pacchetti e framework di terze parti in Python utilizziamo uno strumento chiamato &#8220;pip&#8221; (pip3 in python3). Questo è lo strumento di gestione dei pacchetti in python, cioè si occupa del download, l&#8217;installazione, l&#8217;aggiornamento e la rimozione del codice sorgente richiesto dai pacchetti di terze parti.

Apri un terminale o una console e digita il seguente comando: <code style="color: #e83e8c;">pip3 install backtrader</code>

Semplice! Dovresti vedere pip entrare in azione ed iniziare a scaricare / installare i pacchetti.

Una volta completato puoi verificare l&#8217;installazione aprendo una shell python, digitando python3 nel terminale e premendo invio. Quindi digitare i seguenti comandi, una riga alla volta (premendo invio alla fine di ogni riga):					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-c56f769 elementor-widget elementor-widget-bdt-source-code" data-id="c56f769" data-element_type="widget" data-widget_type="bdt-source-code.default">
				<div class="elementor-widget-container">
			
        <div class="bdt-source-code prism-okaidia">

                            <button class="bdt-copy-button">Copy                </button>
            
            <pre class="language-py">
            <code>import backtrader
print(backtrader.__version__)</code>
        </pre>

        </div>
		</div>
				</div>
				<div class="elementor-element elementor-element-f23413e elementor-widget elementor-widget-text-editor" data-id="f23413e" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				<p>Dovresti vedere il numero della versione stampato a video:</p>					</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-d6080fb elementor-widget elementor-widget-image" data-id="d6080fb" data-element_type="widget" data-widget_type="image.default">
				<div class="elementor-widget-container">
								<div class="elementor-image">
												<img width="647" height="469" src="https://datatrading.info/wp-content/uploads/2018/01/backtrader-install-trading-algoritmico.jpg" class="attachment-large size-large" alt="" loading="lazy" />														</div>
						</div>
				</div>
				<div class="elementor-element elementor-element-ec6a0a4 elementor-widget elementor-widget-text-editor" data-id="ec6a0a4" data-element_type="widget" data-widget_type="text-editor.default">
				<div class="elementor-widget-container">
								<div class="elementor-text-editor elementor-clearfix">
				Se ricevi degli errori, puoi pubblicali di seguito nella sezione dei commenti e possiamo dare loro un&#8217;occhiata (e quindi aggiornare questa pagina le secondo necessità)					</div>
						</div>
				</div>
						</div>
					</div>
		</div>
								</div>
					</div>
		</section>
									</div>
			</div>
					</div>
		<p>L'articolo <a rel="nofollow" href="https://datatrading.info/setup-di-base-per-python-e-backtrader/">Setup di base per Python e BackTrader</a> proviene da <a rel="nofollow" href="https://datatrading.info">Data Trading</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
